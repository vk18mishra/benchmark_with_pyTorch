Total duration: 137.815s
File: /opt/conda/lib/python3.8/posixpath.py
File duration: 3.29716s (2.39%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Common operations on Posix pathnames.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Instead of importing this module directly, import os and refer to
     4|         0|            0|            0|  0.00%|this module as os.path.  The "os.path" name is an alias for this
     5|         0|            0|            0|  0.00%|module on Posix systems; on other systems (e.g. Windows),
     6|         0|            0|            0|  0.00%|os.path provides the same operations in a manner specific to that
     7|         0|            0|            0|  0.00%|platform, and is an alias to another module (e.g. ntpath).
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|Some of this can actually be useful on non-Posix systems too, e.g.
    10|         0|            0|            0|  0.00%|for manipulation of the pathname component of URLs.
    11|         0|            0|            0|  0.00%|"""
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|# Strings representing various path-related bits and pieces.
    14|         0|            0|            0|  0.00%|# These are primarily for export; internally, they are hardcoded.
    15|         0|            0|            0|  0.00%|# Should be set before imports for resolving cyclic dependency.
    16|         0|            0|            0|  0.00%|curdir = '.'
    17|         0|            0|            0|  0.00%|pardir = '..'
    18|         0|            0|            0|  0.00%|extsep = '.'
    19|         0|            0|            0|  0.00%|sep = '/'
    20|         0|            0|            0|  0.00%|pathsep = ':'
    21|         0|            0|            0|  0.00%|defpath = '/bin:/usr/bin'
    22|         0|            0|            0|  0.00%|altsep = None
    23|         0|            0|            0|  0.00%|devnull = '/dev/null'
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|import os
    26|         0|            0|            0|  0.00%|import sys
    27|         0|            0|            0|  0.00%|import stat
    28|         0|            0|            0|  0.00%|import genericpath
    29|         0|            0|            0|  0.00%|from genericpath import *
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|__all__ = ["normcase","isabs","join","splitdrive","split","splitext",
    32|         0|            0|            0|  0.00%|           "basename","dirname","commonprefix","getsize","getmtime",
    33|         0|            0|            0|  0.00%|           "getatime","getctime","islink","exists","lexists","isdir","isfile",
    34|         0|            0|            0|  0.00%|           "ismount", "expanduser","expandvars","normpath","abspath",
    35|         0|            0|            0|  0.00%|           "samefile","sameopenfile","samestat",
    36|         0|            0|            0|  0.00%|           "curdir","pardir","sep","pathsep","defpath","altsep","extsep",
    37|         0|            0|            0|  0.00%|           "devnull","realpath","supports_unicode_filenames","relpath",
    38|         0|            0|            0|  0.00%|           "commonpath"]
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|     17189|    0.0671597|  3.90713e-06|  0.05%|def _get_sep(path):
    42|     17189|    0.0964034|  5.60843e-06|  0.07%|    if isinstance(path, bytes):
    43|         0|            0|            0|  0.00%|        return b'/'
    44|         0|            0|            0|  0.00%|    else:
    45|     17189|    0.0610735|  3.55306e-06|  0.04%|        return '/'
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|# Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.
    48|         0|            0|            0|  0.00%|# On MS-DOS this may also turn slashes into backslashes; however, other
    49|         0|            0|            0|  0.00%|# normalizations (such as optimizing '../' away) are not allowed
    50|         0|            0|            0|  0.00%|# (another function should be defined to do that).
    51|         0|            0|            0|  0.00%|
    52|      1601|   0.00651145|  4.06711e-06|  0.00%|def normcase(s):
    53|         0|            0|            0|  0.00%|    """Normalize case of pathname.  Has no effect under Posix"""
    54|      1601|    0.0094645|  5.91162e-06|  0.01%|    return os.fspath(s)
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|# Return whether a path is absolute.
    58|         0|            0|            0|  0.00%|# Trivial in Posix, harder on the Mac or MS-DOS.
    59|         0|            0|            0|  0.00%|
    60|      4801|    0.0201912|  4.20562e-06|  0.01%|def isabs(s):
    61|         0|            0|            0|  0.00%|    """Test whether a path is absolute"""
    62|      4801|    0.0281348|   5.8602e-06|  0.02%|    s = os.fspath(s)
    63|      4801|    0.0537291|  1.11912e-05|  0.04%|    sep = _get_sep(s)
(call)|      4801|    0.0620923|  1.29332e-05|  0.05%|# /opt/conda/lib/python3.8/posixpath.py:41 _get_sep
    64|      4801|    0.0296214|  6.16983e-06|  0.02%|    return s.startswith(sep)
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|# Join pathnames.
    68|         0|            0|            0|  0.00%|# Ignore the previous parts if a part is absolute.
    69|         0|            0|            0|  0.00%|# Insert a '/' unless the first part is empty or already ends in '/'.
    70|         0|            0|            0|  0.00%|
    71|     12388|    0.0585878|   4.7294e-06|  0.04%|def join(a, *p):
    72|         0|            0|            0|  0.00%|    """Join two or more pathname components, inserting '/' as needed.
    73|         0|            0|            0|  0.00%|    If any component is an absolute path, all previous path components
    74|         0|            0|            0|  0.00%|    will be discarded.  An empty last part will result in a path that
    75|         0|            0|            0|  0.00%|    ends with a separator."""
    76|     12388|     0.078409|  6.32943e-06|  0.06%|    a = os.fspath(a)
    77|     12388|     0.145113|   1.1714e-05|  0.11%|    sep = _get_sep(a)
(call)|     12388|     0.162544|  1.31211e-05|  0.12%|# /opt/conda/lib/python3.8/posixpath.py:41 _get_sep
    78|     12388|    0.0495243|  3.99776e-06|  0.04%|    path = a
    79|     12388|    0.0463574|  3.74212e-06|  0.03%|    try:
    80|     12388|    0.0462182|  3.73088e-06|  0.03%|        if not p:
    81|         0|            0|            0|  0.00%|            path[:0] + sep  #23780: Ensure compatible data type even if p is null.
    82|     24776|     0.106358|   4.2928e-06|  0.08%|        for b in map(os.fspath, p):
    83|     12388|    0.0761693|  6.14863e-06|  0.06%|            if b.startswith(sep):
    84|         0|            0|            0|  0.00%|                path = b
    85|     12388|    0.0736623|  5.94626e-06|  0.05%|            elif not path or path.endswith(sep):
    86|      1600|   0.00672698|  4.20436e-06|  0.00%|                path += b
    87|         0|            0|            0|  0.00%|            else:
    88|     10788|    0.0462816|   4.2901e-06|  0.03%|                path += sep + b
    89|         0|            0|            0|  0.00%|    except (TypeError, AttributeError, BytesWarning):
    90|         0|            0|            0|  0.00%|        genericpath._check_arg_types('join', a, *p)
    91|         0|            0|            0|  0.00%|        raise
    92|     12388|    0.0455575|  3.67755e-06|  0.03%|    return path
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|# Split a path in head (everything up to the last '/') and tail (the
    96|         0|            0|            0|  0.00%|# rest).  If the path ends in '/', tail will be empty.  If there is no
    97|         0|            0|            0|  0.00%|# '/' in the path, head  will be empty.
    98|         0|            0|            0|  0.00%|# Trailing '/'es are stripped from head unless it is the root.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|def split(p):
   101|         0|            0|            0|  0.00%|    """Split a pathname.  Returns tuple "(head, tail)" where "tail" is
   102|         0|            0|            0|  0.00%|    everything after the final slash.  Either part may be empty."""
   103|         0|            0|            0|  0.00%|    p = os.fspath(p)
   104|         0|            0|            0|  0.00%|    sep = _get_sep(p)
   105|         0|            0|            0|  0.00%|    i = p.rfind(sep) + 1
   106|         0|            0|            0|  0.00%|    head, tail = p[:i], p[i:]
   107|         0|            0|            0|  0.00%|    if head and head != sep*len(head):
   108|         0|            0|            0|  0.00%|        head = head.rstrip(sep)
   109|         0|            0|            0|  0.00%|    return head, tail
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|# Split a path in root and extension.
   113|         0|            0|            0|  0.00%|# The extension is everything starting at the last dot in the last
   114|         0|            0|            0|  0.00%|# pathname component; the root is everything before that.
   115|         0|            0|            0|  0.00%|# It is always true that root + ext == p.
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|def splitext(p):
   118|         0|            0|            0|  0.00%|    p = os.fspath(p)
   119|         0|            0|            0|  0.00%|    if isinstance(p, bytes):
   120|         0|            0|            0|  0.00%|        sep = b'/'
   121|         0|            0|            0|  0.00%|        extsep = b'.'
   122|         0|            0|            0|  0.00%|    else:
   123|         0|            0|            0|  0.00%|        sep = '/'
   124|         0|            0|            0|  0.00%|        extsep = '.'
   125|         0|            0|            0|  0.00%|    return genericpath._splitext(p, sep, None, extsep)
   126|         0|            0|            0|  0.00%|splitext.__doc__ = genericpath._splitext.__doc__
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|# Split a pathname into a drive specification and the rest of the
   129|         0|            0|            0|  0.00%|# path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|def splitdrive(p):
   132|         0|            0|            0|  0.00%|    """Split a pathname into drive and path. On Posix, drive is always
   133|         0|            0|            0|  0.00%|    empty."""
   134|         0|            0|            0|  0.00%|    p = os.fspath(p)
   135|         0|            0|            0|  0.00%|    return p[:0], p
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|# Return the tail (basename) part of a path, same as split(path)[1].
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|def basename(p):
   141|         0|            0|            0|  0.00%|    """Returns the final component of a pathname"""
   142|         0|            0|            0|  0.00%|    p = os.fspath(p)
   143|         0|            0|            0|  0.00%|    sep = _get_sep(p)
   144|         0|            0|            0|  0.00%|    i = p.rfind(sep) + 1
   145|         0|            0|            0|  0.00%|    return p[i:]
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|# Return the head (dirname) part of a path, same as split(path)[0].
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|def dirname(p):
   151|         0|            0|            0|  0.00%|    """Returns the directory component of a pathname"""
   152|         0|            0|            0|  0.00%|    p = os.fspath(p)
   153|         0|            0|            0|  0.00%|    sep = _get_sep(p)
   154|         0|            0|            0|  0.00%|    i = p.rfind(sep) + 1
   155|         0|            0|            0|  0.00%|    head = p[:i]
   156|         0|            0|            0|  0.00%|    if head and head != sep*len(head):
   157|         0|            0|            0|  0.00%|        head = head.rstrip(sep)
   158|         0|            0|            0|  0.00%|    return head
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|# Is a path a symbolic link?
   162|         0|            0|            0|  0.00%|# This will always return false on systems where os.lstat doesn't exist.
   163|         0|            0|            0|  0.00%|
   164|     12387|    0.0530658|  4.28399e-06|  0.04%|def islink(path):
   165|         0|            0|            0|  0.00%|    """Test whether a path is a symbolic link"""
   166|     12387|    0.0482304|  3.89363e-06|  0.03%|    try:
   167|     12387|     0.194305|  1.56862e-05|  0.14%|        st = os.lstat(path)
   168|         0|            0|            0|  0.00%|    except (OSError, ValueError, AttributeError):
   169|         0|            0|            0|  0.00%|        return False
   170|     12387|    0.0821342|  6.63068e-06|  0.06%|    return stat.S_ISLNK(st.st_mode)
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|# Being true for dangling symbolic links is also useful.
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|def lexists(path):
   175|         0|            0|            0|  0.00%|    """Test whether a path exists.  Returns True for broken symbolic links"""
   176|         0|            0|            0|  0.00%|    try:
   177|         0|            0|            0|  0.00%|        os.lstat(path)
   178|         0|            0|            0|  0.00%|    except (OSError, ValueError):
   179|         0|            0|            0|  0.00%|        return False
   180|         0|            0|            0|  0.00%|    return True
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|# Is a path a mount point?
   184|         0|            0|            0|  0.00%|# (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|def ismount(path):
   187|         0|            0|            0|  0.00%|    """Test whether a path is a mount point"""
   188|         0|            0|            0|  0.00%|    try:
   189|         0|            0|            0|  0.00%|        s1 = os.lstat(path)
   190|         0|            0|            0|  0.00%|    except (OSError, ValueError):
   191|         0|            0|            0|  0.00%|        # It doesn't exist -- so not a mount point. :-)
   192|         0|            0|            0|  0.00%|        return False
   193|         0|            0|            0|  0.00%|    else:
   194|         0|            0|            0|  0.00%|        # A symlink can never be a mount point
   195|         0|            0|            0|  0.00%|        if stat.S_ISLNK(s1.st_mode):
   196|         0|            0|            0|  0.00%|            return False
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   199|         0|            0|            0|  0.00%|        parent = join(path, b'..')
   200|         0|            0|            0|  0.00%|    else:
   201|         0|            0|            0|  0.00%|        parent = join(path, '..')
   202|         0|            0|            0|  0.00%|    parent = realpath(parent)
   203|         0|            0|            0|  0.00%|    try:
   204|         0|            0|            0|  0.00%|        s2 = os.lstat(parent)
   205|         0|            0|            0|  0.00%|    except (OSError, ValueError):
   206|         0|            0|            0|  0.00%|        return False
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    dev1 = s1.st_dev
   209|         0|            0|            0|  0.00%|    dev2 = s2.st_dev
   210|         0|            0|            0|  0.00%|    if dev1 != dev2:
   211|         0|            0|            0|  0.00%|        return True     # path/.. on a different device as path
   212|         0|            0|            0|  0.00%|    ino1 = s1.st_ino
   213|         0|            0|            0|  0.00%|    ino2 = s2.st_ino
   214|         0|            0|            0|  0.00%|    if ino1 == ino2:
   215|         0|            0|            0|  0.00%|        return True     # path/.. is the same i-node as path
   216|         0|            0|            0|  0.00%|    return False
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|# Expand paths beginning with '~' or '~user'.
   220|         0|            0|            0|  0.00%|# '~' means $HOME; '~user' means that user's home directory.
   221|         0|            0|            0|  0.00%|# If the path doesn't begin with '~', or if the user or $HOME is unknown,
   222|         0|            0|            0|  0.00%|# the path is returned unchanged (leaving error reporting to whatever
   223|         0|            0|            0|  0.00%|# function is called with the expanded path as argument).
   224|         0|            0|            0|  0.00%|# See also module 'glob' for expansion of *, ? and [...] in pathnames.
   225|         0|            0|            0|  0.00%|# (A function should also be defined to do full *sh-style environment
   226|         0|            0|            0|  0.00%|# variable expansion.)
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|def expanduser(path):
   229|         0|            0|            0|  0.00%|    """Expand ~ and ~user constructions.  If user or $HOME is unknown,
   230|         0|            0|            0|  0.00%|    do nothing."""
   231|         0|            0|            0|  0.00%|    path = os.fspath(path)
   232|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   233|         0|            0|            0|  0.00%|        tilde = b'~'
   234|         0|            0|            0|  0.00%|    else:
   235|         0|            0|            0|  0.00%|        tilde = '~'
   236|         0|            0|            0|  0.00%|    if not path.startswith(tilde):
   237|         0|            0|            0|  0.00%|        return path
   238|         0|            0|            0|  0.00%|    sep = _get_sep(path)
   239|         0|            0|            0|  0.00%|    i = path.find(sep, 1)
   240|         0|            0|            0|  0.00%|    if i < 0:
   241|         0|            0|            0|  0.00%|        i = len(path)
   242|         0|            0|            0|  0.00%|    if i == 1:
   243|         0|            0|            0|  0.00%|        if 'HOME' not in os.environ:
   244|         0|            0|            0|  0.00%|            import pwd
   245|         0|            0|            0|  0.00%|            try:
   246|         0|            0|            0|  0.00%|                userhome = pwd.getpwuid(os.getuid()).pw_dir
   247|         0|            0|            0|  0.00%|            except KeyError:
   248|         0|            0|            0|  0.00%|                # bpo-10496: if the current user identifier doesn't exist in the
   249|         0|            0|            0|  0.00%|                # password database, return the path unchanged
   250|         0|            0|            0|  0.00%|                return path
   251|         0|            0|            0|  0.00%|        else:
   252|         0|            0|            0|  0.00%|            userhome = os.environ['HOME']
   253|         0|            0|            0|  0.00%|    else:
   254|         0|            0|            0|  0.00%|        import pwd
   255|         0|            0|            0|  0.00%|        name = path[1:i]
   256|         0|            0|            0|  0.00%|        if isinstance(name, bytes):
   257|         0|            0|            0|  0.00%|            name = str(name, 'ASCII')
   258|         0|            0|            0|  0.00%|        try:
   259|         0|            0|            0|  0.00%|            pwent = pwd.getpwnam(name)
   260|         0|            0|            0|  0.00%|        except KeyError:
   261|         0|            0|            0|  0.00%|            # bpo-10496: if the user name from the path doesn't exist in the
   262|         0|            0|            0|  0.00%|            # password database, return the path unchanged
   263|         0|            0|            0|  0.00%|            return path
   264|         0|            0|            0|  0.00%|        userhome = pwent.pw_dir
   265|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   266|         0|            0|            0|  0.00%|        userhome = os.fsencode(userhome)
   267|         0|            0|            0|  0.00%|        root = b'/'
   268|         0|            0|            0|  0.00%|    else:
   269|         0|            0|            0|  0.00%|        root = '/'
   270|         0|            0|            0|  0.00%|    userhome = userhome.rstrip(root)
   271|         0|            0|            0|  0.00%|    return (userhome + path[i:]) or root
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|# Expand paths containing shell variable substitutions.
   275|         0|            0|            0|  0.00%|# This expands the forms $variable and ${variable} only.
   276|         0|            0|            0|  0.00%|# Non-existent variables are left unchanged.
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|_varprog = None
   279|         0|            0|            0|  0.00%|_varprogb = None
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|def expandvars(path):
   282|         0|            0|            0|  0.00%|    """Expand shell variables of form $var and ${var}.  Unknown variables
   283|         0|            0|            0|  0.00%|    are left unchanged."""
   284|         0|            0|            0|  0.00%|    path = os.fspath(path)
   285|         0|            0|            0|  0.00%|    global _varprog, _varprogb
   286|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   287|         0|            0|            0|  0.00%|        if b'$' not in path:
   288|         0|            0|            0|  0.00%|            return path
   289|         0|            0|            0|  0.00%|        if not _varprogb:
   290|         0|            0|            0|  0.00%|            import re
   291|         0|            0|            0|  0.00%|            _varprogb = re.compile(br'\$(\w+|\{[^}]*\})', re.ASCII)
   292|         0|            0|            0|  0.00%|        search = _varprogb.search
   293|         0|            0|            0|  0.00%|        start = b'{'
   294|         0|            0|            0|  0.00%|        end = b'}'
   295|         0|            0|            0|  0.00%|        environ = getattr(os, 'environb', None)
   296|         0|            0|            0|  0.00%|    else:
   297|         0|            0|            0|  0.00%|        if '$' not in path:
   298|         0|            0|            0|  0.00%|            return path
   299|         0|            0|            0|  0.00%|        if not _varprog:
   300|         0|            0|            0|  0.00%|            import re
   301|         0|            0|            0|  0.00%|            _varprog = re.compile(r'\$(\w+|\{[^}]*\})', re.ASCII)
   302|         0|            0|            0|  0.00%|        search = _varprog.search
   303|         0|            0|            0|  0.00%|        start = '{'
   304|         0|            0|            0|  0.00%|        end = '}'
   305|         0|            0|            0|  0.00%|        environ = os.environ
   306|         0|            0|            0|  0.00%|    i = 0
   307|         0|            0|            0|  0.00%|    while True:
   308|         0|            0|            0|  0.00%|        m = search(path, i)
   309|         0|            0|            0|  0.00%|        if not m:
   310|         0|            0|            0|  0.00%|            break
   311|         0|            0|            0|  0.00%|        i, j = m.span(0)
   312|         0|            0|            0|  0.00%|        name = m.group(1)
   313|         0|            0|            0|  0.00%|        if name.startswith(start) and name.endswith(end):
   314|         0|            0|            0|  0.00%|            name = name[1:-1]
   315|         0|            0|            0|  0.00%|        try:
   316|         0|            0|            0|  0.00%|            if environ is None:
   317|         0|            0|            0|  0.00%|                value = os.fsencode(os.environ[os.fsdecode(name)])
   318|         0|            0|            0|  0.00%|            else:
   319|         0|            0|            0|  0.00%|                value = environ[name]
   320|         0|            0|            0|  0.00%|        except KeyError:
   321|         0|            0|            0|  0.00%|            i = j
   322|         0|            0|            0|  0.00%|        else:
   323|         0|            0|            0|  0.00%|            tail = path[j:]
   324|         0|            0|            0|  0.00%|            path = path[:i] + value
   325|         0|            0|            0|  0.00%|            i = len(path)
   326|         0|            0|            0|  0.00%|            path += tail
   327|         0|            0|            0|  0.00%|    return path
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.
   331|         0|            0|            0|  0.00%|# It should be understood that this may change the meaning of the path
   332|         0|            0|            0|  0.00%|# if it contains symbolic links!
   333|         0|            0|            0|  0.00%|
   334|      3201|    0.0165732|   5.1775e-06|  0.01%|def normpath(path):
   335|         0|            0|            0|  0.00%|    """Normalize path, eliminating double slashes, etc."""
   336|      3201|    0.0225067|  7.03115e-06|  0.02%|    path = os.fspath(path)
   337|      3201|    0.0218165|  6.81552e-06|  0.02%|    if isinstance(path, bytes):
   338|         0|            0|            0|  0.00%|        sep = b'/'
   339|         0|            0|            0|  0.00%|        empty = b''
   340|         0|            0|            0|  0.00%|        dot = b'.'
   341|         0|            0|            0|  0.00%|        dotdot = b'..'
   342|         0|            0|            0|  0.00%|    else:
   343|      3201|    0.0151446|   4.7312e-06|  0.01%|        sep = '/'
   344|      3201|    0.0145879|  4.55729e-06|  0.01%|        empty = ''
   345|      3201|    0.0143192|  4.47335e-06|  0.01%|        dot = '.'
   346|      3201|    0.0142868|  4.46322e-06|  0.01%|        dotdot = '..'
   347|      3201|    0.0141923|  4.43372e-06|  0.01%|    if path == empty:
   348|         0|            0|            0|  0.00%|        return dot
   349|      3201|    0.0218067|  6.81247e-06|  0.02%|    initial_slashes = path.startswith(sep)
   350|         0|            0|            0|  0.00%|    # POSIX allows one or two initial slashes, but treats three or more
   351|         0|            0|            0|  0.00%|    # as single slash.
   352|      6402|     0.028805|  4.49938e-06|  0.02%|    if (initial_slashes and
   353|      3201|     0.022028|  6.88159e-06|  0.02%|        path.startswith(sep*2) and not path.startswith(sep*3)):
   354|         0|            0|            0|  0.00%|        initial_slashes = 2
   355|      3201|    0.0228112|  7.12627e-06|  0.02%|    comps = path.split(sep)
   356|      3201|    0.0143082|  4.46992e-06|  0.01%|    new_comps = []
   357|     31179|     0.126304|  4.05094e-06|  0.09%|    for comp in comps:
   358|     27978|     0.115545|  4.12984e-06|  0.08%|        if comp in (empty, dot):
   359|      3201|     0.012804|  4.00001e-06|  0.01%|            continue
   360|     24777|      0.09834|    3.969e-06|  0.07%|        if (comp != dotdot or (not initial_slashes and not new_comps) or
   361|         0|            0|            0|  0.00%|             (new_comps and new_comps[-1] == dotdot)):
   362|     24777|     0.140631|  5.67589e-06|  0.10%|            new_comps.append(comp)
   363|         0|            0|            0|  0.00%|        elif new_comps:
   364|         0|            0|            0|  0.00%|            new_comps.pop()
   365|      3201|    0.0131001|  4.09252e-06|  0.01%|    comps = new_comps
   366|      3201|    0.0204985|  6.40378e-06|  0.01%|    path = sep.join(comps)
   367|      3201|    0.0131783|  4.11695e-06|  0.01%|    if initial_slashes:
   368|      3201|    0.0150492|  4.70141e-06|  0.01%|        path = sep*initial_slashes + path
   369|      3201|    0.0132408|  4.13646e-06|  0.01%|    return path or dot
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|      3201|    0.0142448|  4.45011e-06|  0.01%|def abspath(path):
   373|         0|            0|            0|  0.00%|    """Return an absolute path."""
   374|      3201|    0.0197799|  6.17929e-06|  0.01%|    path = os.fspath(path)
   375|      3201|    0.0380814|  1.18967e-05|  0.03%|    if not isabs(path):
(call)|      3201|     0.129562|  4.04754e-05|  0.09%|# /opt/conda/lib/python3.8/posixpath.py:60 isabs
   376|         1|  8.34465e-06|  8.34465e-06|  0.00%|        if isinstance(path, bytes):
   377|         0|            0|            0|  0.00%|            cwd = os.getcwdb()
   378|         0|            0|            0|  0.00%|        else:
   379|         1|  1.57356e-05|  1.57356e-05|  0.00%|            cwd = os.getcwd()
   380|         1|   2.6226e-05|   2.6226e-05|  0.00%|        path = join(cwd, path)
(call)|         1|  0.000124693|  0.000124693|  0.00%|# /opt/conda/lib/python3.8/posixpath.py:71 join
   381|      3201|    0.0438559|  1.37007e-05|  0.03%|    return normpath(path)
(call)|      3201|     0.811877|  0.000253632|  0.59%|# /opt/conda/lib/python3.8/posixpath.py:334 normpath
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|# Return a canonical path (i.e. the absolute location of a file on the
   385|         0|            0|            0|  0.00%|# filesystem).
   386|         0|            0|            0|  0.00%|
   387|      1600|   0.00743747|  4.64842e-06|  0.01%|def realpath(filename):
   388|         0|            0|            0|  0.00%|    """Return the canonical path of the specified filename, eliminating any
   389|         0|            0|            0|  0.00%|symbolic links encountered in the path."""
   390|      1600|   0.00968885|  6.05553e-06|  0.01%|    filename = os.fspath(filename)
   391|      1600|    0.0229118|  1.43199e-05|  0.02%|    path, ok = _joinrealpath(filename[:0], filename, {})
(call)|      1600|      2.16401|   0.00135251|  1.57%|# /opt/conda/lib/python3.8/posixpath.py:396 _joinrealpath
   392|      1600|    0.0195591|  1.22245e-05|  0.01%|    return abspath(path)
(call)|      1600|     0.528138|  0.000330086|  0.38%|# /opt/conda/lib/python3.8/posixpath.py:372 abspath
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|# Join two paths, normalizing and eliminating any symbolic links
   395|         0|            0|            0|  0.00%|# encountered in the second path.
   396|      1600|   0.00856161|  5.35101e-06|  0.01%|def _joinrealpath(path, rest, seen):
   397|      1600|    0.0114384|  7.14898e-06|  0.01%|    if isinstance(path, bytes):
   398|         0|            0|            0|  0.00%|        sep = b'/'
   399|         0|            0|            0|  0.00%|        curdir = b'.'
   400|         0|            0|            0|  0.00%|        pardir = b'..'
   401|         0|            0|            0|  0.00%|    else:
   402|      1600|   0.00774169|  4.83856e-06|  0.01%|        sep = '/'
   403|      1600|   0.00751781|  4.69863e-06|  0.01%|        curdir = '.'
   404|      1600|   0.00751781|  4.69863e-06|  0.01%|        pardir = '..'
   405|         0|            0|            0|  0.00%|
   406|      1600|    0.0202718|  1.26699e-05|  0.01%|    if isabs(rest):
(call)|      1600|    0.0642068|  4.01293e-05|  0.05%|# /opt/conda/lib/python3.8/posixpath.py:60 isabs
   407|      1600|   0.00843477|  5.27173e-06|  0.01%|        rest = rest[1:]
   408|      1600|   0.00730443|  4.56527e-06|  0.01%|        path = sep
   409|         0|            0|            0|  0.00%|
   410|     13987|    0.0587296|  4.19887e-06|  0.04%|    while rest:
   411|     12387|    0.0845199|  6.82327e-06|  0.06%|        name, _, rest = rest.partition(sep)
   412|     12387|      0.05725|  4.62178e-06|  0.04%|        if not name or name == curdir:
   413|         0|            0|            0|  0.00%|            # current dir
   414|         0|            0|            0|  0.00%|            continue
   415|     12387|    0.0523763|  4.22833e-06|  0.04%|        if name == pardir:
   416|         0|            0|            0|  0.00%|            # parent dir
   417|         0|            0|            0|  0.00%|            if path:
   418|         0|            0|            0|  0.00%|                path, name = split(path)
   419|         0|            0|            0|  0.00%|                if name == pardir:
   420|         0|            0|            0|  0.00%|                    path = join(path, pardir, pardir)
   421|         0|            0|            0|  0.00%|            else:
   422|         0|            0|            0|  0.00%|                path = pardir
   423|         0|            0|            0|  0.00%|            continue
   424|     12387|     0.161945|  1.30738e-05|  0.12%|        newpath = join(path, name)
(call)|     12387|     0.941385|  7.59978e-05|  0.68%|# /opt/conda/lib/python3.8/posixpath.py:71 join
   425|     12387|     0.169437|  1.36786e-05|  0.12%|        if not islink(newpath):
(call)|     12387|     0.377735|  3.04945e-05|  0.27%|# /opt/conda/lib/python3.8/posixpath.py:164 islink
   426|     12387|     0.058079|  4.68871e-06|  0.04%|            path = newpath
   427|     12387|     0.052763|  4.25955e-06|  0.04%|            continue
   428|         0|            0|            0|  0.00%|        # Resolve the symbolic link
   429|         0|            0|            0|  0.00%|        if newpath in seen:
   430|         0|            0|            0|  0.00%|            # Already seen this path
   431|         0|            0|            0|  0.00%|            path = seen[newpath]
   432|         0|            0|            0|  0.00%|            if path is not None:
   433|         0|            0|            0|  0.00%|                # use cached value
   434|         0|            0|            0|  0.00%|                continue
   435|         0|            0|            0|  0.00%|            # The symlink is not resolved, so we must have a symlink loop.
   436|         0|            0|            0|  0.00%|            # Return already resolved part + rest of the path unchanged.
   437|         0|            0|            0|  0.00%|            return join(newpath, rest), False
   438|         0|            0|            0|  0.00%|        seen[newpath] = None # not resolved symlink
   439|         0|            0|            0|  0.00%|        path, ok = _joinrealpath(path, os.readlink(newpath), seen)
   440|         0|            0|            0|  0.00%|        if not ok:
   441|         0|            0|            0|  0.00%|            return join(path, rest), False
   442|         0|            0|            0|  0.00%|        seen[newpath] = path # resolved symlink
   443|         0|            0|            0|  0.00%|
   444|      1600|   0.00679517|  4.24698e-06|  0.00%|    return path, True
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|supports_unicode_filenames = (sys.platform == 'darwin')
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|def relpath(path, start=None):
   450|         0|            0|            0|  0.00%|    """Return a relative version of a path"""
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|    if not path:
   453|         0|            0|            0|  0.00%|        raise ValueError("no path specified")
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    path = os.fspath(path)
   456|         0|            0|            0|  0.00%|    if isinstance(path, bytes):
   457|         0|            0|            0|  0.00%|        curdir = b'.'
   458|         0|            0|            0|  0.00%|        sep = b'/'
   459|         0|            0|            0|  0.00%|        pardir = b'..'
   460|         0|            0|            0|  0.00%|    else:
   461|         0|            0|            0|  0.00%|        curdir = '.'
   462|         0|            0|            0|  0.00%|        sep = '/'
   463|         0|            0|            0|  0.00%|        pardir = '..'
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    if start is None:
   466|         0|            0|            0|  0.00%|        start = curdir
   467|         0|            0|            0|  0.00%|    else:
   468|         0|            0|            0|  0.00%|        start = os.fspath(start)
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    try:
   471|         0|            0|            0|  0.00%|        start_list = [x for x in abspath(start).split(sep) if x]
   472|         0|            0|            0|  0.00%|        path_list = [x for x in abspath(path).split(sep) if x]
   473|         0|            0|            0|  0.00%|        # Work out how much of the filepath is shared by start and path.
   474|         0|            0|            0|  0.00%|        i = len(commonprefix([start_list, path_list]))
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]
   477|         0|            0|            0|  0.00%|        if not rel_list:
   478|         0|            0|            0|  0.00%|            return curdir
   479|         0|            0|            0|  0.00%|        return join(*rel_list)
   480|         0|            0|            0|  0.00%|    except (TypeError, AttributeError, BytesWarning, DeprecationWarning):
   481|         0|            0|            0|  0.00%|        genericpath._check_arg_types('relpath', path, start)
   482|         0|            0|            0|  0.00%|        raise
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|# Return the longest common sub-path of the sequence of paths given as input.
   486|         0|            0|            0|  0.00%|# The paths are not normalized before comparing them (this is the
   487|         0|            0|            0|  0.00%|# responsibility of the caller). Any trailing separator is stripped from the
   488|         0|            0|            0|  0.00%|# returned path.
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|def commonpath(paths):
   491|         0|            0|            0|  0.00%|    """Given a sequence of path names, returns the longest common sub-path."""
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    if not paths:
   494|         0|            0|            0|  0.00%|        raise ValueError('commonpath() arg is an empty sequence')
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    paths = tuple(map(os.fspath, paths))
   497|         0|            0|            0|  0.00%|    if isinstance(paths[0], bytes):
   498|         0|            0|            0|  0.00%|        sep = b'/'
   499|         0|            0|            0|  0.00%|        curdir = b'.'
   500|         0|            0|            0|  0.00%|    else:
   501|         0|            0|            0|  0.00%|        sep = '/'
   502|         0|            0|            0|  0.00%|        curdir = '.'
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    try:
   505|         0|            0|            0|  0.00%|        split_paths = [path.split(sep) for path in paths]
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|        try:
   508|         0|            0|            0|  0.00%|            isabs, = set(p[:1] == sep for p in paths)
   509|         0|            0|            0|  0.00%|        except ValueError:
   510|         0|            0|            0|  0.00%|            raise ValueError("Can't mix absolute and relative paths") from None
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|        split_paths = [[c for c in s if c and c != curdir] for s in split_paths]
   513|         0|            0|            0|  0.00%|        s1 = min(split_paths)
   514|         0|            0|            0|  0.00%|        s2 = max(split_paths)
   515|         0|            0|            0|  0.00%|        common = s1
   516|         0|            0|            0|  0.00%|        for i, c in enumerate(s1):
   517|         0|            0|            0|  0.00%|            if c != s2[i]:
   518|         0|            0|            0|  0.00%|                common = s1[:i]
   519|         0|            0|            0|  0.00%|                break
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|        prefix = sep if isabs else sep[:0]
   522|         0|            0|            0|  0.00%|        return prefix + sep.join(common)
   523|         0|            0|            0|  0.00%|    except (TypeError, AttributeError):
   524|         0|            0|            0|  0.00%|        genericpath._check_arg_types('commonpath', *paths)
   525|         0|            0|            0|  0.00%|        raise
File: /opt/conda/lib/python3.8/inspect.py
File duration: 0.651244s (0.47%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Get useful information from live Python objects.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This module encapsulates the interface provided by the internal special
     4|         0|            0|            0|  0.00%|attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.
     5|         0|            0|            0|  0.00%|It also provides some help for examining source code and class layout.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|Here are some of the useful functions provided by this module:
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
    10|         0|            0|            0|  0.00%|        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
    11|         0|            0|            0|  0.00%|        isroutine() - check object types
    12|         0|            0|            0|  0.00%|    getmembers() - get members of an object that satisfy a given condition
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|    getfile(), getsourcefile(), getsource() - find an object's source code
    15|         0|            0|            0|  0.00%|    getdoc(), getcomments() - get documentation on an object
    16|         0|            0|            0|  0.00%|    getmodule() - determine the module that an object came from
    17|         0|            0|            0|  0.00%|    getclasstree() - arrange classes so as to represent their hierarchy
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|    getargvalues(), getcallargs() - get info about function arguments
    20|         0|            0|            0|  0.00%|    getfullargspec() - same, with support for Python 3 features
    21|         0|            0|            0|  0.00%|    formatargvalues() - format an argument spec
    22|         0|            0|            0|  0.00%|    getouterframes(), getinnerframes() - get info about frames
    23|         0|            0|            0|  0.00%|    currentframe() - get the current stack frame
    24|         0|            0|            0|  0.00%|    stack(), trace() - get info about frames on the stack or in a traceback
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|    signature() - get a Signature object for the callable
    27|         0|            0|            0|  0.00%|"""
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|# This module is in the public domain.  No warranties.
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|__author__ = ('Ka-Ping Yee <ping@lfw.org>',
    32|         0|            0|            0|  0.00%|              'Yury Selivanov <yselivanov@sprymix.com>')
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|import abc
    35|         0|            0|            0|  0.00%|import dis
    36|         0|            0|            0|  0.00%|import collections.abc
    37|         0|            0|            0|  0.00%|import enum
    38|         0|            0|            0|  0.00%|import importlib.machinery
    39|         0|            0|            0|  0.00%|import itertools
    40|         0|            0|            0|  0.00%|import linecache
    41|         0|            0|            0|  0.00%|import os
    42|         0|            0|            0|  0.00%|import re
    43|         0|            0|            0|  0.00%|import sys
    44|         0|            0|            0|  0.00%|import tokenize
    45|         0|            0|            0|  0.00%|import token
    46|         0|            0|            0|  0.00%|import types
    47|         0|            0|            0|  0.00%|import warnings
    48|         0|            0|            0|  0.00%|import functools
    49|         0|            0|            0|  0.00%|import builtins
    50|         0|            0|            0|  0.00%|from operator import attrgetter
    51|         0|            0|            0|  0.00%|from collections import namedtuple, OrderedDict
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|# Create constants for the compiler flags in Include/code.h
    54|         0|            0|            0|  0.00%|# We try to get them from dis to avoid duplication
    55|         0|            0|            0|  0.00%|mod_dict = globals()
    56|         0|            0|            0|  0.00%|for k, v in dis.COMPILER_FLAG_NAMES.items():
    57|         0|            0|            0|  0.00%|    mod_dict["CO_" + v] = k
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|# See Include/object.h
    60|         0|            0|            0|  0.00%|TPFLAGS_IS_ABSTRACT = 1 << 20
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|# ----------------------------------------------------------- type-checking
    63|      3364|    0.0139794|   4.1556e-06|  0.01%|def ismodule(object):
    64|         0|            0|            0|  0.00%|    """Return true if the object is a module.
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    Module objects provide these attributes:
    67|         0|            0|            0|  0.00%|        __cached__      pathname to byte compiled file
    68|         0|            0|            0|  0.00%|        __doc__         documentation string
    69|         0|            0|            0|  0.00%|        __file__        filename (missing for built-in modules)"""
    70|      3364|     0.019279|  5.73098e-06|  0.01%|    return isinstance(object, types.ModuleType)
    71|         0|            0|            0|  0.00%|
    72|      1708|   0.00666547|   3.9025e-06|  0.00%|def isclass(object):
    73|         0|            0|            0|  0.00%|    """Return true if the object is a class.
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    Class objects provide these attributes:
    76|         0|            0|            0|  0.00%|        __doc__         documentation string
    77|         0|            0|            0|  0.00%|        __module__      name of module in which this class was defined"""
    78|      1708|     0.010262|   6.0082e-06|  0.01%|    return isinstance(object, type)
    79|         0|            0|            0|  0.00%|
    80|         3|  1.81198e-05|  6.03994e-06|  0.00%|def ismethod(object):
    81|         0|            0|            0|  0.00%|    """Return true if the object is an instance method.
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    Instance method objects provide these attributes:
    84|         0|            0|            0|  0.00%|        __doc__         documentation string
    85|         0|            0|            0|  0.00%|        __name__        name with which this method was defined
    86|         0|            0|            0|  0.00%|        __func__        function object containing implementation of method
    87|         0|            0|            0|  0.00%|        __self__        instance to which this method is bound"""
    88|         3|  2.24113e-05|  7.47045e-06|  0.00%|    return isinstance(object, types.MethodType)
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|def ismethoddescriptor(object):
    91|         0|            0|            0|  0.00%|    """Return true if the object is a method descriptor.
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    But not if ismethod() or isclass() or isfunction() are true.
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    This is new in Python 2.2, and, for example, is true of int.__add__.
    96|         0|            0|            0|  0.00%|    An object passing this test has a __get__ attribute but not a __set__
    97|         0|            0|            0|  0.00%|    attribute, but beyond that the set of attributes varies.  __name__ is
    98|         0|            0|            0|  0.00%|    usually sensible, and __doc__ often is.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|    Methods implemented via descriptors that also pass one of the other
   101|         0|            0|            0|  0.00%|    tests return false from the ismethoddescriptor() test, simply because
   102|         0|            0|            0|  0.00%|    the other tests promise more -- you can, e.g., count on having the
   103|         0|            0|            0|  0.00%|    __func__ attribute (etc) when an object passes ismethod()."""
   104|         0|            0|            0|  0.00%|    if isclass(object) or ismethod(object) or isfunction(object):
   105|         0|            0|            0|  0.00%|        # mutual exclusion
   106|         0|            0|            0|  0.00%|        return False
   107|         0|            0|            0|  0.00%|    tp = type(object)
   108|         0|            0|            0|  0.00%|    return hasattr(tp, "__get__") and not hasattr(tp, "__set__")
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|def isdatadescriptor(object):
   111|         0|            0|            0|  0.00%|    """Return true if the object is a data descriptor.
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    Data descriptors have a __set__ or a __delete__ attribute.  Examples are
   114|         0|            0|            0|  0.00%|    properties (defined in Python) and getsets and members (defined in C).
   115|         0|            0|            0|  0.00%|    Typically, data descriptors will also have __name__ and __doc__ attributes
   116|         0|            0|            0|  0.00%|    (properties, getsets, and members have both of these attributes), but this
   117|         0|            0|            0|  0.00%|    is not guaranteed."""
   118|         0|            0|            0|  0.00%|    if isclass(object) or ismethod(object) or isfunction(object):
   119|         0|            0|            0|  0.00%|        # mutual exclusion
   120|         0|            0|            0|  0.00%|        return False
   121|         0|            0|            0|  0.00%|    tp = type(object)
   122|         0|            0|            0|  0.00%|    return hasattr(tp, "__set__") or hasattr(tp, "__delete__")
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|if hasattr(types, 'MemberDescriptorType'):
   125|         0|            0|            0|  0.00%|    # CPython and equivalent
   126|         0|            0|            0|  0.00%|    def ismemberdescriptor(object):
   127|         0|            0|            0|  0.00%|        """Return true if the object is a member descriptor.
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|        Member descriptors are specialized descriptors defined in extension
   130|         0|            0|            0|  0.00%|        modules."""
   131|         0|            0|            0|  0.00%|        return isinstance(object, types.MemberDescriptorType)
   132|         0|            0|            0|  0.00%|else:
   133|         0|            0|            0|  0.00%|    # Other implementations
   134|         0|            0|            0|  0.00%|    def ismemberdescriptor(object):
   135|         0|            0|            0|  0.00%|        """Return true if the object is a member descriptor.
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|        Member descriptors are specialized descriptors defined in extension
   138|         0|            0|            0|  0.00%|        modules."""
   139|         0|            0|            0|  0.00%|        return False
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|if hasattr(types, 'GetSetDescriptorType'):
   142|         0|            0|            0|  0.00%|    # CPython and equivalent
   143|         0|            0|            0|  0.00%|    def isgetsetdescriptor(object):
   144|         0|            0|            0|  0.00%|        """Return true if the object is a getset descriptor.
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|        getset descriptors are specialized descriptors defined in extension
   147|         0|            0|            0|  0.00%|        modules."""
   148|         0|            0|            0|  0.00%|        return isinstance(object, types.GetSetDescriptorType)
   149|         0|            0|            0|  0.00%|else:
   150|         0|            0|            0|  0.00%|    # Other implementations
   151|         0|            0|            0|  0.00%|    def isgetsetdescriptor(object):
   152|         0|            0|            0|  0.00%|        """Return true if the object is a getset descriptor.
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|        getset descriptors are specialized descriptors defined in extension
   155|         0|            0|            0|  0.00%|        modules."""
   156|         0|            0|            0|  0.00%|        return False
   157|         0|            0|            0|  0.00%|
   158|         3|  2.38419e-05|  7.94729e-06|  0.00%|def isfunction(object):
   159|         0|            0|            0|  0.00%|    """Return true if the object is a user-defined function.
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|    Function objects provide these attributes:
   162|         0|            0|            0|  0.00%|        __doc__         documentation string
   163|         0|            0|            0|  0.00%|        __name__        name with which this function was defined
   164|         0|            0|            0|  0.00%|        __code__        code object containing compiled function bytecode
   165|         0|            0|            0|  0.00%|        __defaults__    tuple of any default values for arguments
   166|         0|            0|            0|  0.00%|        __globals__     global namespace in which this function was defined
   167|         0|            0|            0|  0.00%|        __annotations__ dict of parameter annotations
   168|         0|            0|            0|  0.00%|        __kwdefaults__  dict of keyword only parameters with defaults"""
   169|         3|  2.16961e-05|  7.23203e-06|  0.00%|    return isinstance(object, types.FunctionType)
   170|         0|            0|            0|  0.00%|
   171|         1|  6.91414e-06|  6.91414e-06|  0.00%|def _has_code_flag(f, flag):
   172|         0|            0|            0|  0.00%|    """Return true if ``f`` is a function (or a method or functools.partial
   173|         0|            0|            0|  0.00%|    wrapper wrapping a function) whose code object has the given ``flag``
   174|         0|            0|            0|  0.00%|    set in its flags."""
   175|         1|   1.5974e-05|   1.5974e-05|  0.00%|    while ismethod(f):
(call)|         1|  1.14441e-05|  1.14441e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:80 ismethod
   176|         0|            0|            0|  0.00%|        f = f.__func__
   177|         1|  2.71797e-05|  2.71797e-05|  0.00%|    f = functools._unwrap_partial(f)
(call)|         1|  3.38554e-05|  3.38554e-05|  0.00%|# /opt/conda/lib/python3.8/functools.py:429 _unwrap_partial
   178|         1|   1.4782e-05|   1.4782e-05|  0.00%|    if not isfunction(f):
(call)|         1|  1.09673e-05|  1.09673e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:158 isfunction
   179|         0|            0|            0|  0.00%|        return False
   180|         1|  7.62939e-06|  7.62939e-06|  0.00%|    return bool(f.__code__.co_flags & flag)
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|def isgeneratorfunction(obj):
   183|         0|            0|            0|  0.00%|    """Return true if the object is a user-defined generator function.
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    Generator function objects provide the same attributes as functions.
   186|         0|            0|            0|  0.00%|    See help(isfunction) for a list of attributes."""
   187|         0|            0|            0|  0.00%|    return _has_code_flag(obj, CO_GENERATOR)
   188|         0|            0|            0|  0.00%|
   189|         1|   6.4373e-06|   6.4373e-06|  0.00%|def iscoroutinefunction(obj):
   190|         0|            0|            0|  0.00%|    """Return true if the object is a coroutine function.
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|    Coroutine functions are defined with "async def" syntax.
   193|         0|            0|            0|  0.00%|    """
   194|         1|  2.36034e-05|  2.36034e-05|  0.00%|    return _has_code_flag(obj, CO_COROUTINE)
(call)|         1|  0.000128746|  0.000128746|  0.00%|# /opt/conda/lib/python3.8/inspect.py:171 _has_code_flag
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|def isasyncgenfunction(obj):
   197|         0|            0|            0|  0.00%|    """Return true if the object is an asynchronous generator function.
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    Asynchronous generator functions are defined with "async def"
   200|         0|            0|            0|  0.00%|    syntax and have "yield" expressions in their body.
   201|         0|            0|            0|  0.00%|    """
   202|         0|            0|            0|  0.00%|    return _has_code_flag(obj, CO_ASYNC_GENERATOR)
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|def isasyncgen(object):
   205|         0|            0|            0|  0.00%|    """Return true if the object is an asynchronous generator."""
   206|         0|            0|            0|  0.00%|    return isinstance(object, types.AsyncGeneratorType)
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|def isgenerator(object):
   209|         0|            0|            0|  0.00%|    """Return true if the object is a generator.
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|    Generator objects provide these attributes:
   212|         0|            0|            0|  0.00%|        __iter__        defined to support iteration over container
   213|         0|            0|            0|  0.00%|        close           raises a new GeneratorExit exception inside the
   214|         0|            0|            0|  0.00%|                        generator to terminate the iteration
   215|         0|            0|            0|  0.00%|        gi_code         code object
   216|         0|            0|            0|  0.00%|        gi_frame        frame object or possibly None once the generator has
   217|         0|            0|            0|  0.00%|                        been exhausted
   218|         0|            0|            0|  0.00%|        gi_running      set to 1 when generator is executing, 0 otherwise
   219|         0|            0|            0|  0.00%|        next            return the next item from the container
   220|         0|            0|            0|  0.00%|        send            resumes the generator and "sends" a value that becomes
   221|         0|            0|            0|  0.00%|                        the result of the current yield-expression
   222|         0|            0|            0|  0.00%|        throw           used to raise an exception inside the generator"""
   223|         0|            0|            0|  0.00%|    return isinstance(object, types.GeneratorType)
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|def iscoroutine(object):
   226|         0|            0|            0|  0.00%|    """Return true if the object is a coroutine."""
   227|         0|            0|            0|  0.00%|    return isinstance(object, types.CoroutineType)
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|def isawaitable(object):
   230|         0|            0|            0|  0.00%|    """Return true if object can be passed to an ``await`` expression."""
   231|         0|            0|            0|  0.00%|    return (isinstance(object, types.CoroutineType) or
   232|         0|            0|            0|  0.00%|            isinstance(object, types.GeneratorType) and
   233|         0|            0|            0|  0.00%|                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or
   234|         0|            0|            0|  0.00%|            isinstance(object, collections.abc.Awaitable))
   235|         0|            0|            0|  0.00%|
   236|         3|  2.76566e-05|  9.21885e-06|  0.00%|def istraceback(object):
   237|         0|            0|            0|  0.00%|    """Return true if the object is a traceback.
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    Traceback objects provide these attributes:
   240|         0|            0|            0|  0.00%|        tb_frame        frame object at this level
   241|         0|            0|            0|  0.00%|        tb_lasti        index of last attempted instruction in bytecode
   242|         0|            0|            0|  0.00%|        tb_lineno       current line number in Python source code
   243|         0|            0|            0|  0.00%|        tb_next         next inner traceback object (called by this level)"""
   244|         3|  2.21729e-05|  7.39098e-06|  0.00%|    return isinstance(object, types.TracebackType)
   245|         0|            0|            0|  0.00%|
   246|         3|  6.34193e-05|  2.11398e-05|  0.00%|def isframe(object):
   247|         0|            0|            0|  0.00%|    """Return true if the object is a frame object.
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|    Frame objects provide these attributes:
   250|         0|            0|            0|  0.00%|        f_back          next outer frame object (this frame's caller)
   251|         0|            0|            0|  0.00%|        f_builtins      built-in namespace seen by this frame
   252|         0|            0|            0|  0.00%|        f_code          code object being executed in this frame
   253|         0|            0|            0|  0.00%|        f_globals       global namespace seen by this frame
   254|         0|            0|            0|  0.00%|        f_lasti         index of last attempted instruction in bytecode
   255|         0|            0|            0|  0.00%|        f_lineno        current line number in Python source code
   256|         0|            0|            0|  0.00%|        f_locals        local namespace seen by this frame
   257|         0|            0|            0|  0.00%|        f_trace         tracing function for this frame, or None"""
   258|         3|  2.76566e-05|  9.21885e-06|  0.00%|    return isinstance(object, types.FrameType)
   259|         0|            0|            0|  0.00%|
   260|        15|  7.60555e-05|  5.07037e-06|  0.00%|def iscode(object):
   261|         0|            0|            0|  0.00%|    """Return true if the object is a code object.
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    Code objects provide these attributes:
   264|         0|            0|            0|  0.00%|        co_argcount         number of arguments (not including *, ** args
   265|         0|            0|            0|  0.00%|                            or keyword only arguments)
   266|         0|            0|            0|  0.00%|        co_code             string of raw compiled bytecode
   267|         0|            0|            0|  0.00%|        co_cellvars         tuple of names of cell variables
   268|         0|            0|            0|  0.00%|        co_consts           tuple of constants used in the bytecode
   269|         0|            0|            0|  0.00%|        co_filename         name of file in which this code object was created
   270|         0|            0|            0|  0.00%|        co_firstlineno      number of first line in Python source code
   271|         0|            0|            0|  0.00%|        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
   272|         0|            0|            0|  0.00%|                            | 16=nested | 32=generator | 64=nofree | 128=coroutine
   273|         0|            0|            0|  0.00%|                            | 256=iterable_coroutine | 512=async_generator
   274|         0|            0|            0|  0.00%|        co_freevars         tuple of names of free variables
   275|         0|            0|            0|  0.00%|        co_posonlyargcount  number of positional only arguments
   276|         0|            0|            0|  0.00%|        co_kwonlyargcount   number of keyword only arguments (not including ** arg)
   277|         0|            0|            0|  0.00%|        co_lnotab           encoded mapping of line numbers to bytecode indices
   278|         0|            0|            0|  0.00%|        co_name             name with which this code object was defined
   279|         0|            0|            0|  0.00%|        co_names            tuple of names of local variables
   280|         0|            0|            0|  0.00%|        co_nlocals          number of local variables
   281|         0|            0|            0|  0.00%|        co_stacksize        virtual machine stack space required
   282|         0|            0|            0|  0.00%|        co_varnames         tuple of names of arguments and local variables"""
   283|        15|  9.15527e-05|  6.10352e-06|  0.00%|    return isinstance(object, types.CodeType)
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|def isbuiltin(object):
   286|         0|            0|            0|  0.00%|    """Return true if the object is a built-in function or method.
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    Built-in functions and methods provide these attributes:
   289|         0|            0|            0|  0.00%|        __doc__         documentation string
   290|         0|            0|            0|  0.00%|        __name__        original name of this function or method
   291|         0|            0|            0|  0.00%|        __self__        instance to which a method is bound, or None"""
   292|         0|            0|            0|  0.00%|    return isinstance(object, types.BuiltinFunctionType)
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|def isroutine(object):
   295|         0|            0|            0|  0.00%|    """Return true if the object is any kind of function or method."""
   296|         0|            0|            0|  0.00%|    return (isbuiltin(object)
   297|         0|            0|            0|  0.00%|            or isfunction(object)
   298|         0|            0|            0|  0.00%|            or ismethod(object)
   299|         0|            0|            0|  0.00%|            or ismethoddescriptor(object))
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|def isabstract(object):
   302|         0|            0|            0|  0.00%|    """Return true if the object is an abstract base class (ABC)."""
   303|         0|            0|            0|  0.00%|    if not isinstance(object, type):
   304|         0|            0|            0|  0.00%|        return False
   305|         0|            0|            0|  0.00%|    if object.__flags__ & TPFLAGS_IS_ABSTRACT:
   306|         0|            0|            0|  0.00%|        return True
   307|         0|            0|            0|  0.00%|    if not issubclass(type(object), abc.ABCMeta):
   308|         0|            0|            0|  0.00%|        return False
   309|         0|            0|            0|  0.00%|    if hasattr(object, '__abstractmethods__'):
   310|         0|            0|            0|  0.00%|        # It looks like ABCMeta.__new__ has finished running;
   311|         0|            0|            0|  0.00%|        # TPFLAGS_IS_ABSTRACT should have been accurate.
   312|         0|            0|            0|  0.00%|        return False
   313|         0|            0|            0|  0.00%|    # It looks like ABCMeta.__new__ has not finished running yet; we're
   314|         0|            0|            0|  0.00%|    # probably in __init_subclass__. We'll look for abstractmethods manually.
   315|         0|            0|            0|  0.00%|    for name, value in object.__dict__.items():
   316|         0|            0|            0|  0.00%|        if getattr(value, "__isabstractmethod__", False):
   317|         0|            0|            0|  0.00%|            return True
   318|         0|            0|            0|  0.00%|    for base in object.__bases__:
   319|         0|            0|            0|  0.00%|        for name in getattr(base, "__abstractmethods__", ()):
   320|         0|            0|            0|  0.00%|            value = getattr(object, name, None)
   321|         0|            0|            0|  0.00%|            if getattr(value, "__isabstractmethod__", False):
   322|         0|            0|            0|  0.00%|                return True
   323|         0|            0|            0|  0.00%|    return False
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|def getmembers(object, predicate=None):
   326|         0|            0|            0|  0.00%|    """Return all members of an object as (name, value) pairs sorted by name.
   327|         0|            0|            0|  0.00%|    Optionally, only return members that satisfy a given predicate."""
   328|         0|            0|            0|  0.00%|    if isclass(object):
   329|         0|            0|            0|  0.00%|        mro = (object,) + getmro(object)
   330|         0|            0|            0|  0.00%|    else:
   331|         0|            0|            0|  0.00%|        mro = ()
   332|         0|            0|            0|  0.00%|    results = []
   333|         0|            0|            0|  0.00%|    processed = set()
   334|         0|            0|            0|  0.00%|    names = dir(object)
   335|         0|            0|            0|  0.00%|    # :dd any DynamicClassAttributes to the list of names if object is a class;
   336|         0|            0|            0|  0.00%|    # this may result in duplicate entries if, for example, a virtual
   337|         0|            0|            0|  0.00%|    # attribute with the same name as a DynamicClassAttribute exists
   338|         0|            0|            0|  0.00%|    try:
   339|         0|            0|            0|  0.00%|        for base in object.__bases__:
   340|         0|            0|            0|  0.00%|            for k, v in base.__dict__.items():
   341|         0|            0|            0|  0.00%|                if isinstance(v, types.DynamicClassAttribute):
   342|         0|            0|            0|  0.00%|                    names.append(k)
   343|         0|            0|            0|  0.00%|    except AttributeError:
   344|         0|            0|            0|  0.00%|        pass
   345|         0|            0|            0|  0.00%|    for key in names:
   346|         0|            0|            0|  0.00%|        # First try to get the value via getattr.  Some descriptors don't
   347|         0|            0|            0|  0.00%|        # like calling their __get__ (see bug #1785), so fall back to
   348|         0|            0|            0|  0.00%|        # looking in the __dict__.
   349|         0|            0|            0|  0.00%|        try:
   350|         0|            0|            0|  0.00%|            value = getattr(object, key)
   351|         0|            0|            0|  0.00%|            # handle the duplicate key
   352|         0|            0|            0|  0.00%|            if key in processed:
   353|         0|            0|            0|  0.00%|                raise AttributeError
   354|         0|            0|            0|  0.00%|        except AttributeError:
   355|         0|            0|            0|  0.00%|            for base in mro:
   356|         0|            0|            0|  0.00%|                if key in base.__dict__:
   357|         0|            0|            0|  0.00%|                    value = base.__dict__[key]
   358|         0|            0|            0|  0.00%|                    break
   359|         0|            0|            0|  0.00%|            else:
   360|         0|            0|            0|  0.00%|                # could be a (currently) missing slot member, or a buggy
   361|         0|            0|            0|  0.00%|                # __dir__; discard and move on
   362|         0|            0|            0|  0.00%|                continue
   363|         0|            0|            0|  0.00%|        if not predicate or predicate(value):
   364|         0|            0|            0|  0.00%|            results.append((key, value))
   365|         0|            0|            0|  0.00%|        processed.add(key)
   366|         0|            0|            0|  0.00%|    results.sort(key=lambda pair: pair[0])
   367|         0|            0|            0|  0.00%|    return results
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|Attribute = namedtuple('Attribute', 'name kind defining_class object')
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|def classify_class_attrs(cls):
   372|         0|            0|            0|  0.00%|    """Return list of attribute-descriptor tuples.
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    For each name in dir(cls), the return list contains a 4-tuple
   375|         0|            0|            0|  0.00%|    with these elements:
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|        0. The name (a string).
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|        1. The kind of attribute this is, one of these strings:
   380|         0|            0|            0|  0.00%|               'class method'    created via classmethod()
   381|         0|            0|            0|  0.00%|               'static method'   created via staticmethod()
   382|         0|            0|            0|  0.00%|               'property'        created via property()
   383|         0|            0|            0|  0.00%|               'method'          any other flavor of method or descriptor
   384|         0|            0|            0|  0.00%|               'data'            not a method
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|        2. The class which defined this attribute (a class).
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|        3. The object as obtained by calling getattr; if this fails, or if the
   389|         0|            0|            0|  0.00%|           resulting object does not live anywhere in the class' mro (including
   390|         0|            0|            0|  0.00%|           metaclasses) then the object is looked up in the defining class's
   391|         0|            0|            0|  0.00%|           dict (found by walking the mro).
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    If one of the items in dir(cls) is stored in the metaclass it will now
   394|         0|            0|            0|  0.00%|    be discovered and not have None be listed as the class in which it was
   395|         0|            0|            0|  0.00%|    defined.  Any items whose home class cannot be discovered are skipped.
   396|         0|            0|            0|  0.00%|    """
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    mro = getmro(cls)
   399|         0|            0|            0|  0.00%|    metamro = getmro(type(cls)) # for attributes stored in the metaclass
   400|         0|            0|            0|  0.00%|    metamro = tuple(cls for cls in metamro if cls not in (type, object))
   401|         0|            0|            0|  0.00%|    class_bases = (cls,) + mro
   402|         0|            0|            0|  0.00%|    all_bases = class_bases + metamro
   403|         0|            0|            0|  0.00%|    names = dir(cls)
   404|         0|            0|            0|  0.00%|    # :dd any DynamicClassAttributes to the list of names;
   405|         0|            0|            0|  0.00%|    # this may result in duplicate entries if, for example, a virtual
   406|         0|            0|            0|  0.00%|    # attribute with the same name as a DynamicClassAttribute exists.
   407|         0|            0|            0|  0.00%|    for base in mro:
   408|         0|            0|            0|  0.00%|        for k, v in base.__dict__.items():
   409|         0|            0|            0|  0.00%|            if isinstance(v, types.DynamicClassAttribute):
   410|         0|            0|            0|  0.00%|                names.append(k)
   411|         0|            0|            0|  0.00%|    result = []
   412|         0|            0|            0|  0.00%|    processed = set()
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    for name in names:
   415|         0|            0|            0|  0.00%|        # Get the object associated with the name, and where it was defined.
   416|         0|            0|            0|  0.00%|        # Normal objects will be looked up with both getattr and directly in
   417|         0|            0|            0|  0.00%|        # its class' dict (in case getattr fails [bug #1785], and also to look
   418|         0|            0|            0|  0.00%|        # for a docstring).
   419|         0|            0|            0|  0.00%|        # For DynamicClassAttributes on the second pass we only look in the
   420|         0|            0|            0|  0.00%|        # class's dict.
   421|         0|            0|            0|  0.00%|        #
   422|         0|            0|            0|  0.00%|        # Getting an obj from the __dict__ sometimes reveals more than
   423|         0|            0|            0|  0.00%|        # using getattr.  Static and class methods are dramatic examples.
   424|         0|            0|            0|  0.00%|        homecls = None
   425|         0|            0|            0|  0.00%|        get_obj = None
   426|         0|            0|            0|  0.00%|        dict_obj = None
   427|         0|            0|            0|  0.00%|        if name not in processed:
   428|         0|            0|            0|  0.00%|            try:
   429|         0|            0|            0|  0.00%|                if name == '__dict__':
   430|         0|            0|            0|  0.00%|                    raise Exception("__dict__ is special, don't want the proxy")
   431|         0|            0|            0|  0.00%|                get_obj = getattr(cls, name)
   432|         0|            0|            0|  0.00%|            except Exception as exc:
   433|         0|            0|            0|  0.00%|                pass
   434|         0|            0|            0|  0.00%|            else:
   435|         0|            0|            0|  0.00%|                homecls = getattr(get_obj, "__objclass__", homecls)
   436|         0|            0|            0|  0.00%|                if homecls not in class_bases:
   437|         0|            0|            0|  0.00%|                    # if the resulting object does not live somewhere in the
   438|         0|            0|            0|  0.00%|                    # mro, drop it and search the mro manually
   439|         0|            0|            0|  0.00%|                    homecls = None
   440|         0|            0|            0|  0.00%|                    last_cls = None
   441|         0|            0|            0|  0.00%|                    # first look in the classes
   442|         0|            0|            0|  0.00%|                    for srch_cls in class_bases:
   443|         0|            0|            0|  0.00%|                        srch_obj = getattr(srch_cls, name, None)
   444|         0|            0|            0|  0.00%|                        if srch_obj is get_obj:
   445|         0|            0|            0|  0.00%|                            last_cls = srch_cls
   446|         0|            0|            0|  0.00%|                    # then check the metaclasses
   447|         0|            0|            0|  0.00%|                    for srch_cls in metamro:
   448|         0|            0|            0|  0.00%|                        try:
   449|         0|            0|            0|  0.00%|                            srch_obj = srch_cls.__getattr__(cls, name)
   450|         0|            0|            0|  0.00%|                        except AttributeError:
   451|         0|            0|            0|  0.00%|                            continue
   452|         0|            0|            0|  0.00%|                        if srch_obj is get_obj:
   453|         0|            0|            0|  0.00%|                            last_cls = srch_cls
   454|         0|            0|            0|  0.00%|                    if last_cls is not None:
   455|         0|            0|            0|  0.00%|                        homecls = last_cls
   456|         0|            0|            0|  0.00%|        for base in all_bases:
   457|         0|            0|            0|  0.00%|            if name in base.__dict__:
   458|         0|            0|            0|  0.00%|                dict_obj = base.__dict__[name]
   459|         0|            0|            0|  0.00%|                if homecls not in metamro:
   460|         0|            0|            0|  0.00%|                    homecls = base
   461|         0|            0|            0|  0.00%|                break
   462|         0|            0|            0|  0.00%|        if homecls is None:
   463|         0|            0|            0|  0.00%|            # unable to locate the attribute anywhere, most likely due to
   464|         0|            0|            0|  0.00%|            # buggy custom __dir__; discard and move on
   465|         0|            0|            0|  0.00%|            continue
   466|         0|            0|            0|  0.00%|        obj = get_obj if get_obj is not None else dict_obj
   467|         0|            0|            0|  0.00%|        # Classify the object or its descriptor.
   468|         0|            0|            0|  0.00%|        if isinstance(dict_obj, (staticmethod, types.BuiltinMethodType)):
   469|         0|            0|            0|  0.00%|            kind = "static method"
   470|         0|            0|            0|  0.00%|            obj = dict_obj
   471|         0|            0|            0|  0.00%|        elif isinstance(dict_obj, (classmethod, types.ClassMethodDescriptorType)):
   472|         0|            0|            0|  0.00%|            kind = "class method"
   473|         0|            0|            0|  0.00%|            obj = dict_obj
   474|         0|            0|            0|  0.00%|        elif isinstance(dict_obj, property):
   475|         0|            0|            0|  0.00%|            kind = "property"
   476|         0|            0|            0|  0.00%|            obj = dict_obj
   477|         0|            0|            0|  0.00%|        elif isroutine(obj):
   478|         0|            0|            0|  0.00%|            kind = "method"
   479|         0|            0|            0|  0.00%|        else:
   480|         0|            0|            0|  0.00%|            kind = "data"
   481|         0|            0|            0|  0.00%|        result.append(Attribute(name, kind, homecls, obj))
   482|         0|            0|            0|  0.00%|        processed.add(name)
   483|         0|            0|            0|  0.00%|    return result
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|# ----------------------------------------------------------- class helpers
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|def getmro(cls):
   488|         0|            0|            0|  0.00%|    "Return tuple of base classes (including cls) in method resolution order."
   489|         0|            0|            0|  0.00%|    return cls.__mro__
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|# -------------------------------------------------------- function helpers
   492|         0|            0|            0|  0.00%|
   493|         1|  2.52724e-05|  2.52724e-05|  0.00%|def unwrap(func, *, stop=None):
   494|         0|            0|            0|  0.00%|    """Get the object wrapped by *func*.
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|   Follows the chain of :attr:`__wrapped__` attributes returning the last
   497|         0|            0|            0|  0.00%|   object in the chain.
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|   *stop* is an optional callback accepting an object in the wrapper chain
   500|         0|            0|            0|  0.00%|   as its sole argument that allows the unwrapping to be terminated early if
   501|         0|            0|            0|  0.00%|   the callback returns a true value. If the callback never returns a true
   502|         0|            0|            0|  0.00%|   value, the last object in the chain is returned as usual. For example,
   503|         0|            0|            0|  0.00%|   :func:`signature` uses this to stop unwrapping if any object in the
   504|         0|            0|            0|  0.00%|   chain has a ``__signature__`` attribute defined.
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|   :exc:`ValueError` is raised if a cycle is encountered.
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    """
   509|         1|  8.34465e-06|  8.34465e-06|  0.00%|    if stop is None:
   510|         2|  1.28746e-05|   6.4373e-06|  0.00%|        def _is_wrapper(f):
   511|         1|  1.43051e-05|  1.43051e-05|  0.00%|            return hasattr(f, '__wrapped__')
   512|         0|            0|            0|  0.00%|    else:
   513|         0|            0|            0|  0.00%|        def _is_wrapper(f):
   514|         0|            0|            0|  0.00%|            return hasattr(f, '__wrapped__') and not stop(f)
   515|         1|  1.38283e-05|  1.38283e-05|  0.00%|    f = func  # remember the original func for error reporting
   516|         0|            0|            0|  0.00%|    # Memoise by id to tolerate non-hashable objects, but store objects to
   517|         0|            0|            0|  0.00%|    # ensure they aren't destroyed, which would allow their IDs to be reused.
   518|         1|   1.7643e-05|   1.7643e-05|  0.00%|    memo = {id(f): f}
   519|         1|  1.28746e-05|  1.28746e-05|  0.00%|    recursion_limit = sys.getrecursionlimit()
   520|         1|  2.12193e-05|  2.12193e-05|  0.00%|    while _is_wrapper(func):
(call)|         1|  2.00272e-05|  2.00272e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:510 _is_wrapper
   521|         0|            0|            0|  0.00%|        func = func.__wrapped__
   522|         0|            0|            0|  0.00%|        id_func = id(func)
   523|         0|            0|            0|  0.00%|        if (id_func in memo) or (len(memo) >= recursion_limit):
   524|         0|            0|            0|  0.00%|            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))
   525|         0|            0|            0|  0.00%|        memo[id_func] = func
   526|         1|  6.91414e-06|  6.91414e-06|  0.00%|    return func
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|# -------------------------------------------------- source code extraction
   529|         0|            0|            0|  0.00%|def indentsize(line):
   530|         0|            0|            0|  0.00%|    """Return the indent size, in spaces, at the start of a line of text."""
   531|         0|            0|            0|  0.00%|    expline = line.expandtabs()
   532|         0|            0|            0|  0.00%|    return len(expline) - len(expline.lstrip())
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|def _findclass(func):
   535|         0|            0|            0|  0.00%|    cls = sys.modules.get(func.__module__)
   536|         0|            0|            0|  0.00%|    if cls is None:
   537|         0|            0|            0|  0.00%|        return None
   538|         0|            0|            0|  0.00%|    for name in func.__qualname__.split('.')[:-1]:
   539|         0|            0|            0|  0.00%|        cls = getattr(cls, name)
   540|         0|            0|            0|  0.00%|    if not isclass(cls):
   541|         0|            0|            0|  0.00%|        return None
   542|         0|            0|            0|  0.00%|    return cls
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|def _finddoc(obj):
   545|         0|            0|            0|  0.00%|    if isclass(obj):
   546|         0|            0|            0|  0.00%|        for base in obj.__mro__:
   547|         0|            0|            0|  0.00%|            if base is not object:
   548|         0|            0|            0|  0.00%|                try:
   549|         0|            0|            0|  0.00%|                    doc = base.__doc__
   550|         0|            0|            0|  0.00%|                except AttributeError:
   551|         0|            0|            0|  0.00%|                    continue
   552|         0|            0|            0|  0.00%|                if doc is not None:
   553|         0|            0|            0|  0.00%|                    return doc
   554|         0|            0|            0|  0.00%|        return None
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    if ismethod(obj):
   557|         0|            0|            0|  0.00%|        name = obj.__func__.__name__
   558|         0|            0|            0|  0.00%|        self = obj.__self__
   559|         0|            0|            0|  0.00%|        if (isclass(self) and
   560|         0|            0|            0|  0.00%|            getattr(getattr(self, name, None), '__func__') is obj.__func__):
   561|         0|            0|            0|  0.00%|            # classmethod
   562|         0|            0|            0|  0.00%|            cls = self
   563|         0|            0|            0|  0.00%|        else:
   564|         0|            0|            0|  0.00%|            cls = self.__class__
   565|         0|            0|            0|  0.00%|    elif isfunction(obj):
   566|         0|            0|            0|  0.00%|        name = obj.__name__
   567|         0|            0|            0|  0.00%|        cls = _findclass(obj)
   568|         0|            0|            0|  0.00%|        if cls is None or getattr(cls, name) is not obj:
   569|         0|            0|            0|  0.00%|            return None
   570|         0|            0|            0|  0.00%|    elif isbuiltin(obj):
   571|         0|            0|            0|  0.00%|        name = obj.__name__
   572|         0|            0|            0|  0.00%|        self = obj.__self__
   573|         0|            0|            0|  0.00%|        if (isclass(self) and
   574|         0|            0|            0|  0.00%|            self.__qualname__ + '.' + name == obj.__qualname__):
   575|         0|            0|            0|  0.00%|            # classmethod
   576|         0|            0|            0|  0.00%|            cls = self
   577|         0|            0|            0|  0.00%|        else:
   578|         0|            0|            0|  0.00%|            cls = self.__class__
   579|         0|            0|            0|  0.00%|    # Should be tested before isdatadescriptor().
   580|         0|            0|            0|  0.00%|    elif isinstance(obj, property):
   581|         0|            0|            0|  0.00%|        func = obj.fget
   582|         0|            0|            0|  0.00%|        name = func.__name__
   583|         0|            0|            0|  0.00%|        cls = _findclass(func)
   584|         0|            0|            0|  0.00%|        if cls is None or getattr(cls, name) is not obj:
   585|         0|            0|            0|  0.00%|            return None
   586|         0|            0|            0|  0.00%|    elif ismethoddescriptor(obj) or isdatadescriptor(obj):
   587|         0|            0|            0|  0.00%|        name = obj.__name__
   588|         0|            0|            0|  0.00%|        cls = obj.__objclass__
   589|         0|            0|            0|  0.00%|        if getattr(cls, name) is not obj:
   590|         0|            0|            0|  0.00%|            return None
   591|         0|            0|            0|  0.00%|        if ismemberdescriptor(obj):
   592|         0|            0|            0|  0.00%|            slots = getattr(cls, '__slots__', None)
   593|         0|            0|            0|  0.00%|            if isinstance(slots, dict) and name in slots:
   594|         0|            0|            0|  0.00%|                return slots[name]
   595|         0|            0|            0|  0.00%|    else:
   596|         0|            0|            0|  0.00%|        return None
   597|         0|            0|            0|  0.00%|    for base in cls.__mro__:
   598|         0|            0|            0|  0.00%|        try:
   599|         0|            0|            0|  0.00%|            doc = getattr(base, name).__doc__
   600|         0|            0|            0|  0.00%|        except AttributeError:
   601|         0|            0|            0|  0.00%|            continue
   602|         0|            0|            0|  0.00%|        if doc is not None:
   603|         0|            0|            0|  0.00%|            return doc
   604|         0|            0|            0|  0.00%|    return None
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|def getdoc(object):
   607|         0|            0|            0|  0.00%|    """Get the documentation string for an object.
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    All tabs are expanded to spaces.  To clean up docstrings that are
   610|         0|            0|            0|  0.00%|    indented to line up with blocks of code, any whitespace than can be
   611|         0|            0|            0|  0.00%|    uniformly removed from the second line onwards is removed."""
   612|         0|            0|            0|  0.00%|    try:
   613|         0|            0|            0|  0.00%|        doc = object.__doc__
   614|         0|            0|            0|  0.00%|    except AttributeError:
   615|         0|            0|            0|  0.00%|        return None
   616|         0|            0|            0|  0.00%|    if doc is None:
   617|         0|            0|            0|  0.00%|        try:
   618|         0|            0|            0|  0.00%|            doc = _finddoc(object)
   619|         0|            0|            0|  0.00%|        except (AttributeError, TypeError):
   620|         0|            0|            0|  0.00%|            return None
   621|         0|            0|            0|  0.00%|    if not isinstance(doc, str):
   622|         0|            0|            0|  0.00%|        return None
   623|         0|            0|            0|  0.00%|    return cleandoc(doc)
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|def cleandoc(doc):
   626|         0|            0|            0|  0.00%|    """Clean up indentation from docstrings.
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    Any whitespace that can be uniformly removed from the second line
   629|         0|            0|            0|  0.00%|    onwards is removed."""
   630|         0|            0|            0|  0.00%|    try:
   631|         0|            0|            0|  0.00%|        lines = doc.expandtabs().split('\n')
   632|         0|            0|            0|  0.00%|    except UnicodeError:
   633|         0|            0|            0|  0.00%|        return None
   634|         0|            0|            0|  0.00%|    else:
   635|         0|            0|            0|  0.00%|        # Find minimum indentation of any non-blank lines after first line.
   636|         0|            0|            0|  0.00%|        margin = sys.maxsize
   637|         0|            0|            0|  0.00%|        for line in lines[1:]:
   638|         0|            0|            0|  0.00%|            content = len(line.lstrip())
   639|         0|            0|            0|  0.00%|            if content:
   640|         0|            0|            0|  0.00%|                indent = len(line) - content
   641|         0|            0|            0|  0.00%|                margin = min(margin, indent)
   642|         0|            0|            0|  0.00%|        # Remove indentation.
   643|         0|            0|            0|  0.00%|        if lines:
   644|         0|            0|            0|  0.00%|            lines[0] = lines[0].lstrip()
   645|         0|            0|            0|  0.00%|        if margin < sys.maxsize:
   646|         0|            0|            0|  0.00%|            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
   647|         0|            0|            0|  0.00%|        # Remove any trailing or leading blank lines.
   648|         0|            0|            0|  0.00%|        while lines and not lines[-1]:
   649|         0|            0|            0|  0.00%|            lines.pop()
   650|         0|            0|            0|  0.00%|        while lines and not lines[0]:
   651|         0|            0|            0|  0.00%|            lines.pop(0)
   652|         0|            0|            0|  0.00%|        return '\n'.join(lines)
   653|         0|            0|            0|  0.00%|
   654|      1706|   0.00755095|  4.42612e-06|  0.01%|def getfile(object):
   655|         0|            0|            0|  0.00%|    """Work out which source or compiled file an object was defined in."""
   656|      1706|    0.0205698|  1.20573e-05|  0.01%|    if ismodule(object):
(call)|      1706|    0.0160851|  9.42857e-06|  0.01%|# /opt/conda/lib/python3.8/inspect.py:63 ismodule
   657|      1705|    0.0105779|  6.20406e-06|  0.01%|        if getattr(object, '__file__', None):
(call)|         2|  2.24113e-05|  1.12057e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/__init__.py:46 __getattr__
(call)|         1|  1.12057e-05|  1.12057e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/quantized/__init__.py:44 __getattr__
   658|      1705|   0.00697207|  4.08919e-06|  0.01%|            return object.__file__
(call)|         2|  1.81198e-05|  9.05991e-06|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/__init__.py:46 __getattr__
(call)|         1|  9.29832e-06|  9.29832e-06|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/quantized/__init__.py:44 __getattr__
   659|         0|            0|            0|  0.00%|        raise TypeError('{!r} is a built-in module'.format(object))
   660|         1|  1.85966e-05|  1.85966e-05|  0.00%|    if isclass(object):
(call)|         1|  1.26362e-05|  1.26362e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:72 isclass
   661|         0|            0|            0|  0.00%|        if hasattr(object, '__module__'):
   662|         0|            0|            0|  0.00%|            module = sys.modules.get(object.__module__)
   663|         0|            0|            0|  0.00%|            if getattr(module, '__file__', None):
   664|         0|            0|            0|  0.00%|                return module.__file__
   665|         0|            0|            0|  0.00%|        raise TypeError('{!r} is a built-in class'.format(object))
   666|         1|  2.71797e-05|  2.71797e-05|  0.00%|    if ismethod(object):
(call)|         1|   1.5974e-05|   1.5974e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:80 ismethod
   667|         0|            0|            0|  0.00%|        object = object.__func__
   668|         1|  2.81334e-05|  2.81334e-05|  0.00%|    if isfunction(object):
(call)|         1|  2.19345e-05|  2.19345e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:158 isfunction
   669|         0|            0|            0|  0.00%|        object = object.__code__
   670|         1|  1.83582e-05|  1.83582e-05|  0.00%|    if istraceback(object):
(call)|         1|   1.5974e-05|   1.5974e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:236 istraceback
   671|         0|            0|            0|  0.00%|        object = object.tb_frame
   672|         1|   2.6226e-05|   2.6226e-05|  0.00%|    if isframe(object):
(call)|         1|  2.64645e-05|  2.64645e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:246 isframe
   673|         0|            0|            0|  0.00%|        object = object.f_code
   674|         1|  1.81198e-05|  1.81198e-05|  0.00%|    if iscode(object):
(call)|         1|  2.19345e-05|  2.19345e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:260 iscode
   675|         1|  6.67572e-06|  6.67572e-06|  0.00%|        return object.co_filename
   676|         0|            0|            0|  0.00%|    raise TypeError('module, class, method, function, traceback, frame, or '
   677|         0|            0|            0|  0.00%|                    'code object was expected, got {}'.format(
   678|         0|            0|            0|  0.00%|                    type(object).__name__))
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|def getmodulename(path):
   681|         0|            0|            0|  0.00%|    """Return the module name for a given file, or None."""
   682|         0|            0|            0|  0.00%|    fname = os.path.basename(path)
   683|         0|            0|            0|  0.00%|    # Check for paths that look like an actual module file
   684|         0|            0|            0|  0.00%|    suffixes = [(-len(suffix), suffix)
   685|         0|            0|            0|  0.00%|                    for suffix in importlib.machinery.all_suffixes()]
   686|         0|            0|            0|  0.00%|    suffixes.sort() # try longest suffixes first, in case they overlap
   687|         0|            0|            0|  0.00%|    for neglen, suffix in suffixes:
   688|         0|            0|            0|  0.00%|        if fname.endswith(suffix):
   689|         0|            0|            0|  0.00%|            return fname[:neglen]
   690|         0|            0|            0|  0.00%|    return None
   691|         0|            0|            0|  0.00%|
   692|      1601|   0.00802851|  5.01468e-06|  0.01%|def getsourcefile(object):
   693|         0|            0|            0|  0.00%|    """Return the filename that can be used to locate an object's source.
   694|         0|            0|            0|  0.00%|    Return None if no way can be identified to get the source.
   695|         0|            0|            0|  0.00%|    """
   696|      1601|    0.0209801|  1.31044e-05|  0.02%|    filename = getfile(object)
(call)|      1601|      0.11946|  7.46158e-05|  0.09%|# /opt/conda/lib/python3.8/site-packages/torch/package/package_importer.py:588 patched_getfile
   697|      1601|   0.00834274|  5.21096e-06|  0.01%|    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]
   698|      1601|   0.00795031|  4.96584e-06|  0.01%|    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]
   699|     11207|    0.0990195|  8.83551e-06|  0.07%|    if any(filename.endswith(s) for s in all_bytecode_suffixes):
(call)|      4803|    0.0480514|  1.00044e-05|  0.03%|# /opt/conda/lib/python3.8/inspect.py:699 <genexpr>
   700|         0|            0|            0|  0.00%|        filename = (os.path.splitext(filename)[0] +
   701|         0|            0|            0|  0.00%|                    importlib.machinery.SOURCE_SUFFIXES[0])
   702|     15485|     0.127688|   8.2459e-06|  0.09%|    elif any(filename.endswith(s) for s in
(call)|      6194|    0.0607154|   9.8023e-06|  0.04%|# /opt/conda/lib/python3.8/inspect.py:702 <genexpr>
   703|      1601|   0.00671339|  4.19325e-06|  0.00%|                 importlib.machinery.EXTENSION_SUFFIXES):
   704|       105|  0.000437975|  4.17119e-06|  0.00%|        return None
   705|      1496|     0.020674|  1.38195e-05|  0.02%|    if os.path.exists(filename):
(call)|      1496|    0.0524614|  3.50678e-05|  0.04%|# /opt/conda/lib/python3.8/genericpath.py:16 exists
   706|      1496|     0.006217|  4.15575e-06|  0.00%|        return filename
   707|         0|            0|            0|  0.00%|    # only return a non-existent filename if the module has a PEP 302 loader
   708|         0|            0|            0|  0.00%|    if getattr(getmodule(object, filename), '__loader__', None) is not None:
   709|         0|            0|            0|  0.00%|        return filename
   710|         0|            0|            0|  0.00%|    # or it is in the linecache
   711|         0|            0|            0|  0.00%|    if filename in linecache.cache:
   712|         0|            0|            0|  0.00%|        return filename
   713|         0|            0|            0|  0.00%|
   714|      1601|   0.00710726|  4.43926e-06|  0.01%|def getabsfile(object, _filename=None):
   715|         0|            0|            0|  0.00%|    """Return an absolute path to the source or compiled file for an object.
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|    The idea is for each object to have a unique origin, so this routine
   718|         0|            0|            0|  0.00%|    normalizes the result as much as possible."""
   719|      1601|   0.00634694|  3.96436e-06|  0.00%|    if _filename is None:
   720|      1600|    0.0218501|  1.36563e-05|  0.02%|        _filename = getsourcefile(object) or getfile(object)
(call)|      1600|     0.477166|  0.000298229|  0.35%|# /opt/conda/lib/python3.8/inspect.py:692 getsourcefile
(call)|       105|   0.00769567|  7.32921e-05|  0.01%|# /opt/conda/lib/python3.8/site-packages/torch/package/package_importer.py:588 patched_getfile
   721|      1601|    0.0333064|  2.08035e-05|  0.02%|    return os.path.normcase(os.path.abspath(_filename))
(call)|      1601|     0.529438|  0.000330692|  0.38%|# /opt/conda/lib/python3.8/posixpath.py:372 abspath
(call)|      1601|     0.015976|  9.97873e-06|  0.01%|# /opt/conda/lib/python3.8/posixpath.py:52 normcase
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|modulesbyfile = {}
   724|         0|            0|            0|  0.00%|_filesbymodname = {}
   725|         0|            0|            0|  0.00%|
   726|         1|  1.45435e-05|  1.45435e-05|  0.00%|def getmodule(object, _filename=None):
   727|         0|            0|            0|  0.00%|    """Return the module an object was defined in, or None if not found."""
   728|         1|  1.81198e-05|  1.81198e-05|  0.00%|    if ismodule(object):
(call)|         1|  1.19209e-05|  1.19209e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:63 ismodule
   729|         0|            0|            0|  0.00%|        return object
   730|         1|  1.00136e-05|  1.00136e-05|  0.00%|    if hasattr(object, '__module__'):
   731|         0|            0|            0|  0.00%|        return sys.modules.get(object.__module__)
   732|         0|            0|            0|  0.00%|    # Try the filename to modulename cache
   733|         1|  1.23978e-05|  1.23978e-05|  0.00%|    if _filename is not None and _filename in modulesbyfile:
   734|         0|            0|            0|  0.00%|        return sys.modules.get(modulesbyfile[_filename])
   735|         0|            0|            0|  0.00%|    # Try the cache again with the absolute file name
   736|         1|  1.35899e-05|  1.35899e-05|  0.00%|    try:
   737|         1|  2.07424e-05|  2.07424e-05|  0.00%|        file = getabsfile(object, _filename)
(call)|         1|  0.000781298|  0.000781298|  0.00%|# /opt/conda/lib/python3.8/inspect.py:714 getabsfile
   738|         0|            0|            0|  0.00%|    except TypeError:
   739|         0|            0|            0|  0.00%|        return None
   740|         1|  7.86781e-06|  7.86781e-06|  0.00%|    if file in modulesbyfile:
   741|         0|            0|            0|  0.00%|        return sys.modules.get(modulesbyfile[file])
   742|         0|            0|            0|  0.00%|    # Update the filename to module name cache and check yet again
   743|         0|            0|            0|  0.00%|    # Copy sys.modules in order to cope with changes while iterating
   744|      1656|    0.0127199|  7.68108e-06|  0.01%|    for modname, module in sys.modules.copy().items():
   745|      1655|    0.0387661|  2.34237e-05|  0.03%|        if ismodule(module) and hasattr(module, '__file__'):
(call)|      1655|    0.0171344|  1.03531e-05|  0.01%|# /opt/conda/lib/python3.8/inspect.py:63 ismodule
(call)|         1|  6.03199e-05|  6.03199e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/_VF.py:25 __getattr__
(call)|         2|  5.17368e-05|  2.58684e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/__init__.py:46 __getattr__
(call)|         1|  3.00407e-05|  3.00407e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/quantized/__init__.py:44 __getattr__
   746|      1601|   0.00850272|  5.31088e-06|  0.01%|            f = module.__file__
(call)|         2|  1.93119e-05|  9.65595e-06|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/__init__.py:46 __getattr__
(call)|         1|  1.00136e-05|  1.00136e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/torch/backends/quantized/__init__.py:44 __getattr__
   747|      1601|    0.0114808|  7.17102e-06|  0.01%|            if f == _filesbymodname.get(modname, None):
   748|         0|            0|            0|  0.00%|                # Have already mapped this module, so skip it
   749|         1|  4.29153e-06|  4.29153e-06|  0.00%|                continue
   750|      1600|   0.00794244|  4.96402e-06|  0.01%|            _filesbymodname[modname] = f
   751|      1600|    0.0216684|  1.35428e-05|  0.02%|            f = getabsfile(module)
(call)|      1600|      1.09811|  0.000686316|  0.80%|# /opt/conda/lib/python3.8/inspect.py:714 getabsfile
   752|         0|            0|            0|  0.00%|            # Always map to the name the module knows itself by
   753|      3200|    0.0173399|  5.41873e-06|  0.01%|            modulesbyfile[f] = modulesbyfile[
   754|      3200|     0.029829|  9.32157e-06|  0.02%|                os.path.realpath(f)] = module.__name__
(call)|      1600|      2.75175|   0.00171984|  2.00%|# /opt/conda/lib/python3.8/posixpath.py:387 realpath
   755|         1|  7.15256e-06|  7.15256e-06|  0.00%|    if file in modulesbyfile:
   756|         0|            0|            0|  0.00%|        return sys.modules.get(modulesbyfile[file])
   757|         0|            0|            0|  0.00%|    # Check the main module
   758|         1|  1.14441e-05|  1.14441e-05|  0.00%|    main = sys.modules['__main__']
   759|         1|   1.0252e-05|   1.0252e-05|  0.00%|    if not hasattr(object, '__name__'):
   760|         1|  6.67572e-06|  6.67572e-06|  0.00%|        return None
   761|         0|            0|            0|  0.00%|    if hasattr(main, object.__name__):
   762|         0|            0|            0|  0.00%|        mainobject = getattr(main, object.__name__)
   763|         0|            0|            0|  0.00%|        if mainobject is object:
   764|         0|            0|            0|  0.00%|            return main
   765|         0|            0|            0|  0.00%|    # Check builtins
   766|         0|            0|            0|  0.00%|    builtin = sys.modules['builtins']
   767|         0|            0|            0|  0.00%|    if hasattr(builtin, object.__name__):
   768|         0|            0|            0|  0.00%|        builtinobject = getattr(builtin, object.__name__)
   769|         0|            0|            0|  0.00%|        if builtinobject is object:
   770|         0|            0|            0|  0.00%|            return builtin
   771|         0|            0|            0|  0.00%|
   772|         1|  2.02656e-05|  2.02656e-05|  0.00%|def findsource(object):
   773|         0|            0|            0|  0.00%|    """Return the entire source file and starting line number for an object.
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|    The argument may be a module, class, method, function, traceback, frame,
   776|         0|            0|            0|  0.00%|    or code object.  The source code is returned as a list of all the lines
   777|         0|            0|            0|  0.00%|    in the file and the line number indexes a line in that list.  An OSError
   778|         0|            0|            0|  0.00%|    is raised if the source code cannot be retrieved."""
   779|         0|            0|            0|  0.00%|
   780|         1|  2.38419e-05|  2.38419e-05|  0.00%|    file = getsourcefile(object)
(call)|         1|  0.000806332|  0.000806332|  0.00%|# /opt/conda/lib/python3.8/inspect.py:692 getsourcefile
   781|         1|  1.54972e-05|  1.54972e-05|  0.00%|    if file:
   782|         0|            0|            0|  0.00%|        # Invalidate cache if needed.
   783|         1|  4.93526e-05|  4.93526e-05|  0.00%|        linecache.checkcache(file)
(call)|         1|   0.00013113|   0.00013113|  0.00%|# /opt/conda/lib/python3.8/linecache.py:53 checkcache
   784|         0|            0|            0|  0.00%|    else:
   785|         0|            0|            0|  0.00%|        file = getfile(object)
   786|         0|            0|            0|  0.00%|        # Allow filenames in form of "<something>" to pass through.
   787|         0|            0|            0|  0.00%|        # `doctest` monkeypatches `linecache` module to enable
   788|         0|            0|            0|  0.00%|        # inspection, so let `linecache.getlines` to be called.
   789|         0|            0|            0|  0.00%|        if not (file.startswith('<') and file.endswith('>')):
   790|         0|            0|            0|  0.00%|            raise OSError('source code not available')
   791|         0|            0|            0|  0.00%|
   792|         1|  4.79221e-05|  4.79221e-05|  0.00%|    module = getmodule(object, file)
(call)|         1|      4.01634|      4.01634|  2.91%|# /opt/conda/lib/python3.8/inspect.py:726 getmodule
   793|         1|  8.58307e-06|  8.58307e-06|  0.00%|    if module:
   794|         0|            0|            0|  0.00%|        lines = linecache.getlines(file, module.__dict__)
   795|         0|            0|            0|  0.00%|    else:
   796|         1|  3.57628e-05|  3.57628e-05|  0.00%|        lines = linecache.getlines(file)
(call)|         1|  4.45843e-05|  4.45843e-05|  0.00%|# /opt/conda/lib/python3.8/linecache.py:37 getlines
   797|         1|  7.62939e-06|  7.62939e-06|  0.00%|    if not lines:
   798|         0|            0|            0|  0.00%|        raise OSError('could not get source code')
   799|         0|            0|            0|  0.00%|
   800|         1|   2.5034e-05|   2.5034e-05|  0.00%|    if ismodule(object):
(call)|         1|  1.43051e-05|  1.43051e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:63 ismodule
   801|         0|            0|            0|  0.00%|        return lines, 0
   802|         0|            0|            0|  0.00%|
   803|         1|   2.5034e-05|   2.5034e-05|  0.00%|    if isclass(object):
(call)|         1|  1.26362e-05|  1.26362e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:72 isclass
   804|         0|            0|            0|  0.00%|        name = object.__name__
   805|         0|            0|            0|  0.00%|        pat = re.compile(r'^(\s*)class\s*' + name + r'\b')
   806|         0|            0|            0|  0.00%|        # make some effort to find the best matching class definition:
   807|         0|            0|            0|  0.00%|        # use the one with the least indentation, which is the one
   808|         0|            0|            0|  0.00%|        # that's most probably not inside a function definition.
   809|         0|            0|            0|  0.00%|        candidates = []
   810|         0|            0|            0|  0.00%|        for i in range(len(lines)):
   811|         0|            0|            0|  0.00%|            match = pat.match(lines[i])
   812|         0|            0|            0|  0.00%|            if match:
   813|         0|            0|            0|  0.00%|                # if it's at toplevel, it's already the best one
   814|         0|            0|            0|  0.00%|                if lines[i][0] == 'c':
   815|         0|            0|            0|  0.00%|                    return lines, i
   816|         0|            0|            0|  0.00%|                # else add whitespace to candidate list
   817|         0|            0|            0|  0.00%|                candidates.append((match.group(1), i))
   818|         0|            0|            0|  0.00%|        if candidates:
   819|         0|            0|            0|  0.00%|            # this will sort by whitespace, and by line number,
   820|         0|            0|            0|  0.00%|            # less whitespace first
   821|         0|            0|            0|  0.00%|            candidates.sort()
   822|         0|            0|            0|  0.00%|            return lines, candidates[0][1]
   823|         0|            0|            0|  0.00%|        else:
   824|         0|            0|            0|  0.00%|            raise OSError('could not find class definition')
   825|         0|            0|            0|  0.00%|
   826|         1|  1.85966e-05|  1.85966e-05|  0.00%|    if ismethod(object):
(call)|         1|   1.3113e-05|   1.3113e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:80 ismethod
   827|         0|            0|            0|  0.00%|        object = object.__func__
   828|         1|  1.85966e-05|  1.85966e-05|  0.00%|    if isfunction(object):
(call)|         1|  1.26362e-05|  1.26362e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:158 isfunction
   829|         0|            0|            0|  0.00%|        object = object.__code__
   830|         1|  1.90735e-05|  1.90735e-05|  0.00%|    if istraceback(object):
(call)|         1|  2.14577e-05|  2.14577e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:236 istraceback
   831|         0|            0|            0|  0.00%|        object = object.tb_frame
   832|         1|  1.90735e-05|  1.90735e-05|  0.00%|    if isframe(object):
(call)|         1|  1.33514e-05|  1.33514e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:246 isframe
   833|         0|            0|            0|  0.00%|        object = object.f_code
   834|         1|  1.81198e-05|  1.81198e-05|  0.00%|    if iscode(object):
(call)|         1|  1.23978e-05|  1.23978e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:260 iscode
   835|         1|   1.0252e-05|   1.0252e-05|  0.00%|        if not hasattr(object, 'co_firstlineno'):
   836|         0|            0|            0|  0.00%|            raise OSError('could not find function definition')
   837|         1|  1.16825e-05|  1.16825e-05|  0.00%|        lnum = object.co_firstlineno - 1
   838|         1|  3.55244e-05|  3.55244e-05|  0.00%|        pat = re.compile(r'^(\s*def\s)|(\s*async\s+def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
(call)|         1|    0.0306585|    0.0306585|  0.02%|# /opt/conda/lib/python3.8/re.py:250 compile
   839|         1|  8.10623e-06|  8.10623e-06|  0.00%|        while lnum > 0:
   840|         1|  1.54972e-05|  1.54972e-05|  0.00%|            try:
   841|         1|  1.33514e-05|  1.33514e-05|  0.00%|                line = lines[lnum]
   842|         0|            0|            0|  0.00%|            except IndexError:
   843|         0|            0|            0|  0.00%|                raise OSError('lineno is out of bounds')
   844|         1|  1.93119e-05|  1.93119e-05|  0.00%|            if pat.match(line):
   845|         1|  8.10623e-06|  8.10623e-06|  0.00%|                break
   846|         0|            0|            0|  0.00%|            lnum = lnum - 1
   847|         1|  1.45435e-05|  1.45435e-05|  0.00%|        return lines, lnum
   848|         0|            0|            0|  0.00%|    raise OSError('could not find code object')
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|def getcomments(object):
   851|         0|            0|            0|  0.00%|    """Get lines of comments immediately preceding an object's source code.
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|    Returns None when source can't be found.
   854|         0|            0|            0|  0.00%|    """
   855|         0|            0|            0|  0.00%|    try:
   856|         0|            0|            0|  0.00%|        lines, lnum = findsource(object)
   857|         0|            0|            0|  0.00%|    except (OSError, TypeError):
   858|         0|            0|            0|  0.00%|        return None
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|    if ismodule(object):
   861|         0|            0|            0|  0.00%|        # Look for a comment block at the top of the file.
   862|         0|            0|            0|  0.00%|        start = 0
   863|         0|            0|            0|  0.00%|        if lines and lines[0][:2] == '#!': start = 1
   864|         0|            0|            0|  0.00%|        while start < len(lines) and lines[start].strip() in ('', '#'):
   865|         0|            0|            0|  0.00%|            start = start + 1
   866|         0|            0|            0|  0.00%|        if start < len(lines) and lines[start][:1] == '#':
   867|         0|            0|            0|  0.00%|            comments = []
   868|         0|            0|            0|  0.00%|            end = start
   869|         0|            0|            0|  0.00%|            while end < len(lines) and lines[end][:1] == '#':
   870|         0|            0|            0|  0.00%|                comments.append(lines[end].expandtabs())
   871|         0|            0|            0|  0.00%|                end = end + 1
   872|         0|            0|            0|  0.00%|            return ''.join(comments)
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|    # Look for a preceding block of comments at the same indentation.
   875|         0|            0|            0|  0.00%|    elif lnum > 0:
   876|         0|            0|            0|  0.00%|        indent = indentsize(lines[lnum])
   877|         0|            0|            0|  0.00%|        end = lnum - 1
   878|         0|            0|            0|  0.00%|        if end >= 0 and lines[end].lstrip()[:1] == '#' and \
   879|         0|            0|            0|  0.00%|            indentsize(lines[end]) == indent:
   880|         0|            0|            0|  0.00%|            comments = [lines[end].expandtabs().lstrip()]
   881|         0|            0|            0|  0.00%|            if end > 0:
   882|         0|            0|            0|  0.00%|                end = end - 1
   883|         0|            0|            0|  0.00%|                comment = lines[end].expandtabs().lstrip()
   884|         0|            0|            0|  0.00%|                while comment[:1] == '#' and indentsize(lines[end]) == indent:
   885|         0|            0|            0|  0.00%|                    comments[:0] = [comment]
   886|         0|            0|            0|  0.00%|                    end = end - 1
   887|         0|            0|            0|  0.00%|                    if end < 0: break
   888|         0|            0|            0|  0.00%|                    comment = lines[end].expandtabs().lstrip()
   889|         0|            0|            0|  0.00%|            while comments and comments[0].strip() == '#':
   890|         0|            0|            0|  0.00%|                comments[:1] = []
   891|         0|            0|            0|  0.00%|            while comments and comments[-1].strip() == '#':
   892|         0|            0|            0|  0.00%|                comments[-1:] = []
   893|         0|            0|            0|  0.00%|            return ''.join(comments)
   894|         0|            0|            0|  0.00%|
   895|         0|            0|            0|  0.00%|class EndOfBlock(Exception): pass
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|class BlockFinder:
   898|         0|            0|            0|  0.00%|    """Provide a tokeneater() method to detect the end of a code block."""
   899|         1|  6.67572e-06|  6.67572e-06|  0.00%|    def __init__(self):
   900|         1|  1.26362e-05|  1.26362e-05|  0.00%|        self.indent = 0
   901|         1|  6.67572e-06|  6.67572e-06|  0.00%|        self.islambda = False
   902|         1|  5.96046e-06|  5.96046e-06|  0.00%|        self.started = False
   903|         1|  1.07288e-05|  1.07288e-05|  0.00%|        self.passline = False
   904|         1|  5.96046e-06|  5.96046e-06|  0.00%|        self.indecorator = False
   905|         1|  1.07288e-05|  1.07288e-05|  0.00%|        self.decoratorhasargs = False
   906|         1|  6.19888e-06|  6.19888e-06|  0.00%|        self.last = 1
   907|         1|  1.81198e-05|  1.81198e-05|  0.00%|        self.body_col0 = None
   908|         0|            0|            0|  0.00%|
   909|       476|   0.00220847|  4.63965e-06|  0.00%|    def tokeneater(self, type, token, srowcol, erowcol, line):
   910|       476|   0.00198317|  4.16631e-06|  0.00%|        if not self.started and not self.indecorator:
   911|         0|            0|            0|  0.00%|            # skip any decorators
   912|         3|  1.40667e-05|   4.6889e-06|  0.00%|            if token == "@":
   913|         1|   6.4373e-06|   6.4373e-06|  0.00%|                self.indecorator = True
   914|         0|            0|            0|  0.00%|            # look for the first "def", "class" or "lambda"
   915|         2|  8.10623e-06|  4.05312e-06|  0.00%|            elif token in ("def", "class", "lambda"):
   916|         1|  4.05312e-06|  4.05312e-06|  0.00%|                if token == "lambda":
   917|         0|            0|            0|  0.00%|                    self.islambda = True
   918|         1|  6.91414e-06|  6.91414e-06|  0.00%|                self.started = True
   919|         3|  1.85966e-05|  6.19888e-06|  0.00%|            self.passline = True    # skip to the end of the line
   920|       473|   0.00189066|  3.99717e-06|  0.00%|        elif token == "(":
   921|        36|  0.000146151|  4.05974e-06|  0.00%|            if self.indecorator:
   922|         1|  6.67572e-06|  6.67572e-06|  0.00%|                self.decoratorhasargs = True
   923|       437|   0.00167131|  3.82452e-06|  0.00%|        elif token == ")":
   924|        36|  0.000146151|  4.05974e-06|  0.00%|            if self.indecorator:
   925|         1|   6.4373e-06|   6.4373e-06|  0.00%|                self.indecorator = False
   926|         1|  6.19888e-06|  6.19888e-06|  0.00%|                self.decoratorhasargs = False
   927|       401|   0.00161982|  4.03944e-06|  0.00%|        elif type == tokenize.NEWLINE:
   928|        41|    0.0001688|  4.11708e-06|  0.00%|            self.passline = False   # stop skipping when a NEWLINE is seen
   929|        41|  0.000173807|   4.2392e-06|  0.00%|            self.last = srowcol[0]
   930|        41|  0.000158548|  3.86703e-06|  0.00%|            if self.islambda:       # lambdas always end at the first NEWLINE
   931|         0|            0|            0|  0.00%|                raise EndOfBlock
   932|         0|            0|            0|  0.00%|            # hitting a NEWLINE when in a decorator without args
   933|         0|            0|            0|  0.00%|            # ends the decorator
   934|        41|  0.000168562|  4.11127e-06|  0.00%|            if self.indecorator and not self.decoratorhasargs:
   935|         0|            0|            0|  0.00%|                self.indecorator = False
   936|       360|   0.00139689|  3.88026e-06|  0.00%|        elif self.passline:
   937|        63|  0.000246048|  3.90552e-06|  0.00%|            pass
   938|       297|   0.00116181|  3.91183e-06|  0.00%|        elif type == tokenize.INDENT:
   939|        10|  4.24385e-05|  4.24385e-06|  0.00%|            if self.body_col0 is None and self.started:
   940|         1|  5.96046e-06|  5.96046e-06|  0.00%|                self.body_col0 = erowcol[1]
   941|        10|  4.24385e-05|  4.24385e-06|  0.00%|            self.indent = self.indent + 1
   942|        10|  4.24385e-05|  4.24385e-06|  0.00%|            self.passline = True
   943|       287|   0.00117874|  4.10711e-06|  0.00%|        elif type == tokenize.DEDENT:
   944|        10|  4.19617e-05|  4.19617e-06|  0.00%|            self.indent = self.indent - 1
   945|         0|            0|            0|  0.00%|            # the end of matching indent/dedent pairs end a block
   946|         0|            0|            0|  0.00%|            # (note that this only works for "def"/"class" blocks,
   947|         0|            0|            0|  0.00%|            #  not e.g. for "if: else:" or "try: finally:" blocks)
   948|        10|  4.29153e-05|  4.29153e-06|  0.00%|            if self.indent <= 0:
   949|         1|  6.67572e-06|  6.67572e-06|  0.00%|                raise EndOfBlock
   950|       277|   0.00109172|  3.94122e-06|  0.00%|        elif type == tokenize.COMMENT:
   951|        35|  0.000149012|  4.25747e-06|  0.00%|            if self.body_col0 is not None and srowcol[1] >= self.body_col0:
   952|         0|            0|            0|  0.00%|                # Include comments if indented at least as much as the block
   953|        10|  4.50611e-05|  4.50611e-06|  0.00%|                self.last = srowcol[0]
   954|       242|   0.00096941|  4.00583e-06|  0.00%|        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
   955|         0|            0|            0|  0.00%|            # any other token on the same indentation level end the previous
   956|         0|            0|            0|  0.00%|            # block as well, except the pseudo-tokens COMMENT and NL.
   957|         0|            0|            0|  0.00%|            raise EndOfBlock
   958|         0|            0|            0|  0.00%|
   959|         1|  8.34465e-06|  8.34465e-06|  0.00%|def getblock(lines):
   960|         0|            0|            0|  0.00%|    """Extract the block of code at the top of the given list of lines."""
   961|         1|  2.88486e-05|  2.88486e-05|  0.00%|    blockfinder = BlockFinder()
(call)|         1|  8.36849e-05|  8.36849e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:899 __init__
   962|         1|   6.4373e-06|   6.4373e-06|  0.00%|    try:
   963|         1|  3.31402e-05|  3.31402e-05|  0.00%|        tokens = tokenize.generate_tokens(iter(lines).__next__)
(call)|         1|  2.64645e-05|  2.64645e-05|  0.00%|# /opt/conda/lib/python3.8/tokenize.py:612 generate_tokens
   964|       476|   0.00731421|   1.5366e-05|  0.01%|        for _token in tokens:
(call)|       476|     0.484836|   0.00101856|  0.35%|# /opt/conda/lib/python3.8/tokenize.py:429 _tokenize
   965|       476|   0.00646353|  1.35788e-05|  0.00%|            blockfinder.tokeneater(*_token)
(call)|       476|    0.0168765|  3.54547e-05|  0.01%|# /opt/conda/lib/python3.8/inspect.py:909 tokeneater
   966|         1|  5.48363e-06|  5.48363e-06|  0.00%|    except (EndOfBlock, IndentationError):
   967|         1|  7.15256e-06|  7.15256e-06|  0.00%|        pass
   968|         1|  6.91414e-06|  6.91414e-06|  0.00%|    return lines[:blockfinder.last]
   969|         0|            0|            0|  0.00%|
   970|         1|  1.64509e-05|  1.64509e-05|  0.00%|def getsourcelines(object):
   971|         0|            0|            0|  0.00%|    """Return a list of source lines and starting line number for an object.
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|    The argument may be a module, class, method, function, traceback, frame,
   974|         0|            0|            0|  0.00%|    or code object.  The source code is returned as a list of the lines
   975|         0|            0|            0|  0.00%|    corresponding to the object and the line number indicates where in the
   976|         0|            0|            0|  0.00%|    original source file the first line of code was found.  An OSError is
   977|         0|            0|            0|  0.00%|    raised if the source code cannot be retrieved."""
   978|         1|  4.79221e-05|  4.79221e-05|  0.00%|    object = unwrap(object)
(call)|         1|  0.000133276|  0.000133276|  0.00%|# /opt/conda/lib/python3.8/inspect.py:493 unwrap
   979|         1|  3.17097e-05|  3.17097e-05|  0.00%|    lines, lnum = findsource(object)
(call)|         1|      4.04857|      4.04857|  2.94%|# /opt/conda/lib/python3.8/inspect.py:772 findsource
   980|         0|            0|            0|  0.00%|
   981|         1|   1.5974e-05|   1.5974e-05|  0.00%|    if istraceback(object):
(call)|         1|  1.23978e-05|  1.23978e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:236 istraceback
   982|         0|            0|            0|  0.00%|        object = object.tb_frame
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|    # for module or frame that corresponds to module, return all source lines
   985|         2|  3.57628e-05|  1.78814e-05|  0.00%|    if (ismodule(object) or
(call)|         1|  1.26362e-05|  1.26362e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:63 ismodule
   986|         1|  1.71661e-05|  1.71661e-05|  0.00%|        (isframe(object) and object.f_code.co_name == "<module>")):
(call)|         1|    5.126e-05|    5.126e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:246 isframe
   987|         0|            0|            0|  0.00%|        return lines, 0
   988|         0|            0|            0|  0.00%|    else:
   989|         1|  7.72476e-05|  7.72476e-05|  0.00%|        return getblock(lines[lnum:]), lnum + 1
(call)|         1|     0.515697|     0.515697|  0.37%|# /opt/conda/lib/python3.8/inspect.py:959 getblock
(call)|         1|  1.14441e-05|  1.14441e-05|  0.00%|# /opt/conda/lib/python3.8/tokenize.py:429 _tokenize
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|def getsource(object):
   992|         0|            0|            0|  0.00%|    """Return the text of the source code for an object.
   993|         0|            0|            0|  0.00%|
   994|         0|            0|            0|  0.00%|    The argument may be a module, class, method, function, traceback, frame,
   995|         0|            0|            0|  0.00%|    or code object.  The source code is returned as a single string.  An
   996|         0|            0|            0|  0.00%|    OSError is raised if the source code cannot be retrieved."""
   997|         0|            0|            0|  0.00%|    lines, lnum = getsourcelines(object)
   998|         0|            0|            0|  0.00%|    return ''.join(lines)
   999|         0|            0|            0|  0.00%|
  1000|         0|            0|            0|  0.00%|# --------------------------------------------------- class tree extraction
  1001|         0|            0|            0|  0.00%|def walktree(classes, children, parent):
  1002|         0|            0|            0|  0.00%|    """Recursive helper function for getclasstree()."""
  1003|         0|            0|            0|  0.00%|    results = []
  1004|         0|            0|            0|  0.00%|    classes.sort(key=attrgetter('__module__', '__name__'))
  1005|         0|            0|            0|  0.00%|    for c in classes:
  1006|         0|            0|            0|  0.00%|        results.append((c, c.__bases__))
  1007|         0|            0|            0|  0.00%|        if c in children:
  1008|         0|            0|            0|  0.00%|            results.append(walktree(children[c], children, c))
  1009|         0|            0|            0|  0.00%|    return results
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|def getclasstree(classes, unique=False):
  1012|         0|            0|            0|  0.00%|    """Arrange the given list of classes into a hierarchy of nested lists.
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|    Where a nested list appears, it contains classes derived from the class
  1015|         0|            0|            0|  0.00%|    whose entry immediately precedes the list.  Each entry is a 2-tuple
  1016|         0|            0|            0|  0.00%|    containing a class and a tuple of its base classes.  If the 'unique'
  1017|         0|            0|            0|  0.00%|    argument is true, exactly one entry appears in the returned structure
  1018|         0|            0|            0|  0.00%|    for each class in the given list.  Otherwise, classes using multiple
  1019|         0|            0|            0|  0.00%|    inheritance and their descendants will appear multiple times."""
  1020|         0|            0|            0|  0.00%|    children = {}
  1021|         0|            0|            0|  0.00%|    roots = []
  1022|         0|            0|            0|  0.00%|    for c in classes:
  1023|         0|            0|            0|  0.00%|        if c.__bases__:
  1024|         0|            0|            0|  0.00%|            for parent in c.__bases__:
  1025|         0|            0|            0|  0.00%|                if parent not in children:
  1026|         0|            0|            0|  0.00%|                    children[parent] = []
  1027|         0|            0|            0|  0.00%|                if c not in children[parent]:
  1028|         0|            0|            0|  0.00%|                    children[parent].append(c)
  1029|         0|            0|            0|  0.00%|                if unique and parent in classes: break
  1030|         0|            0|            0|  0.00%|        elif c not in roots:
  1031|         0|            0|            0|  0.00%|            roots.append(c)
  1032|         0|            0|            0|  0.00%|    for parent in children:
  1033|         0|            0|            0|  0.00%|        if parent not in classes:
  1034|         0|            0|            0|  0.00%|            roots.append(parent)
  1035|         0|            0|            0|  0.00%|    return walktree(roots, children, None)
  1036|         0|            0|            0|  0.00%|
  1037|         0|            0|            0|  0.00%|# ------------------------------------------------ argument list extraction
  1038|         0|            0|            0|  0.00%|Arguments = namedtuple('Arguments', 'args, varargs, varkw')
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|def getargs(co):
  1041|         0|            0|            0|  0.00%|    """Get information about the arguments accepted by a code object.
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|    Three things are returned: (args, varargs, varkw), where
  1044|         0|            0|            0|  0.00%|    'args' is the list of argument names. Keyword-only arguments are
  1045|         0|            0|            0|  0.00%|    appended. 'varargs' and 'varkw' are the names of the * and **
  1046|         0|            0|            0|  0.00%|    arguments or None."""
  1047|         0|            0|            0|  0.00%|    if not iscode(co):
  1048|         0|            0|            0|  0.00%|        raise TypeError('{!r} is not a code object'.format(co))
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|    names = co.co_varnames
  1051|         0|            0|            0|  0.00%|    nargs = co.co_argcount
  1052|         0|            0|            0|  0.00%|    nkwargs = co.co_kwonlyargcount
  1053|         0|            0|            0|  0.00%|    args = list(names[:nargs])
  1054|         0|            0|            0|  0.00%|    kwonlyargs = list(names[nargs:nargs+nkwargs])
  1055|         0|            0|            0|  0.00%|    step = 0
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|    nargs += nkwargs
  1058|         0|            0|            0|  0.00%|    varargs = None
  1059|         0|            0|            0|  0.00%|    if co.co_flags & CO_VARARGS:
  1060|         0|            0|            0|  0.00%|        varargs = co.co_varnames[nargs]
  1061|         0|            0|            0|  0.00%|        nargs = nargs + 1
  1062|         0|            0|            0|  0.00%|    varkw = None
  1063|         0|            0|            0|  0.00%|    if co.co_flags & CO_VARKEYWORDS:
  1064|         0|            0|            0|  0.00%|        varkw = co.co_varnames[nargs]
  1065|         0|            0|            0|  0.00%|    return Arguments(args + kwonlyargs, varargs, varkw)
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|ArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')
  1068|         0|            0|            0|  0.00%|
  1069|         0|            0|            0|  0.00%|def getargspec(func):
  1070|         0|            0|            0|  0.00%|    """Get the names and default values of a function's parameters.
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|    A tuple of four things is returned: (args, varargs, keywords, defaults).
  1073|         0|            0|            0|  0.00%|    'args' is a list of the argument names, including keyword-only argument names.
  1074|         0|            0|            0|  0.00%|    'varargs' and 'keywords' are the names of the * and ** parameters or None.
  1075|         0|            0|            0|  0.00%|    'defaults' is an n-tuple of the default values of the last n parameters.
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|    This function is deprecated, as it does not support annotations or
  1078|         0|            0|            0|  0.00%|    keyword-only parameters and will raise ValueError if either is present
  1079|         0|            0|            0|  0.00%|    on the supplied callable.
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|    For a more structured introspection API, use inspect.signature() instead.
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|    Alternatively, use getfullargspec() for an API with a similar namedtuple
  1084|         0|            0|            0|  0.00%|    based interface, but full support for annotations and keyword-only
  1085|         0|            0|            0|  0.00%|    parameters.
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|    Deprecated since Python 3.5, use `inspect.getfullargspec()`.
  1088|         0|            0|            0|  0.00%|    """
  1089|         0|            0|            0|  0.00%|    warnings.warn("inspect.getargspec() is deprecated since Python 3.0, "
  1090|         0|            0|            0|  0.00%|                  "use inspect.signature() or inspect.getfullargspec()",
  1091|         0|            0|            0|  0.00%|                  DeprecationWarning, stacklevel=2)
  1092|         0|            0|            0|  0.00%|    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = \
  1093|         0|            0|            0|  0.00%|        getfullargspec(func)
  1094|         0|            0|            0|  0.00%|    if kwonlyargs or ann:
  1095|         0|            0|            0|  0.00%|        raise ValueError("Function has keyword-only parameters or annotations"
  1096|         0|            0|            0|  0.00%|                         ", use inspect.signature() API which can support them")
  1097|         0|            0|            0|  0.00%|    return ArgSpec(args, varargs, varkw, defaults)
  1098|         0|            0|            0|  0.00%|
  1099|         0|            0|            0|  0.00%|FullArgSpec = namedtuple('FullArgSpec',
  1100|         0|            0|            0|  0.00%|    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|def getfullargspec(func):
  1103|         0|            0|            0|  0.00%|    """Get the names and default values of a callable object's parameters.
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|    A tuple of seven things is returned:
  1106|         0|            0|            0|  0.00%|    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).
  1107|         0|            0|            0|  0.00%|    'args' is a list of the parameter names.
  1108|         0|            0|            0|  0.00%|    'varargs' and 'varkw' are the names of the * and ** parameters or None.
  1109|         0|            0|            0|  0.00%|    'defaults' is an n-tuple of the default values of the last n parameters.
  1110|         0|            0|            0|  0.00%|    'kwonlyargs' is a list of keyword-only parameter names.
  1111|         0|            0|            0|  0.00%|    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.
  1112|         0|            0|            0|  0.00%|    'annotations' is a dictionary mapping parameter names to annotations.
  1113|         0|            0|            0|  0.00%|
  1114|         0|            0|            0|  0.00%|    Notable differences from inspect.signature():
  1115|         0|            0|            0|  0.00%|      - the "self" parameter is always reported, even for bound methods
  1116|         0|            0|            0|  0.00%|      - wrapper chains defined by __wrapped__ *not* unwrapped automatically
  1117|         0|            0|            0|  0.00%|    """
  1118|         0|            0|            0|  0.00%|    try:
  1119|         0|            0|            0|  0.00%|        # Re: `skip_bound_arg=False`
  1120|         0|            0|            0|  0.00%|        #
  1121|         0|            0|            0|  0.00%|        # There is a notable difference in behaviour between getfullargspec
  1122|         0|            0|            0|  0.00%|        # and Signature: the former always returns 'self' parameter for bound
  1123|         0|            0|            0|  0.00%|        # methods, whereas the Signature always shows the actual calling
  1124|         0|            0|            0|  0.00%|        # signature of the passed object.
  1125|         0|            0|            0|  0.00%|        #
  1126|         0|            0|            0|  0.00%|        # To simulate this behaviour, we "unbind" bound methods, to trick
  1127|         0|            0|            0|  0.00%|        # inspect.signature to always return their first parameter ("self",
  1128|         0|            0|            0|  0.00%|        # usually)
  1129|         0|            0|            0|  0.00%|
  1130|         0|            0|            0|  0.00%|        # Re: `follow_wrapper_chains=False`
  1131|         0|            0|            0|  0.00%|        #
  1132|         0|            0|            0|  0.00%|        # getfullargspec() historically ignored __wrapped__ attributes,
  1133|         0|            0|            0|  0.00%|        # so we ensure that remains the case in 3.3+
  1134|         0|            0|            0|  0.00%|
  1135|         0|            0|            0|  0.00%|        sig = _signature_from_callable(func,
  1136|         0|            0|            0|  0.00%|                                       follow_wrapper_chains=False,
  1137|         0|            0|            0|  0.00%|                                       skip_bound_arg=False,
  1138|         0|            0|            0|  0.00%|                                       sigcls=Signature)
  1139|         0|            0|            0|  0.00%|    except Exception as ex:
  1140|         0|            0|            0|  0.00%|        # Most of the times 'signature' will raise ValueError.
  1141|         0|            0|            0|  0.00%|        # But, it can also raise AttributeError, and, maybe something
  1142|         0|            0|            0|  0.00%|        # else. So to be fully backwards compatible, we catch all
  1143|         0|            0|            0|  0.00%|        # possible exceptions here, and reraise a TypeError.
  1144|         0|            0|            0|  0.00%|        raise TypeError('unsupported callable') from ex
  1145|         0|            0|            0|  0.00%|
  1146|         0|            0|            0|  0.00%|    args = []
  1147|         0|            0|            0|  0.00%|    varargs = None
  1148|         0|            0|            0|  0.00%|    varkw = None
  1149|         0|            0|            0|  0.00%|    posonlyargs = []
  1150|         0|            0|            0|  0.00%|    kwonlyargs = []
  1151|         0|            0|            0|  0.00%|    defaults = ()
  1152|         0|            0|            0|  0.00%|    annotations = {}
  1153|         0|            0|            0|  0.00%|    defaults = ()
  1154|         0|            0|            0|  0.00%|    kwdefaults = {}
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|    if sig.return_annotation is not sig.empty:
  1157|         0|            0|            0|  0.00%|        annotations['return'] = sig.return_annotation
  1158|         0|            0|            0|  0.00%|
  1159|         0|            0|            0|  0.00%|    for param in sig.parameters.values():
  1160|         0|            0|            0|  0.00%|        kind = param.kind
  1161|         0|            0|            0|  0.00%|        name = param.name
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|        if kind is _POSITIONAL_ONLY:
  1164|         0|            0|            0|  0.00%|            posonlyargs.append(name)
  1165|         0|            0|            0|  0.00%|            if param.default is not param.empty:
  1166|         0|            0|            0|  0.00%|                defaults += (param.default,)
  1167|         0|            0|            0|  0.00%|        elif kind is _POSITIONAL_OR_KEYWORD:
  1168|         0|            0|            0|  0.00%|            args.append(name)
  1169|         0|            0|            0|  0.00%|            if param.default is not param.empty:
  1170|         0|            0|            0|  0.00%|                defaults += (param.default,)
  1171|         0|            0|            0|  0.00%|        elif kind is _VAR_POSITIONAL:
  1172|         0|            0|            0|  0.00%|            varargs = name
  1173|         0|            0|            0|  0.00%|        elif kind is _KEYWORD_ONLY:
  1174|         0|            0|            0|  0.00%|            kwonlyargs.append(name)
  1175|         0|            0|            0|  0.00%|            if param.default is not param.empty:
  1176|         0|            0|            0|  0.00%|                kwdefaults[name] = param.default
  1177|         0|            0|            0|  0.00%|        elif kind is _VAR_KEYWORD:
  1178|         0|            0|            0|  0.00%|            varkw = name
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|        if param.annotation is not param.empty:
  1181|         0|            0|            0|  0.00%|            annotations[name] = param.annotation
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|    if not kwdefaults:
  1184|         0|            0|            0|  0.00%|        # compatibility with 'func.__kwdefaults__'
  1185|         0|            0|            0|  0.00%|        kwdefaults = None
  1186|         0|            0|            0|  0.00%|
  1187|         0|            0|            0|  0.00%|    if not defaults:
  1188|         0|            0|            0|  0.00%|        # compatibility with 'func.__defaults__'
  1189|         0|            0|            0|  0.00%|        defaults = None
  1190|         0|            0|            0|  0.00%|
  1191|         0|            0|            0|  0.00%|    return FullArgSpec(posonlyargs + args, varargs, varkw, defaults,
  1192|         0|            0|            0|  0.00%|                       kwonlyargs, kwdefaults, annotations)
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|def getargvalues(frame):
  1198|         0|            0|            0|  0.00%|    """Get information about arguments passed into a particular frame.
  1199|         0|            0|            0|  0.00%|
  1200|         0|            0|            0|  0.00%|    A tuple of four things is returned: (args, varargs, varkw, locals).
  1201|         0|            0|            0|  0.00%|    'args' is a list of the argument names.
  1202|         0|            0|            0|  0.00%|    'varargs' and 'varkw' are the names of the * and ** arguments or None.
  1203|         0|            0|            0|  0.00%|    'locals' is the locals dictionary of the given frame."""
  1204|         0|            0|            0|  0.00%|    args, varargs, varkw = getargs(frame.f_code)
  1205|         0|            0|            0|  0.00%|    return ArgInfo(args, varargs, varkw, frame.f_locals)
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|def formatannotation(annotation, base_module=None):
  1208|         0|            0|            0|  0.00%|    if getattr(annotation, '__module__', None) == 'typing':
  1209|         0|            0|            0|  0.00%|        return repr(annotation).replace('typing.', '')
  1210|         0|            0|            0|  0.00%|    if isinstance(annotation, type):
  1211|         0|            0|            0|  0.00%|        if annotation.__module__ in ('builtins', base_module):
  1212|         0|            0|            0|  0.00%|            return annotation.__qualname__
  1213|         0|            0|            0|  0.00%|        return annotation.__module__+'.'+annotation.__qualname__
  1214|         0|            0|            0|  0.00%|    return repr(annotation)
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|def formatannotationrelativeto(object):
  1217|         0|            0|            0|  0.00%|    module = getattr(object, '__module__', None)
  1218|         0|            0|            0|  0.00%|    def _formatannotation(annotation):
  1219|         0|            0|            0|  0.00%|        return formatannotation(annotation, module)
  1220|         0|            0|            0|  0.00%|    return _formatannotation
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|def formatargspec(args, varargs=None, varkw=None, defaults=None,
  1223|         0|            0|            0|  0.00%|                  kwonlyargs=(), kwonlydefaults={}, annotations={},
  1224|         0|            0|            0|  0.00%|                  formatarg=str,
  1225|         0|            0|            0|  0.00%|                  formatvarargs=lambda name: '*' + name,
  1226|         0|            0|            0|  0.00%|                  formatvarkw=lambda name: '**' + name,
  1227|         0|            0|            0|  0.00%|                  formatvalue=lambda value: '=' + repr(value),
  1228|         0|            0|            0|  0.00%|                  formatreturns=lambda text: ' -> ' + text,
  1229|         0|            0|            0|  0.00%|                  formatannotation=formatannotation):
  1230|         0|            0|            0|  0.00%|    """Format an argument spec from the values returned by getfullargspec.
  1231|         0|            0|            0|  0.00%|
  1232|         0|            0|            0|  0.00%|    The first seven arguments are (args, varargs, varkw, defaults,
  1233|         0|            0|            0|  0.00%|    kwonlyargs, kwonlydefaults, annotations).  The other five arguments
  1234|         0|            0|            0|  0.00%|    are the corresponding optional formatting functions that are called to
  1235|         0|            0|            0|  0.00%|    turn names and values into strings.  The last argument is an optional
  1236|         0|            0|            0|  0.00%|    function to format the sequence of arguments.
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|    Deprecated since Python 3.5: use the `signature` function and `Signature`
  1239|         0|            0|            0|  0.00%|    objects.
  1240|         0|            0|            0|  0.00%|    """
  1241|         0|            0|            0|  0.00%|
  1242|         0|            0|            0|  0.00%|    from warnings import warn
  1243|         0|            0|            0|  0.00%|
  1244|         0|            0|            0|  0.00%|    warn("`formatargspec` is deprecated since Python 3.5. Use `signature` and "
  1245|         0|            0|            0|  0.00%|         "the `Signature` object directly",
  1246|         0|            0|            0|  0.00%|         DeprecationWarning,
  1247|         0|            0|            0|  0.00%|         stacklevel=2)
  1248|         0|            0|            0|  0.00%|
  1249|         0|            0|            0|  0.00%|    def formatargandannotation(arg):
  1250|         0|            0|            0|  0.00%|        result = formatarg(arg)
  1251|         0|            0|            0|  0.00%|        if arg in annotations:
  1252|         0|            0|            0|  0.00%|            result += ': ' + formatannotation(annotations[arg])
  1253|         0|            0|            0|  0.00%|        return result
  1254|         0|            0|            0|  0.00%|    specs = []
  1255|         0|            0|            0|  0.00%|    if defaults:
  1256|         0|            0|            0|  0.00%|        firstdefault = len(args) - len(defaults)
  1257|         0|            0|            0|  0.00%|    for i, arg in enumerate(args):
  1258|         0|            0|            0|  0.00%|        spec = formatargandannotation(arg)
  1259|         0|            0|            0|  0.00%|        if defaults and i >= firstdefault:
  1260|         0|            0|            0|  0.00%|            spec = spec + formatvalue(defaults[i - firstdefault])
  1261|         0|            0|            0|  0.00%|        specs.append(spec)
  1262|         0|            0|            0|  0.00%|    if varargs is not None:
  1263|         0|            0|            0|  0.00%|        specs.append(formatvarargs(formatargandannotation(varargs)))
  1264|         0|            0|            0|  0.00%|    else:
  1265|         0|            0|            0|  0.00%|        if kwonlyargs:
  1266|         0|            0|            0|  0.00%|            specs.append('*')
  1267|         0|            0|            0|  0.00%|    if kwonlyargs:
  1268|         0|            0|            0|  0.00%|        for kwonlyarg in kwonlyargs:
  1269|         0|            0|            0|  0.00%|            spec = formatargandannotation(kwonlyarg)
  1270|         0|            0|            0|  0.00%|            if kwonlydefaults and kwonlyarg in kwonlydefaults:
  1271|         0|            0|            0|  0.00%|                spec += formatvalue(kwonlydefaults[kwonlyarg])
  1272|         0|            0|            0|  0.00%|            specs.append(spec)
  1273|         0|            0|            0|  0.00%|    if varkw is not None:
  1274|         0|            0|            0|  0.00%|        specs.append(formatvarkw(formatargandannotation(varkw)))
  1275|         0|            0|            0|  0.00%|    result = '(' + ', '.join(specs) + ')'
  1276|         0|            0|            0|  0.00%|    if 'return' in annotations:
  1277|         0|            0|            0|  0.00%|        result += formatreturns(formatannotation(annotations['return']))
  1278|         0|            0|            0|  0.00%|    return result
  1279|         0|            0|            0|  0.00%|
  1280|         0|            0|            0|  0.00%|def formatargvalues(args, varargs, varkw, locals,
  1281|         0|            0|            0|  0.00%|                    formatarg=str,
  1282|         0|            0|            0|  0.00%|                    formatvarargs=lambda name: '*' + name,
  1283|         0|            0|            0|  0.00%|                    formatvarkw=lambda name: '**' + name,
  1284|         0|            0|            0|  0.00%|                    formatvalue=lambda value: '=' + repr(value)):
  1285|         0|            0|            0|  0.00%|    """Format an argument spec from the 4 values returned by getargvalues.
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    The first four arguments are (args, varargs, varkw, locals).  The
  1288|         0|            0|            0|  0.00%|    next four arguments are the corresponding optional formatting functions
  1289|         0|            0|            0|  0.00%|    that are called to turn names and values into strings.  The ninth
  1290|         0|            0|            0|  0.00%|    argument is an optional function to format the sequence of arguments."""
  1291|         0|            0|            0|  0.00%|    def convert(name, locals=locals,
  1292|         0|            0|            0|  0.00%|                formatarg=formatarg, formatvalue=formatvalue):
  1293|         0|            0|            0|  0.00%|        return formatarg(name) + formatvalue(locals[name])
  1294|         0|            0|            0|  0.00%|    specs = []
  1295|         0|            0|            0|  0.00%|    for i in range(len(args)):
  1296|         0|            0|            0|  0.00%|        specs.append(convert(args[i]))
  1297|         0|            0|            0|  0.00%|    if varargs:
  1298|         0|            0|            0|  0.00%|        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
  1299|         0|            0|            0|  0.00%|    if varkw:
  1300|         0|            0|            0|  0.00%|        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
  1301|         0|            0|            0|  0.00%|    return '(' + ', '.join(specs) + ')'
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|def _missing_arguments(f_name, argnames, pos, values):
  1304|         0|            0|            0|  0.00%|    names = [repr(name) for name in argnames if name not in values]
  1305|         0|            0|            0|  0.00%|    missing = len(names)
  1306|         0|            0|            0|  0.00%|    if missing == 1:
  1307|         0|            0|            0|  0.00%|        s = names[0]
  1308|         0|            0|            0|  0.00%|    elif missing == 2:
  1309|         0|            0|            0|  0.00%|        s = "{} and {}".format(*names)
  1310|         0|            0|            0|  0.00%|    else:
  1311|         0|            0|            0|  0.00%|        tail = ", {} and {}".format(*names[-2:])
  1312|         0|            0|            0|  0.00%|        del names[-2:]
  1313|         0|            0|            0|  0.00%|        s = ", ".join(names) + tail
  1314|         0|            0|            0|  0.00%|    raise TypeError("%s() missing %i required %s argument%s: %s" %
  1315|         0|            0|            0|  0.00%|                    (f_name, missing,
  1316|         0|            0|            0|  0.00%|                      "positional" if pos else "keyword-only",
  1317|         0|            0|            0|  0.00%|                      "" if missing == 1 else "s", s))
  1318|         0|            0|            0|  0.00%|
  1319|         0|            0|            0|  0.00%|def _too_many(f_name, args, kwonly, varargs, defcount, given, values):
  1320|         0|            0|            0|  0.00%|    atleast = len(args) - defcount
  1321|         0|            0|            0|  0.00%|    kwonly_given = len([arg for arg in kwonly if arg in values])
  1322|         0|            0|            0|  0.00%|    if varargs:
  1323|         0|            0|            0|  0.00%|        plural = atleast != 1
  1324|         0|            0|            0|  0.00%|        sig = "at least %d" % (atleast,)
  1325|         0|            0|            0|  0.00%|    elif defcount:
  1326|         0|            0|            0|  0.00%|        plural = True
  1327|         0|            0|            0|  0.00%|        sig = "from %d to %d" % (atleast, len(args))
  1328|         0|            0|            0|  0.00%|    else:
  1329|         0|            0|            0|  0.00%|        plural = len(args) != 1
  1330|         0|            0|            0|  0.00%|        sig = str(len(args))
  1331|         0|            0|            0|  0.00%|    kwonly_sig = ""
  1332|         0|            0|            0|  0.00%|    if kwonly_given:
  1333|         0|            0|            0|  0.00%|        msg = " positional argument%s (and %d keyword-only argument%s)"
  1334|         0|            0|            0|  0.00%|        kwonly_sig = (msg % ("s" if given != 1 else "", kwonly_given,
  1335|         0|            0|            0|  0.00%|                             "s" if kwonly_given != 1 else ""))
  1336|         0|            0|            0|  0.00%|    raise TypeError("%s() takes %s positional argument%s but %d%s %s given" %
  1337|         0|            0|            0|  0.00%|            (f_name, sig, "s" if plural else "", given, kwonly_sig,
  1338|         0|            0|            0|  0.00%|             "was" if given == 1 and not kwonly_given else "were"))
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|def getcallargs(func, /, *positional, **named):
  1341|         0|            0|            0|  0.00%|    """Get the mapping of arguments to values.
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|    A dict is returned, with keys the function argument names (including the
  1344|         0|            0|            0|  0.00%|    names of the * and ** arguments, if any), and values the respective bound
  1345|         0|            0|            0|  0.00%|    values from 'positional' and 'named'."""
  1346|         0|            0|            0|  0.00%|    spec = getfullargspec(func)
  1347|         0|            0|            0|  0.00%|    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec
  1348|         0|            0|            0|  0.00%|    f_name = func.__name__
  1349|         0|            0|            0|  0.00%|    arg2value = {}
  1350|         0|            0|            0|  0.00%|
  1351|         0|            0|            0|  0.00%|
  1352|         0|            0|            0|  0.00%|    if ismethod(func) and func.__self__ is not None:
  1353|         0|            0|            0|  0.00%|        # implicit 'self' (or 'cls' for classmethods) argument
  1354|         0|            0|            0|  0.00%|        positional = (func.__self__,) + positional
  1355|         0|            0|            0|  0.00%|    num_pos = len(positional)
  1356|         0|            0|            0|  0.00%|    num_args = len(args)
  1357|         0|            0|            0|  0.00%|    num_defaults = len(defaults) if defaults else 0
  1358|         0|            0|            0|  0.00%|
  1359|         0|            0|            0|  0.00%|    n = min(num_pos, num_args)
  1360|         0|            0|            0|  0.00%|    for i in range(n):
  1361|         0|            0|            0|  0.00%|        arg2value[args[i]] = positional[i]
  1362|         0|            0|            0|  0.00%|    if varargs:
  1363|         0|            0|            0|  0.00%|        arg2value[varargs] = tuple(positional[n:])
  1364|         0|            0|            0|  0.00%|    possible_kwargs = set(args + kwonlyargs)
  1365|         0|            0|            0|  0.00%|    if varkw:
  1366|         0|            0|            0|  0.00%|        arg2value[varkw] = {}
  1367|         0|            0|            0|  0.00%|    for kw, value in named.items():
  1368|         0|            0|            0|  0.00%|        if kw not in possible_kwargs:
  1369|         0|            0|            0|  0.00%|            if not varkw:
  1370|         0|            0|            0|  0.00%|                raise TypeError("%s() got an unexpected keyword argument %r" %
  1371|         0|            0|            0|  0.00%|                                (f_name, kw))
  1372|         0|            0|            0|  0.00%|            arg2value[varkw][kw] = value
  1373|         0|            0|            0|  0.00%|            continue
  1374|         0|            0|            0|  0.00%|        if kw in arg2value:
  1375|         0|            0|            0|  0.00%|            raise TypeError("%s() got multiple values for argument %r" %
  1376|         0|            0|            0|  0.00%|                            (f_name, kw))
  1377|         0|            0|            0|  0.00%|        arg2value[kw] = value
  1378|         0|            0|            0|  0.00%|    if num_pos > num_args and not varargs:
  1379|         0|            0|            0|  0.00%|        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,
  1380|         0|            0|            0|  0.00%|                   num_pos, arg2value)
  1381|         0|            0|            0|  0.00%|    if num_pos < num_args:
  1382|         0|            0|            0|  0.00%|        req = args[:num_args - num_defaults]
  1383|         0|            0|            0|  0.00%|        for arg in req:
  1384|         0|            0|            0|  0.00%|            if arg not in arg2value:
  1385|         0|            0|            0|  0.00%|                _missing_arguments(f_name, req, True, arg2value)
  1386|         0|            0|            0|  0.00%|        for i, arg in enumerate(args[num_args - num_defaults:]):
  1387|         0|            0|            0|  0.00%|            if arg not in arg2value:
  1388|         0|            0|            0|  0.00%|                arg2value[arg] = defaults[i]
  1389|         0|            0|            0|  0.00%|    missing = 0
  1390|         0|            0|            0|  0.00%|    for kwarg in kwonlyargs:
  1391|         0|            0|            0|  0.00%|        if kwarg not in arg2value:
  1392|         0|            0|            0|  0.00%|            if kwonlydefaults and kwarg in kwonlydefaults:
  1393|         0|            0|            0|  0.00%|                arg2value[kwarg] = kwonlydefaults[kwarg]
  1394|         0|            0|            0|  0.00%|            else:
  1395|         0|            0|            0|  0.00%|                missing += 1
  1396|         0|            0|            0|  0.00%|    if missing:
  1397|         0|            0|            0|  0.00%|        _missing_arguments(f_name, kwonlyargs, False, arg2value)
  1398|         0|            0|            0|  0.00%|    return arg2value
  1399|         0|            0|            0|  0.00%|
  1400|         0|            0|            0|  0.00%|ClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')
  1401|         0|            0|            0|  0.00%|
  1402|         0|            0|            0|  0.00%|def getclosurevars(func):
  1403|         0|            0|            0|  0.00%|    """
  1404|         0|            0|            0|  0.00%|    Get the mapping of free variables to their current values.
  1405|         0|            0|            0|  0.00%|
  1406|         0|            0|            0|  0.00%|    Returns a named tuple of dicts mapping the current nonlocal, global
  1407|         0|            0|            0|  0.00%|    and builtin references as seen by the body of the function. A final
  1408|         0|            0|            0|  0.00%|    set of unbound names that could not be resolved is also provided.
  1409|         0|            0|            0|  0.00%|    """
  1410|         0|            0|            0|  0.00%|
  1411|         0|            0|            0|  0.00%|    if ismethod(func):
  1412|         0|            0|            0|  0.00%|        func = func.__func__
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|    if not isfunction(func):
  1415|         0|            0|            0|  0.00%|        raise TypeError("{!r} is not a Python function".format(func))
  1416|         0|            0|            0|  0.00%|
  1417|         0|            0|            0|  0.00%|    code = func.__code__
  1418|         0|            0|            0|  0.00%|    # Nonlocal references are named in co_freevars and resolved
  1419|         0|            0|            0|  0.00%|    # by looking them up in __closure__ by positional index
  1420|         0|            0|            0|  0.00%|    if func.__closure__ is None:
  1421|         0|            0|            0|  0.00%|        nonlocal_vars = {}
  1422|         0|            0|            0|  0.00%|    else:
  1423|         0|            0|            0|  0.00%|        nonlocal_vars = {
  1424|         0|            0|            0|  0.00%|            var : cell.cell_contents
  1425|         0|            0|            0|  0.00%|            for var, cell in zip(code.co_freevars, func.__closure__)
  1426|         0|            0|            0|  0.00%|       }
  1427|         0|            0|            0|  0.00%|
  1428|         0|            0|            0|  0.00%|    # Global and builtin references are named in co_names and resolved
  1429|         0|            0|            0|  0.00%|    # by looking them up in __globals__ or __builtins__
  1430|         0|            0|            0|  0.00%|    global_ns = func.__globals__
  1431|         0|            0|            0|  0.00%|    builtin_ns = global_ns.get("__builtins__", builtins.__dict__)
  1432|         0|            0|            0|  0.00%|    if ismodule(builtin_ns):
  1433|         0|            0|            0|  0.00%|        builtin_ns = builtin_ns.__dict__
  1434|         0|            0|            0|  0.00%|    global_vars = {}
  1435|         0|            0|            0|  0.00%|    builtin_vars = {}
  1436|         0|            0|            0|  0.00%|    unbound_names = set()
  1437|         0|            0|            0|  0.00%|    for name in code.co_names:
  1438|         0|            0|            0|  0.00%|        if name in ("None", "True", "False"):
  1439|         0|            0|            0|  0.00%|            # Because these used to be builtins instead of keywords, they
  1440|         0|            0|            0|  0.00%|            # may still show up as name references. We ignore them.
  1441|         0|            0|            0|  0.00%|            continue
  1442|         0|            0|            0|  0.00%|        try:
  1443|         0|            0|            0|  0.00%|            global_vars[name] = global_ns[name]
  1444|         0|            0|            0|  0.00%|        except KeyError:
  1445|         0|            0|            0|  0.00%|            try:
  1446|         0|            0|            0|  0.00%|                builtin_vars[name] = builtin_ns[name]
  1447|         0|            0|            0|  0.00%|            except KeyError:
  1448|         0|            0|            0|  0.00%|                unbound_names.add(name)
  1449|         0|            0|            0|  0.00%|
  1450|         0|            0|            0|  0.00%|    return ClosureVars(nonlocal_vars, global_vars,
  1451|         0|            0|            0|  0.00%|                       builtin_vars, unbound_names)
  1452|         0|            0|            0|  0.00%|
  1453|         0|            0|            0|  0.00%|# -------------------------------------------------- stack frame extraction
  1454|         0|            0|            0|  0.00%|
  1455|         0|            0|            0|  0.00%|Traceback = namedtuple('Traceback', 'filename lineno function code_context index')
  1456|         0|            0|            0|  0.00%|
  1457|         0|            0|            0|  0.00%|def getframeinfo(frame, context=1):
  1458|         0|            0|            0|  0.00%|    """Get information about a frame or traceback object.
  1459|         0|            0|            0|  0.00%|
  1460|         0|            0|            0|  0.00%|    A tuple of five things is returned: the filename, the line number of
  1461|         0|            0|            0|  0.00%|    the current line, the function name, a list of lines of context from
  1462|         0|            0|            0|  0.00%|    the source code, and the index of the current line within that list.
  1463|         0|            0|            0|  0.00%|    The optional second argument specifies the number of lines of context
  1464|         0|            0|            0|  0.00%|    to return, which are centered around the current line."""
  1465|         0|            0|            0|  0.00%|    if istraceback(frame):
  1466|         0|            0|            0|  0.00%|        lineno = frame.tb_lineno
  1467|         0|            0|            0|  0.00%|        frame = frame.tb_frame
  1468|         0|            0|            0|  0.00%|    else:
  1469|         0|            0|            0|  0.00%|        lineno = frame.f_lineno
  1470|         0|            0|            0|  0.00%|    if not isframe(frame):
  1471|         0|            0|            0|  0.00%|        raise TypeError('{!r} is not a frame or traceback object'.format(frame))
  1472|         0|            0|            0|  0.00%|
  1473|         0|            0|            0|  0.00%|    filename = getsourcefile(frame) or getfile(frame)
  1474|         0|            0|            0|  0.00%|    if context > 0:
  1475|         0|            0|            0|  0.00%|        start = lineno - 1 - context//2
  1476|         0|            0|            0|  0.00%|        try:
  1477|         0|            0|            0|  0.00%|            lines, lnum = findsource(frame)
  1478|         0|            0|            0|  0.00%|        except OSError:
  1479|         0|            0|            0|  0.00%|            lines = index = None
  1480|         0|            0|            0|  0.00%|        else:
  1481|         0|            0|            0|  0.00%|            start = max(0, min(start, len(lines) - context))
  1482|         0|            0|            0|  0.00%|            lines = lines[start:start+context]
  1483|         0|            0|            0|  0.00%|            index = lineno - 1 - start
  1484|         0|            0|            0|  0.00%|    else:
  1485|         0|            0|            0|  0.00%|        lines = index = None
  1486|         0|            0|            0|  0.00%|
  1487|         0|            0|            0|  0.00%|    return Traceback(filename, lineno, frame.f_code.co_name, lines, index)
  1488|         0|            0|            0|  0.00%|
  1489|         0|            0|            0|  0.00%|def getlineno(frame):
  1490|         0|            0|            0|  0.00%|    """Get the line number from a frame object, allowing for optimization."""
  1491|         0|            0|            0|  0.00%|    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
  1492|         0|            0|            0|  0.00%|    return frame.f_lineno
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|FrameInfo = namedtuple('FrameInfo', ('frame',) + Traceback._fields)
  1495|         0|            0|            0|  0.00%|
  1496|         0|            0|            0|  0.00%|def getouterframes(frame, context=1):
  1497|         0|            0|            0|  0.00%|    """Get a list of records for a frame and all higher (calling) frames.
  1498|         0|            0|            0|  0.00%|
  1499|         0|            0|            0|  0.00%|    Each record contains a frame object, filename, line number, function
  1500|         0|            0|            0|  0.00%|    name, a list of lines of context, and index within the context."""
  1501|         0|            0|            0|  0.00%|    framelist = []
  1502|         0|            0|            0|  0.00%|    while frame:
  1503|         0|            0|            0|  0.00%|        frameinfo = (frame,) + getframeinfo(frame, context)
  1504|         0|            0|            0|  0.00%|        framelist.append(FrameInfo(*frameinfo))
  1505|         0|            0|            0|  0.00%|        frame = frame.f_back
  1506|         0|            0|            0|  0.00%|    return framelist
  1507|         0|            0|            0|  0.00%|
  1508|         0|            0|            0|  0.00%|def getinnerframes(tb, context=1):
  1509|         0|            0|            0|  0.00%|    """Get a list of records for a traceback's frame and all lower frames.
  1510|         0|            0|            0|  0.00%|
  1511|         0|            0|            0|  0.00%|    Each record contains a frame object, filename, line number, function
  1512|         0|            0|            0|  0.00%|    name, a list of lines of context, and index within the context."""
  1513|         0|            0|            0|  0.00%|    framelist = []
  1514|         0|            0|            0|  0.00%|    while tb:
  1515|         0|            0|            0|  0.00%|        frameinfo = (tb.tb_frame,) + getframeinfo(tb, context)
  1516|         0|            0|            0|  0.00%|        framelist.append(FrameInfo(*frameinfo))
  1517|         0|            0|            0|  0.00%|        tb = tb.tb_next
  1518|         0|            0|            0|  0.00%|    return framelist
  1519|         0|            0|            0|  0.00%|
  1520|         0|            0|            0|  0.00%|def currentframe():
  1521|         0|            0|            0|  0.00%|    """Return the frame of the caller or None if this is not possible."""
  1522|         0|            0|            0|  0.00%|    return sys._getframe(1) if hasattr(sys, "_getframe") else None
  1523|         0|            0|            0|  0.00%|
  1524|         0|            0|            0|  0.00%|def stack(context=1):
  1525|         0|            0|            0|  0.00%|    """Return a list of records for the stack above the caller's frame."""
  1526|         0|            0|            0|  0.00%|    return getouterframes(sys._getframe(1), context)
  1527|         0|            0|            0|  0.00%|
  1528|         0|            0|            0|  0.00%|def trace(context=1):
  1529|         0|            0|            0|  0.00%|    """Return a list of records for the stack below the current exception."""
  1530|         0|            0|            0|  0.00%|    return getinnerframes(sys.exc_info()[2], context)
  1531|         0|            0|            0|  0.00%|
  1532|         0|            0|            0|  0.00%|
  1533|         0|            0|            0|  0.00%|# ------------------------------------------------ static version of getattr
  1534|         0|            0|            0|  0.00%|
  1535|         0|            0|            0|  0.00%|_sentinel = object()
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|def _static_getmro(klass):
  1538|         0|            0|            0|  0.00%|    return type.__dict__['__mro__'].__get__(klass)
  1539|         0|            0|            0|  0.00%|
  1540|         0|            0|            0|  0.00%|def _check_instance(obj, attr):
  1541|         0|            0|            0|  0.00%|    instance_dict = {}
  1542|         0|            0|            0|  0.00%|    try:
  1543|         0|            0|            0|  0.00%|        instance_dict = object.__getattribute__(obj, "__dict__")
  1544|         0|            0|            0|  0.00%|    except AttributeError:
  1545|         0|            0|            0|  0.00%|        pass
  1546|         0|            0|            0|  0.00%|    return dict.get(instance_dict, attr, _sentinel)
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|
  1549|         0|            0|            0|  0.00%|def _check_class(klass, attr):
  1550|         0|            0|            0|  0.00%|    for entry in _static_getmro(klass):
  1551|         0|            0|            0|  0.00%|        if _shadowed_dict(type(entry)) is _sentinel:
  1552|         0|            0|            0|  0.00%|            try:
  1553|         0|            0|            0|  0.00%|                return entry.__dict__[attr]
  1554|         0|            0|            0|  0.00%|            except KeyError:
  1555|         0|            0|            0|  0.00%|                pass
  1556|         0|            0|            0|  0.00%|    return _sentinel
  1557|         0|            0|            0|  0.00%|
  1558|         0|            0|            0|  0.00%|def _is_type(obj):
  1559|         0|            0|            0|  0.00%|    try:
  1560|         0|            0|            0|  0.00%|        _static_getmro(obj)
  1561|         0|            0|            0|  0.00%|    except TypeError:
  1562|         0|            0|            0|  0.00%|        return False
  1563|         0|            0|            0|  0.00%|    return True
  1564|         0|            0|            0|  0.00%|
  1565|         0|            0|            0|  0.00%|def _shadowed_dict(klass):
  1566|         0|            0|            0|  0.00%|    dict_attr = type.__dict__["__dict__"]
  1567|         0|            0|            0|  0.00%|    for entry in _static_getmro(klass):
  1568|         0|            0|            0|  0.00%|        try:
  1569|         0|            0|            0|  0.00%|            class_dict = dict_attr.__get__(entry)["__dict__"]
  1570|         0|            0|            0|  0.00%|        except KeyError:
  1571|         0|            0|            0|  0.00%|            pass
  1572|         0|            0|            0|  0.00%|        else:
  1573|         0|            0|            0|  0.00%|            if not (type(class_dict) is types.GetSetDescriptorType and
  1574|         0|            0|            0|  0.00%|                    class_dict.__name__ == "__dict__" and
  1575|         0|            0|            0|  0.00%|                    class_dict.__objclass__ is entry):
  1576|         0|            0|            0|  0.00%|                return class_dict
  1577|         0|            0|            0|  0.00%|    return _sentinel
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|def getattr_static(obj, attr, default=_sentinel):
  1580|         0|            0|            0|  0.00%|    """Retrieve attributes without triggering dynamic lookup via the
  1581|         0|            0|            0|  0.00%|       descriptor protocol,  __getattr__ or __getattribute__.
  1582|         0|            0|            0|  0.00%|
  1583|         0|            0|            0|  0.00%|       Note: this function may not be able to retrieve all attributes
  1584|         0|            0|            0|  0.00%|       that getattr can fetch (like dynamically created attributes)
  1585|         0|            0|            0|  0.00%|       and may find attributes that getattr can't (like descriptors
  1586|         0|            0|            0|  0.00%|       that raise AttributeError). It can also return descriptor objects
  1587|         0|            0|            0|  0.00%|       instead of instance members in some cases. See the
  1588|         0|            0|            0|  0.00%|       documentation for details.
  1589|         0|            0|            0|  0.00%|    """
  1590|         0|            0|            0|  0.00%|    instance_result = _sentinel
  1591|         0|            0|            0|  0.00%|    if not _is_type(obj):
  1592|         0|            0|            0|  0.00%|        klass = type(obj)
  1593|         0|            0|            0|  0.00%|        dict_attr = _shadowed_dict(klass)
  1594|         0|            0|            0|  0.00%|        if (dict_attr is _sentinel or
  1595|         0|            0|            0|  0.00%|            type(dict_attr) is types.MemberDescriptorType):
  1596|         0|            0|            0|  0.00%|            instance_result = _check_instance(obj, attr)
  1597|         0|            0|            0|  0.00%|    else:
  1598|         0|            0|            0|  0.00%|        klass = obj
  1599|         0|            0|            0|  0.00%|
  1600|         0|            0|            0|  0.00%|    klass_result = _check_class(klass, attr)
  1601|         0|            0|            0|  0.00%|
  1602|         0|            0|            0|  0.00%|    if instance_result is not _sentinel and klass_result is not _sentinel:
  1603|         0|            0|            0|  0.00%|        if (_check_class(type(klass_result), '__get__') is not _sentinel and
  1604|         0|            0|            0|  0.00%|            _check_class(type(klass_result), '__set__') is not _sentinel):
  1605|         0|            0|            0|  0.00%|            return klass_result
  1606|         0|            0|            0|  0.00%|
  1607|         0|            0|            0|  0.00%|    if instance_result is not _sentinel:
  1608|         0|            0|            0|  0.00%|        return instance_result
  1609|         0|            0|            0|  0.00%|    if klass_result is not _sentinel:
  1610|         0|            0|            0|  0.00%|        return klass_result
  1611|         0|            0|            0|  0.00%|
  1612|         0|            0|            0|  0.00%|    if obj is klass:
  1613|         0|            0|            0|  0.00%|        # for types we check the metaclass too
  1614|         0|            0|            0|  0.00%|        for entry in _static_getmro(type(klass)):
  1615|         0|            0|            0|  0.00%|            if _shadowed_dict(type(entry)) is _sentinel:
  1616|         0|            0|            0|  0.00%|                try:
  1617|         0|            0|            0|  0.00%|                    return entry.__dict__[attr]
  1618|         0|            0|            0|  0.00%|                except KeyError:
  1619|         0|            0|            0|  0.00%|                    pass
  1620|         0|            0|            0|  0.00%|    if default is not _sentinel:
  1621|         0|            0|            0|  0.00%|        return default
  1622|         0|            0|            0|  0.00%|    raise AttributeError(attr)
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|
  1625|         0|            0|            0|  0.00%|# ------------------------------------------------ generator introspection
  1626|         0|            0|            0|  0.00%|
  1627|         0|            0|            0|  0.00%|GEN_CREATED = 'GEN_CREATED'
  1628|         0|            0|            0|  0.00%|GEN_RUNNING = 'GEN_RUNNING'
  1629|         0|            0|            0|  0.00%|GEN_SUSPENDED = 'GEN_SUSPENDED'
  1630|         0|            0|            0|  0.00%|GEN_CLOSED = 'GEN_CLOSED'
  1631|         0|            0|            0|  0.00%|
  1632|         0|            0|            0|  0.00%|def getgeneratorstate(generator):
  1633|         0|            0|            0|  0.00%|    """Get current state of a generator-iterator.
  1634|         0|            0|            0|  0.00%|
  1635|         0|            0|            0|  0.00%|    Possible states are:
  1636|         0|            0|            0|  0.00%|      GEN_CREATED: Waiting to start execution.
  1637|         0|            0|            0|  0.00%|      GEN_RUNNING: Currently being executed by the interpreter.
  1638|         0|            0|            0|  0.00%|      GEN_SUSPENDED: Currently suspended at a yield expression.
  1639|         0|            0|            0|  0.00%|      GEN_CLOSED: Execution has completed.
  1640|         0|            0|            0|  0.00%|    """
  1641|         0|            0|            0|  0.00%|    if generator.gi_running:
  1642|         0|            0|            0|  0.00%|        return GEN_RUNNING
  1643|         0|            0|            0|  0.00%|    if generator.gi_frame is None:
  1644|         0|            0|            0|  0.00%|        return GEN_CLOSED
  1645|         0|            0|            0|  0.00%|    if generator.gi_frame.f_lasti == -1:
  1646|         0|            0|            0|  0.00%|        return GEN_CREATED
  1647|         0|            0|            0|  0.00%|    return GEN_SUSPENDED
  1648|         0|            0|            0|  0.00%|
  1649|         0|            0|            0|  0.00%|
  1650|         0|            0|            0|  0.00%|def getgeneratorlocals(generator):
  1651|         0|            0|            0|  0.00%|    """
  1652|         0|            0|            0|  0.00%|    Get the mapping of generator local variables to their current values.
  1653|         0|            0|            0|  0.00%|
  1654|         0|            0|            0|  0.00%|    A dict is returned, with the keys the local variable names and values the
  1655|         0|            0|            0|  0.00%|    bound values."""
  1656|         0|            0|            0|  0.00%|
  1657|         0|            0|            0|  0.00%|    if not isgenerator(generator):
  1658|         0|            0|            0|  0.00%|        raise TypeError("{!r} is not a Python generator".format(generator))
  1659|         0|            0|            0|  0.00%|
  1660|         0|            0|            0|  0.00%|    frame = getattr(generator, "gi_frame", None)
  1661|         0|            0|            0|  0.00%|    if frame is not None:
  1662|         0|            0|            0|  0.00%|        return generator.gi_frame.f_locals
  1663|         0|            0|            0|  0.00%|    else:
  1664|         0|            0|            0|  0.00%|        return {}
  1665|         0|            0|            0|  0.00%|
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|# ------------------------------------------------ coroutine introspection
  1668|         0|            0|            0|  0.00%|
  1669|         0|            0|            0|  0.00%|CORO_CREATED = 'CORO_CREATED'
  1670|         0|            0|            0|  0.00%|CORO_RUNNING = 'CORO_RUNNING'
  1671|         0|            0|            0|  0.00%|CORO_SUSPENDED = 'CORO_SUSPENDED'
  1672|         0|            0|            0|  0.00%|CORO_CLOSED = 'CORO_CLOSED'
  1673|         0|            0|            0|  0.00%|
  1674|         0|            0|            0|  0.00%|def getcoroutinestate(coroutine):
  1675|         0|            0|            0|  0.00%|    """Get current state of a coroutine object.
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|    Possible states are:
  1678|         0|            0|            0|  0.00%|      CORO_CREATED: Waiting to start execution.
  1679|         0|            0|            0|  0.00%|      CORO_RUNNING: Currently being executed by the interpreter.
  1680|         0|            0|            0|  0.00%|      CORO_SUSPENDED: Currently suspended at an await expression.
  1681|         0|            0|            0|  0.00%|      CORO_CLOSED: Execution has completed.
  1682|         0|            0|            0|  0.00%|    """
  1683|         0|            0|            0|  0.00%|    if coroutine.cr_running:
  1684|         0|            0|            0|  0.00%|        return CORO_RUNNING
  1685|         0|            0|            0|  0.00%|    if coroutine.cr_frame is None:
  1686|         0|            0|            0|  0.00%|        return CORO_CLOSED
  1687|         0|            0|            0|  0.00%|    if coroutine.cr_frame.f_lasti == -1:
  1688|         0|            0|            0|  0.00%|        return CORO_CREATED
  1689|         0|            0|            0|  0.00%|    return CORO_SUSPENDED
  1690|         0|            0|            0|  0.00%|
  1691|         0|            0|            0|  0.00%|
  1692|         0|            0|            0|  0.00%|def getcoroutinelocals(coroutine):
  1693|         0|            0|            0|  0.00%|    """
  1694|         0|            0|            0|  0.00%|    Get the mapping of coroutine local variables to their current values.
  1695|         0|            0|            0|  0.00%|
  1696|         0|            0|            0|  0.00%|    A dict is returned, with the keys the local variable names and values the
  1697|         0|            0|            0|  0.00%|    bound values."""
  1698|         0|            0|            0|  0.00%|    frame = getattr(coroutine, "cr_frame", None)
  1699|         0|            0|            0|  0.00%|    if frame is not None:
  1700|         0|            0|            0|  0.00%|        return frame.f_locals
  1701|         0|            0|            0|  0.00%|    else:
  1702|         0|            0|            0|  0.00%|        return {}
  1703|         0|            0|            0|  0.00%|
  1704|         0|            0|            0|  0.00%|
  1705|         0|            0|            0|  0.00%|###############################################################################
  1706|         0|            0|            0|  0.00%|### Function Signature Object (PEP 362)
  1707|         0|            0|            0|  0.00%|###############################################################################
  1708|         0|            0|            0|  0.00%|
  1709|         0|            0|            0|  0.00%|
  1710|         0|            0|            0|  0.00%|_WrapperDescriptor = type(type.__call__)
  1711|         0|            0|            0|  0.00%|_MethodWrapper = type(all.__call__)
  1712|         0|            0|            0|  0.00%|_ClassMethodWrapper = type(int.__dict__['from_bytes'])
  1713|         0|            0|            0|  0.00%|
  1714|         0|            0|            0|  0.00%|_NonUserDefinedCallables = (_WrapperDescriptor,
  1715|         0|            0|            0|  0.00%|                            _MethodWrapper,
  1716|         0|            0|            0|  0.00%|                            _ClassMethodWrapper,
  1717|         0|            0|            0|  0.00%|                            types.BuiltinFunctionType)
  1718|         0|            0|            0|  0.00%|
  1719|         0|            0|            0|  0.00%|
  1720|         0|            0|            0|  0.00%|def _signature_get_user_defined_method(cls, method_name):
  1721|         0|            0|            0|  0.00%|    """Private helper. Checks if ``cls`` has an attribute
  1722|         0|            0|            0|  0.00%|    named ``method_name`` and returns it only if it is a
  1723|         0|            0|            0|  0.00%|    pure python function.
  1724|         0|            0|            0|  0.00%|    """
  1725|         0|            0|            0|  0.00%|    try:
  1726|         0|            0|            0|  0.00%|        meth = getattr(cls, method_name)
  1727|         0|            0|            0|  0.00%|    except AttributeError:
  1728|         0|            0|            0|  0.00%|        return
  1729|         0|            0|            0|  0.00%|    else:
  1730|         0|            0|            0|  0.00%|        if not isinstance(meth, _NonUserDefinedCallables):
  1731|         0|            0|            0|  0.00%|            # Once '__signature__' will be added to 'C'-level
  1732|         0|            0|            0|  0.00%|            # callables, this check won't be necessary
  1733|         0|            0|            0|  0.00%|            return meth
  1734|         0|            0|            0|  0.00%|
  1735|         0|            0|            0|  0.00%|
  1736|         0|            0|            0|  0.00%|def _signature_get_partial(wrapped_sig, partial, extra_args=()):
  1737|         0|            0|            0|  0.00%|    """Private helper to calculate how 'wrapped_sig' signature will
  1738|         0|            0|            0|  0.00%|    look like after applying a 'functools.partial' object (or alike)
  1739|         0|            0|            0|  0.00%|    on it.
  1740|         0|            0|            0|  0.00%|    """
  1741|         0|            0|            0|  0.00%|
  1742|         0|            0|            0|  0.00%|    old_params = wrapped_sig.parameters
  1743|         0|            0|            0|  0.00%|    new_params = OrderedDict(old_params.items())
  1744|         0|            0|            0|  0.00%|
  1745|         0|            0|            0|  0.00%|    partial_args = partial.args or ()
  1746|         0|            0|            0|  0.00%|    partial_keywords = partial.keywords or {}
  1747|         0|            0|            0|  0.00%|
  1748|         0|            0|            0|  0.00%|    if extra_args:
  1749|         0|            0|            0|  0.00%|        partial_args = extra_args + partial_args
  1750|         0|            0|            0|  0.00%|
  1751|         0|            0|            0|  0.00%|    try:
  1752|         0|            0|            0|  0.00%|        ba = wrapped_sig.bind_partial(*partial_args, **partial_keywords)
  1753|         0|            0|            0|  0.00%|    except TypeError as ex:
  1754|         0|            0|            0|  0.00%|        msg = 'partial object {!r} has incorrect arguments'.format(partial)
  1755|         0|            0|            0|  0.00%|        raise ValueError(msg) from ex
  1756|         0|            0|            0|  0.00%|
  1757|         0|            0|            0|  0.00%|
  1758|         0|            0|            0|  0.00%|    transform_to_kwonly = False
  1759|         0|            0|            0|  0.00%|    for param_name, param in old_params.items():
  1760|         0|            0|            0|  0.00%|        try:
  1761|         0|            0|            0|  0.00%|            arg_value = ba.arguments[param_name]
  1762|         0|            0|            0|  0.00%|        except KeyError:
  1763|         0|            0|            0|  0.00%|            pass
  1764|         0|            0|            0|  0.00%|        else:
  1765|         0|            0|            0|  0.00%|            if param.kind is _POSITIONAL_ONLY:
  1766|         0|            0|            0|  0.00%|                # If positional-only parameter is bound by partial,
  1767|         0|            0|            0|  0.00%|                # it effectively disappears from the signature
  1768|         0|            0|            0|  0.00%|                new_params.pop(param_name)
  1769|         0|            0|            0|  0.00%|                continue
  1770|         0|            0|            0|  0.00%|
  1771|         0|            0|            0|  0.00%|            if param.kind is _POSITIONAL_OR_KEYWORD:
  1772|         0|            0|            0|  0.00%|                if param_name in partial_keywords:
  1773|         0|            0|            0|  0.00%|                    # This means that this parameter, and all parameters
  1774|         0|            0|            0|  0.00%|                    # after it should be keyword-only (and var-positional
  1775|         0|            0|            0|  0.00%|                    # should be removed). Here's why. Consider the following
  1776|         0|            0|            0|  0.00%|                    # function:
  1777|         0|            0|            0|  0.00%|                    #     foo(a, b, *args, c):
  1778|         0|            0|            0|  0.00%|                    #         pass
  1779|         0|            0|            0|  0.00%|                    #
  1780|         0|            0|            0|  0.00%|                    # "partial(foo, a='spam')" will have the following
  1781|         0|            0|            0|  0.00%|                    # signature: "(*, a='spam', b, c)". Because attempting
  1782|         0|            0|            0|  0.00%|                    # to call that partial with "(10, 20)" arguments will
  1783|         0|            0|            0|  0.00%|                    # raise a TypeError, saying that "a" argument received
  1784|         0|            0|            0|  0.00%|                    # multiple values.
  1785|         0|            0|            0|  0.00%|                    transform_to_kwonly = True
  1786|         0|            0|            0|  0.00%|                    # Set the new default value
  1787|         0|            0|            0|  0.00%|                    new_params[param_name] = param.replace(default=arg_value)
  1788|         0|            0|            0|  0.00%|                else:
  1789|         0|            0|            0|  0.00%|                    # was passed as a positional argument
  1790|         0|            0|            0|  0.00%|                    new_params.pop(param.name)
  1791|         0|            0|            0|  0.00%|                    continue
  1792|         0|            0|            0|  0.00%|
  1793|         0|            0|            0|  0.00%|            if param.kind is _KEYWORD_ONLY:
  1794|         0|            0|            0|  0.00%|                # Set the new default value
  1795|         0|            0|            0|  0.00%|                new_params[param_name] = param.replace(default=arg_value)
  1796|         0|            0|            0|  0.00%|
  1797|         0|            0|            0|  0.00%|        if transform_to_kwonly:
  1798|         0|            0|            0|  0.00%|            assert param.kind is not _POSITIONAL_ONLY
  1799|         0|            0|            0|  0.00%|
  1800|         0|            0|            0|  0.00%|            if param.kind is _POSITIONAL_OR_KEYWORD:
  1801|         0|            0|            0|  0.00%|                new_param = new_params[param_name].replace(kind=_KEYWORD_ONLY)
  1802|         0|            0|            0|  0.00%|                new_params[param_name] = new_param
  1803|         0|            0|            0|  0.00%|                new_params.move_to_end(param_name)
  1804|         0|            0|            0|  0.00%|            elif param.kind in (_KEYWORD_ONLY, _VAR_KEYWORD):
  1805|         0|            0|            0|  0.00%|                new_params.move_to_end(param_name)
  1806|         0|            0|            0|  0.00%|            elif param.kind is _VAR_POSITIONAL:
  1807|         0|            0|            0|  0.00%|                new_params.pop(param.name)
  1808|         0|            0|            0|  0.00%|
  1809|         0|            0|            0|  0.00%|    return wrapped_sig.replace(parameters=new_params.values())
  1810|         0|            0|            0|  0.00%|
  1811|         0|            0|            0|  0.00%|
  1812|         0|            0|            0|  0.00%|def _signature_bound_method(sig):
  1813|         0|            0|            0|  0.00%|    """Private helper to transform signatures for unbound
  1814|         0|            0|            0|  0.00%|    functions to bound methods.
  1815|         0|            0|            0|  0.00%|    """
  1816|         0|            0|            0|  0.00%|
  1817|         0|            0|            0|  0.00%|    params = tuple(sig.parameters.values())
  1818|         0|            0|            0|  0.00%|
  1819|         0|            0|            0|  0.00%|    if not params or params[0].kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  1820|         0|            0|            0|  0.00%|        raise ValueError('invalid method signature')
  1821|         0|            0|            0|  0.00%|
  1822|         0|            0|            0|  0.00%|    kind = params[0].kind
  1823|         0|            0|            0|  0.00%|    if kind in (_POSITIONAL_OR_KEYWORD, _POSITIONAL_ONLY):
  1824|         0|            0|            0|  0.00%|        # Drop first parameter:
  1825|         0|            0|            0|  0.00%|        # '(p1, p2[, ...])' -> '(p2[, ...])'
  1826|         0|            0|            0|  0.00%|        params = params[1:]
  1827|         0|            0|            0|  0.00%|    else:
  1828|         0|            0|            0|  0.00%|        if kind is not _VAR_POSITIONAL:
  1829|         0|            0|            0|  0.00%|            # Unless we add a new parameter type we never
  1830|         0|            0|            0|  0.00%|            # get here
  1831|         0|            0|            0|  0.00%|            raise ValueError('invalid argument type')
  1832|         0|            0|            0|  0.00%|        # It's a var-positional parameter.
  1833|         0|            0|            0|  0.00%|        # Do nothing. '(*args[, ...])' -> '(*args[, ...])'
  1834|         0|            0|            0|  0.00%|
  1835|         0|            0|            0|  0.00%|    return sig.replace(parameters=params)
  1836|         0|            0|            0|  0.00%|
  1837|         0|            0|            0|  0.00%|
  1838|         0|            0|            0|  0.00%|def _signature_is_builtin(obj):
  1839|         0|            0|            0|  0.00%|    """Private helper to test if `obj` is a callable that might
  1840|         0|            0|            0|  0.00%|    support Argument Clinic's __text_signature__ protocol.
  1841|         0|            0|            0|  0.00%|    """
  1842|         0|            0|            0|  0.00%|    return (isbuiltin(obj) or
  1843|         0|            0|            0|  0.00%|            ismethoddescriptor(obj) or
  1844|         0|            0|            0|  0.00%|            isinstance(obj, _NonUserDefinedCallables) or
  1845|         0|            0|            0|  0.00%|            # Can't test 'isinstance(type)' here, as it would
  1846|         0|            0|            0|  0.00%|            # also be True for regular python classes
  1847|         0|            0|            0|  0.00%|            obj in (type, object))
  1848|         0|            0|            0|  0.00%|
  1849|         0|            0|            0|  0.00%|
  1850|         0|            0|            0|  0.00%|def _signature_is_functionlike(obj):
  1851|         0|            0|            0|  0.00%|    """Private helper to test if `obj` is a duck type of FunctionType.
  1852|         0|            0|            0|  0.00%|    A good example of such objects are functions compiled with
  1853|         0|            0|            0|  0.00%|    Cython, which have all attributes that a pure Python function
  1854|         0|            0|            0|  0.00%|    would have, but have their code statically compiled.
  1855|         0|            0|            0|  0.00%|    """
  1856|         0|            0|            0|  0.00%|
  1857|         0|            0|            0|  0.00%|    if not callable(obj) or isclass(obj):
  1858|         0|            0|            0|  0.00%|        # All function-like objects are obviously callables,
  1859|         0|            0|            0|  0.00%|        # and not classes.
  1860|         0|            0|            0|  0.00%|        return False
  1861|         0|            0|            0|  0.00%|
  1862|         0|            0|            0|  0.00%|    name = getattr(obj, '__name__', None)
  1863|         0|            0|            0|  0.00%|    code = getattr(obj, '__code__', None)
  1864|         0|            0|            0|  0.00%|    defaults = getattr(obj, '__defaults__', _void) # Important to use _void ...
  1865|         0|            0|            0|  0.00%|    kwdefaults = getattr(obj, '__kwdefaults__', _void) # ... and not None here
  1866|         0|            0|            0|  0.00%|    annotations = getattr(obj, '__annotations__', None)
  1867|         0|            0|            0|  0.00%|
  1868|         0|            0|            0|  0.00%|    return (isinstance(code, types.CodeType) and
  1869|         0|            0|            0|  0.00%|            isinstance(name, str) and
  1870|         0|            0|            0|  0.00%|            (defaults is None or isinstance(defaults, tuple)) and
  1871|         0|            0|            0|  0.00%|            (kwdefaults is None or isinstance(kwdefaults, dict)) and
  1872|         0|            0|            0|  0.00%|            isinstance(annotations, dict))
  1873|         0|            0|            0|  0.00%|
  1874|         0|            0|            0|  0.00%|
  1875|         0|            0|            0|  0.00%|def _signature_get_bound_param(spec):
  1876|         0|            0|            0|  0.00%|    """ Private helper to get first parameter name from a
  1877|         0|            0|            0|  0.00%|    __text_signature__ of a builtin method, which should
  1878|         0|            0|            0|  0.00%|    be in the following format: '($param1, ...)'.
  1879|         0|            0|            0|  0.00%|    Assumptions are that the first argument won't have
  1880|         0|            0|            0|  0.00%|    a default value or an annotation.
  1881|         0|            0|            0|  0.00%|    """
  1882|         0|            0|            0|  0.00%|
  1883|         0|            0|            0|  0.00%|    assert spec.startswith('($')
  1884|         0|            0|            0|  0.00%|
  1885|         0|            0|            0|  0.00%|    pos = spec.find(',')
  1886|         0|            0|            0|  0.00%|    if pos == -1:
  1887|         0|            0|            0|  0.00%|        pos = spec.find(')')
  1888|         0|            0|            0|  0.00%|
  1889|         0|            0|            0|  0.00%|    cpos = spec.find(':')
  1890|         0|            0|            0|  0.00%|    assert cpos == -1 or cpos > pos
  1891|         0|            0|            0|  0.00%|
  1892|         0|            0|            0|  0.00%|    cpos = spec.find('=')
  1893|         0|            0|            0|  0.00%|    assert cpos == -1 or cpos > pos
  1894|         0|            0|            0|  0.00%|
  1895|         0|            0|            0|  0.00%|    return spec[2:pos]
  1896|         0|            0|            0|  0.00%|
  1897|         0|            0|            0|  0.00%|
  1898|         0|            0|            0|  0.00%|def _signature_strip_non_python_syntax(signature):
  1899|         0|            0|            0|  0.00%|    """
  1900|         0|            0|            0|  0.00%|    Private helper function. Takes a signature in Argument Clinic's
  1901|         0|            0|            0|  0.00%|    extended signature format.
  1902|         0|            0|            0|  0.00%|
  1903|         0|            0|            0|  0.00%|    Returns a tuple of three things:
  1904|         0|            0|            0|  0.00%|      * that signature re-rendered in standard Python syntax,
  1905|         0|            0|            0|  0.00%|      * the index of the "self" parameter (generally 0), or None if
  1906|         0|            0|            0|  0.00%|        the function does not have a "self" parameter, and
  1907|         0|            0|            0|  0.00%|      * the index of the last "positional only" parameter,
  1908|         0|            0|            0|  0.00%|        or None if the signature has no positional-only parameters.
  1909|         0|            0|            0|  0.00%|    """
  1910|         0|            0|            0|  0.00%|
  1911|         0|            0|            0|  0.00%|    if not signature:
  1912|         0|            0|            0|  0.00%|        return signature, None, None
  1913|         0|            0|            0|  0.00%|
  1914|         0|            0|            0|  0.00%|    self_parameter = None
  1915|         0|            0|            0|  0.00%|    last_positional_only = None
  1916|         0|            0|            0|  0.00%|
  1917|         0|            0|            0|  0.00%|    lines = [l.encode('ascii') for l in signature.split('\n')]
  1918|         0|            0|            0|  0.00%|    generator = iter(lines).__next__
  1919|         0|            0|            0|  0.00%|    token_stream = tokenize.tokenize(generator)
  1920|         0|            0|            0|  0.00%|
  1921|         0|            0|            0|  0.00%|    delayed_comma = False
  1922|         0|            0|            0|  0.00%|    skip_next_comma = False
  1923|         0|            0|            0|  0.00%|    text = []
  1924|         0|            0|            0|  0.00%|    add = text.append
  1925|         0|            0|            0|  0.00%|
  1926|         0|            0|            0|  0.00%|    current_parameter = 0
  1927|         0|            0|            0|  0.00%|    OP = token.OP
  1928|         0|            0|            0|  0.00%|    ERRORTOKEN = token.ERRORTOKEN
  1929|         0|            0|            0|  0.00%|
  1930|         0|            0|            0|  0.00%|    # token stream always starts with ENCODING token, skip it
  1931|         0|            0|            0|  0.00%|    t = next(token_stream)
  1932|         0|            0|            0|  0.00%|    assert t.type == tokenize.ENCODING
  1933|         0|            0|            0|  0.00%|
  1934|         0|            0|            0|  0.00%|    for t in token_stream:
  1935|         0|            0|            0|  0.00%|        type, string = t.type, t.string
  1936|         0|            0|            0|  0.00%|
  1937|         0|            0|            0|  0.00%|        if type == OP:
  1938|         0|            0|            0|  0.00%|            if string == ',':
  1939|         0|            0|            0|  0.00%|                if skip_next_comma:
  1940|         0|            0|            0|  0.00%|                    skip_next_comma = False
  1941|         0|            0|            0|  0.00%|                else:
  1942|         0|            0|            0|  0.00%|                    assert not delayed_comma
  1943|         0|            0|            0|  0.00%|                    delayed_comma = True
  1944|         0|            0|            0|  0.00%|                    current_parameter += 1
  1945|         0|            0|            0|  0.00%|                continue
  1946|         0|            0|            0|  0.00%|
  1947|         0|            0|            0|  0.00%|            if string == '/':
  1948|         0|            0|            0|  0.00%|                assert not skip_next_comma
  1949|         0|            0|            0|  0.00%|                assert last_positional_only is None
  1950|         0|            0|            0|  0.00%|                skip_next_comma = True
  1951|         0|            0|            0|  0.00%|                last_positional_only = current_parameter - 1
  1952|         0|            0|            0|  0.00%|                continue
  1953|         0|            0|            0|  0.00%|
  1954|         0|            0|            0|  0.00%|        if (type == ERRORTOKEN) and (string == '$'):
  1955|         0|            0|            0|  0.00%|            assert self_parameter is None
  1956|         0|            0|            0|  0.00%|            self_parameter = current_parameter
  1957|         0|            0|            0|  0.00%|            continue
  1958|         0|            0|            0|  0.00%|
  1959|         0|            0|            0|  0.00%|        if delayed_comma:
  1960|         0|            0|            0|  0.00%|            delayed_comma = False
  1961|         0|            0|            0|  0.00%|            if not ((type == OP) and (string == ')')):
  1962|         0|            0|            0|  0.00%|                add(', ')
  1963|         0|            0|            0|  0.00%|        add(string)
  1964|         0|            0|            0|  0.00%|        if (string == ','):
  1965|         0|            0|            0|  0.00%|            add(' ')
  1966|         0|            0|            0|  0.00%|    clean_signature = ''.join(text)
  1967|         0|            0|            0|  0.00%|    return clean_signature, self_parameter, last_positional_only
  1968|         0|            0|            0|  0.00%|
  1969|         0|            0|            0|  0.00%|
  1970|         0|            0|            0|  0.00%|def _signature_fromstr(cls, obj, s, skip_bound_arg=True):
  1971|         0|            0|            0|  0.00%|    """Private helper to parse content of '__text_signature__'
  1972|         0|            0|            0|  0.00%|    and return a Signature based on it.
  1973|         0|            0|            0|  0.00%|    """
  1974|         0|            0|            0|  0.00%|    # Lazy import ast because it's relatively heavy and
  1975|         0|            0|            0|  0.00%|    # it's not used for other than this function.
  1976|         0|            0|            0|  0.00%|    import ast
  1977|         0|            0|            0|  0.00%|
  1978|         0|            0|            0|  0.00%|    Parameter = cls._parameter_cls
  1979|         0|            0|            0|  0.00%|
  1980|         0|            0|            0|  0.00%|    clean_signature, self_parameter, last_positional_only = \
  1981|         0|            0|            0|  0.00%|        _signature_strip_non_python_syntax(s)
  1982|         0|            0|            0|  0.00%|
  1983|         0|            0|            0|  0.00%|    program = "def foo" + clean_signature + ": pass"
  1984|         0|            0|            0|  0.00%|
  1985|         0|            0|            0|  0.00%|    try:
  1986|         0|            0|            0|  0.00%|        module = ast.parse(program)
  1987|         0|            0|            0|  0.00%|    except SyntaxError:
  1988|         0|            0|            0|  0.00%|        module = None
  1989|         0|            0|            0|  0.00%|
  1990|         0|            0|            0|  0.00%|    if not isinstance(module, ast.Module):
  1991|         0|            0|            0|  0.00%|        raise ValueError("{!r} builtin has invalid signature".format(obj))
  1992|         0|            0|            0|  0.00%|
  1993|         0|            0|            0|  0.00%|    f = module.body[0]
  1994|         0|            0|            0|  0.00%|
  1995|         0|            0|            0|  0.00%|    parameters = []
  1996|         0|            0|            0|  0.00%|    empty = Parameter.empty
  1997|         0|            0|            0|  0.00%|    invalid = object()
  1998|         0|            0|            0|  0.00%|
  1999|         0|            0|            0|  0.00%|    module = None
  2000|         0|            0|            0|  0.00%|    module_dict = {}
  2001|         0|            0|            0|  0.00%|    module_name = getattr(obj, '__module__', None)
  2002|         0|            0|            0|  0.00%|    if module_name:
  2003|         0|            0|            0|  0.00%|        module = sys.modules.get(module_name, None)
  2004|         0|            0|            0|  0.00%|        if module:
  2005|         0|            0|            0|  0.00%|            module_dict = module.__dict__
  2006|         0|            0|            0|  0.00%|    sys_module_dict = sys.modules.copy()
  2007|         0|            0|            0|  0.00%|
  2008|         0|            0|            0|  0.00%|    def parse_name(node):
  2009|         0|            0|            0|  0.00%|        assert isinstance(node, ast.arg)
  2010|         0|            0|            0|  0.00%|        if node.annotation is not None:
  2011|         0|            0|            0|  0.00%|            raise ValueError("Annotations are not currently supported")
  2012|         0|            0|            0|  0.00%|        return node.arg
  2013|         0|            0|            0|  0.00%|
  2014|         0|            0|            0|  0.00%|    def wrap_value(s):
  2015|         0|            0|            0|  0.00%|        try:
  2016|         0|            0|            0|  0.00%|            value = eval(s, module_dict)
  2017|         0|            0|            0|  0.00%|        except NameError:
  2018|         0|            0|            0|  0.00%|            try:
  2019|         0|            0|            0|  0.00%|                value = eval(s, sys_module_dict)
  2020|         0|            0|            0|  0.00%|            except NameError:
  2021|         0|            0|            0|  0.00%|                raise RuntimeError()
  2022|         0|            0|            0|  0.00%|
  2023|         0|            0|            0|  0.00%|        if isinstance(value, (str, int, float, bytes, bool, type(None))):
  2024|         0|            0|            0|  0.00%|            return ast.Constant(value)
  2025|         0|            0|            0|  0.00%|        raise RuntimeError()
  2026|         0|            0|            0|  0.00%|
  2027|         0|            0|            0|  0.00%|    class RewriteSymbolics(ast.NodeTransformer):
  2028|         0|            0|            0|  0.00%|        def visit_Attribute(self, node):
  2029|         0|            0|            0|  0.00%|            a = []
  2030|         0|            0|            0|  0.00%|            n = node
  2031|         0|            0|            0|  0.00%|            while isinstance(n, ast.Attribute):
  2032|         0|            0|            0|  0.00%|                a.append(n.attr)
  2033|         0|            0|            0|  0.00%|                n = n.value
  2034|         0|            0|            0|  0.00%|            if not isinstance(n, ast.Name):
  2035|         0|            0|            0|  0.00%|                raise RuntimeError()
  2036|         0|            0|            0|  0.00%|            a.append(n.id)
  2037|         0|            0|            0|  0.00%|            value = ".".join(reversed(a))
  2038|         0|            0|            0|  0.00%|            return wrap_value(value)
  2039|         0|            0|            0|  0.00%|
  2040|         0|            0|            0|  0.00%|        def visit_Name(self, node):
  2041|         0|            0|            0|  0.00%|            if not isinstance(node.ctx, ast.Load):
  2042|         0|            0|            0|  0.00%|                raise ValueError()
  2043|         0|            0|            0|  0.00%|            return wrap_value(node.id)
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|    def p(name_node, default_node, default=empty):
  2046|         0|            0|            0|  0.00%|        name = parse_name(name_node)
  2047|         0|            0|            0|  0.00%|        if name is invalid:
  2048|         0|            0|            0|  0.00%|            return None
  2049|         0|            0|            0|  0.00%|        if default_node and default_node is not _empty:
  2050|         0|            0|            0|  0.00%|            try:
  2051|         0|            0|            0|  0.00%|                default_node = RewriteSymbolics().visit(default_node)
  2052|         0|            0|            0|  0.00%|                o = ast.literal_eval(default_node)
  2053|         0|            0|            0|  0.00%|            except ValueError:
  2054|         0|            0|            0|  0.00%|                o = invalid
  2055|         0|            0|            0|  0.00%|            if o is invalid:
  2056|         0|            0|            0|  0.00%|                return None
  2057|         0|            0|            0|  0.00%|            default = o if o is not invalid else default
  2058|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, kind, default=default, annotation=empty))
  2059|         0|            0|            0|  0.00%|
  2060|         0|            0|            0|  0.00%|    # non-keyword-only parameters
  2061|         0|            0|            0|  0.00%|    args = reversed(f.args.args)
  2062|         0|            0|            0|  0.00%|    defaults = reversed(f.args.defaults)
  2063|         0|            0|            0|  0.00%|    iter = itertools.zip_longest(args, defaults, fillvalue=None)
  2064|         0|            0|            0|  0.00%|    if last_positional_only is not None:
  2065|         0|            0|            0|  0.00%|        kind = Parameter.POSITIONAL_ONLY
  2066|         0|            0|            0|  0.00%|    else:
  2067|         0|            0|            0|  0.00%|        kind = Parameter.POSITIONAL_OR_KEYWORD
  2068|         0|            0|            0|  0.00%|    for i, (name, default) in enumerate(reversed(list(iter))):
  2069|         0|            0|            0|  0.00%|        p(name, default)
  2070|         0|            0|            0|  0.00%|        if i == last_positional_only:
  2071|         0|            0|            0|  0.00%|            kind = Parameter.POSITIONAL_OR_KEYWORD
  2072|         0|            0|            0|  0.00%|
  2073|         0|            0|            0|  0.00%|    # *args
  2074|         0|            0|            0|  0.00%|    if f.args.vararg:
  2075|         0|            0|            0|  0.00%|        kind = Parameter.VAR_POSITIONAL
  2076|         0|            0|            0|  0.00%|        p(f.args.vararg, empty)
  2077|         0|            0|            0|  0.00%|
  2078|         0|            0|            0|  0.00%|    # keyword-only arguments
  2079|         0|            0|            0|  0.00%|    kind = Parameter.KEYWORD_ONLY
  2080|         0|            0|            0|  0.00%|    for name, default in zip(f.args.kwonlyargs, f.args.kw_defaults):
  2081|         0|            0|            0|  0.00%|        p(name, default)
  2082|         0|            0|            0|  0.00%|
  2083|         0|            0|            0|  0.00%|    # **kwargs
  2084|         0|            0|            0|  0.00%|    if f.args.kwarg:
  2085|         0|            0|            0|  0.00%|        kind = Parameter.VAR_KEYWORD
  2086|         0|            0|            0|  0.00%|        p(f.args.kwarg, empty)
  2087|         0|            0|            0|  0.00%|
  2088|         0|            0|            0|  0.00%|    if self_parameter is not None:
  2089|         0|            0|            0|  0.00%|        # Possibly strip the bound argument:
  2090|         0|            0|            0|  0.00%|        #    - We *always* strip first bound argument if
  2091|         0|            0|            0|  0.00%|        #      it is a module.
  2092|         0|            0|            0|  0.00%|        #    - We don't strip first bound argument if
  2093|         0|            0|            0|  0.00%|        #      skip_bound_arg is False.
  2094|         0|            0|            0|  0.00%|        assert parameters
  2095|         0|            0|            0|  0.00%|        _self = getattr(obj, '__self__', None)
  2096|         0|            0|            0|  0.00%|        self_isbound = _self is not None
  2097|         0|            0|            0|  0.00%|        self_ismodule = ismodule(_self)
  2098|         0|            0|            0|  0.00%|        if self_isbound and (self_ismodule or skip_bound_arg):
  2099|         0|            0|            0|  0.00%|            parameters.pop(0)
  2100|         0|            0|            0|  0.00%|        else:
  2101|         0|            0|            0|  0.00%|            # for builtins, self parameter is always positional-only!
  2102|         0|            0|            0|  0.00%|            p = parameters[0].replace(kind=Parameter.POSITIONAL_ONLY)
  2103|         0|            0|            0|  0.00%|            parameters[0] = p
  2104|         0|            0|            0|  0.00%|
  2105|         0|            0|            0|  0.00%|    return cls(parameters, return_annotation=cls.empty)
  2106|         0|            0|            0|  0.00%|
  2107|         0|            0|            0|  0.00%|
  2108|         0|            0|            0|  0.00%|def _signature_from_builtin(cls, func, skip_bound_arg=True):
  2109|         0|            0|            0|  0.00%|    """Private helper function to get signature for
  2110|         0|            0|            0|  0.00%|    builtin callables.
  2111|         0|            0|            0|  0.00%|    """
  2112|         0|            0|            0|  0.00%|
  2113|         0|            0|            0|  0.00%|    if not _signature_is_builtin(func):
  2114|         0|            0|            0|  0.00%|        raise TypeError("{!r} is not a Python builtin "
  2115|         0|            0|            0|  0.00%|                        "function".format(func))
  2116|         0|            0|            0|  0.00%|
  2117|         0|            0|            0|  0.00%|    s = getattr(func, "__text_signature__", None)
  2118|         0|            0|            0|  0.00%|    if not s:
  2119|         0|            0|            0|  0.00%|        raise ValueError("no signature found for builtin {!r}".format(func))
  2120|         0|            0|            0|  0.00%|
  2121|         0|            0|            0|  0.00%|    return _signature_fromstr(cls, func, s, skip_bound_arg)
  2122|         0|            0|            0|  0.00%|
  2123|         0|            0|            0|  0.00%|
  2124|         0|            0|            0|  0.00%|def _signature_from_function(cls, func, skip_bound_arg=True):
  2125|         0|            0|            0|  0.00%|    """Private helper: constructs Signature for the given python function."""
  2126|         0|            0|            0|  0.00%|
  2127|         0|            0|            0|  0.00%|    is_duck_function = False
  2128|         0|            0|            0|  0.00%|    if not isfunction(func):
  2129|         0|            0|            0|  0.00%|        if _signature_is_functionlike(func):
  2130|         0|            0|            0|  0.00%|            is_duck_function = True
  2131|         0|            0|            0|  0.00%|        else:
  2132|         0|            0|            0|  0.00%|            # If it's not a pure Python function, and not a duck type
  2133|         0|            0|            0|  0.00%|            # of pure function:
  2134|         0|            0|            0|  0.00%|            raise TypeError('{!r} is not a Python function'.format(func))
  2135|         0|            0|            0|  0.00%|
  2136|         0|            0|            0|  0.00%|    s = getattr(func, "__text_signature__", None)
  2137|         0|            0|            0|  0.00%|    if s:
  2138|         0|            0|            0|  0.00%|        return _signature_fromstr(cls, func, s, skip_bound_arg)
  2139|         0|            0|            0|  0.00%|
  2140|         0|            0|            0|  0.00%|    Parameter = cls._parameter_cls
  2141|         0|            0|            0|  0.00%|
  2142|         0|            0|            0|  0.00%|    # Parameter information.
  2143|         0|            0|            0|  0.00%|    func_code = func.__code__
  2144|         0|            0|            0|  0.00%|    pos_count = func_code.co_argcount
  2145|         0|            0|            0|  0.00%|    arg_names = func_code.co_varnames
  2146|         0|            0|            0|  0.00%|    posonly_count = func_code.co_posonlyargcount
  2147|         0|            0|            0|  0.00%|    positional = arg_names[:pos_count]
  2148|         0|            0|            0|  0.00%|    keyword_only_count = func_code.co_kwonlyargcount
  2149|         0|            0|            0|  0.00%|    keyword_only = arg_names[pos_count:pos_count + keyword_only_count]
  2150|         0|            0|            0|  0.00%|    annotations = func.__annotations__
  2151|         0|            0|            0|  0.00%|    defaults = func.__defaults__
  2152|         0|            0|            0|  0.00%|    kwdefaults = func.__kwdefaults__
  2153|         0|            0|            0|  0.00%|
  2154|         0|            0|            0|  0.00%|    if defaults:
  2155|         0|            0|            0|  0.00%|        pos_default_count = len(defaults)
  2156|         0|            0|            0|  0.00%|    else:
  2157|         0|            0|            0|  0.00%|        pos_default_count = 0
  2158|         0|            0|            0|  0.00%|
  2159|         0|            0|            0|  0.00%|    parameters = []
  2160|         0|            0|            0|  0.00%|
  2161|         0|            0|            0|  0.00%|    non_default_count = pos_count - pos_default_count
  2162|         0|            0|            0|  0.00%|    posonly_left = posonly_count
  2163|         0|            0|            0|  0.00%|
  2164|         0|            0|            0|  0.00%|    # Non-keyword-only parameters w/o defaults.
  2165|         0|            0|            0|  0.00%|    for name in positional[:non_default_count]:
  2166|         0|            0|            0|  0.00%|        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD
  2167|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2168|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2169|         0|            0|            0|  0.00%|                                    kind=kind))
  2170|         0|            0|            0|  0.00%|        if posonly_left:
  2171|         0|            0|            0|  0.00%|            posonly_left -= 1
  2172|         0|            0|            0|  0.00%|
  2173|         0|            0|            0|  0.00%|    # ... w/ defaults.
  2174|         0|            0|            0|  0.00%|    for offset, name in enumerate(positional[non_default_count:]):
  2175|         0|            0|            0|  0.00%|        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD
  2176|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2177|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2178|         0|            0|            0|  0.00%|                                    kind=kind,
  2179|         0|            0|            0|  0.00%|                                    default=defaults[offset]))
  2180|         0|            0|            0|  0.00%|        if posonly_left:
  2181|         0|            0|            0|  0.00%|            posonly_left -= 1
  2182|         0|            0|            0|  0.00%|
  2183|         0|            0|            0|  0.00%|    # *args
  2184|         0|            0|            0|  0.00%|    if func_code.co_flags & CO_VARARGS:
  2185|         0|            0|            0|  0.00%|        name = arg_names[pos_count + keyword_only_count]
  2186|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2187|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2188|         0|            0|            0|  0.00%|                                    kind=_VAR_POSITIONAL))
  2189|         0|            0|            0|  0.00%|
  2190|         0|            0|            0|  0.00%|    # Keyword-only parameters.
  2191|         0|            0|            0|  0.00%|    for name in keyword_only:
  2192|         0|            0|            0|  0.00%|        default = _empty
  2193|         0|            0|            0|  0.00%|        if kwdefaults is not None:
  2194|         0|            0|            0|  0.00%|            default = kwdefaults.get(name, _empty)
  2195|         0|            0|            0|  0.00%|
  2196|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2197|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2198|         0|            0|            0|  0.00%|                                    kind=_KEYWORD_ONLY,
  2199|         0|            0|            0|  0.00%|                                    default=default))
  2200|         0|            0|            0|  0.00%|    # **kwargs
  2201|         0|            0|            0|  0.00%|    if func_code.co_flags & CO_VARKEYWORDS:
  2202|         0|            0|            0|  0.00%|        index = pos_count + keyword_only_count
  2203|         0|            0|            0|  0.00%|        if func_code.co_flags & CO_VARARGS:
  2204|         0|            0|            0|  0.00%|            index += 1
  2205|         0|            0|            0|  0.00%|
  2206|         0|            0|            0|  0.00%|        name = arg_names[index]
  2207|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2208|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2209|         0|            0|            0|  0.00%|                                    kind=_VAR_KEYWORD))
  2210|         0|            0|            0|  0.00%|
  2211|         0|            0|            0|  0.00%|    # Is 'func' is a pure Python function - don't validate the
  2212|         0|            0|            0|  0.00%|    # parameters list (for correct order and defaults), it should be OK.
  2213|         0|            0|            0|  0.00%|    return cls(parameters,
  2214|         0|            0|            0|  0.00%|               return_annotation=annotations.get('return', _empty),
  2215|         0|            0|            0|  0.00%|               __validate_parameters__=is_duck_function)
  2216|         0|            0|            0|  0.00%|
  2217|         0|            0|            0|  0.00%|
  2218|         0|            0|            0|  0.00%|def _signature_from_callable(obj, *,
  2219|         0|            0|            0|  0.00%|                             follow_wrapper_chains=True,
  2220|         0|            0|            0|  0.00%|                             skip_bound_arg=True,
  2221|         0|            0|            0|  0.00%|                             sigcls):
  2222|         0|            0|            0|  0.00%|
  2223|         0|            0|            0|  0.00%|    """Private helper function to get signature for arbitrary
  2224|         0|            0|            0|  0.00%|    callable objects.
  2225|         0|            0|            0|  0.00%|    """
  2226|         0|            0|            0|  0.00%|
  2227|         0|            0|            0|  0.00%|    if not callable(obj):
  2228|         0|            0|            0|  0.00%|        raise TypeError('{!r} is not a callable object'.format(obj))
  2229|         0|            0|            0|  0.00%|
  2230|         0|            0|            0|  0.00%|    if isinstance(obj, types.MethodType):
  2231|         0|            0|            0|  0.00%|        # In this case we skip the first parameter of the underlying
  2232|         0|            0|            0|  0.00%|        # function (usually `self` or `cls`).
  2233|         0|            0|            0|  0.00%|        sig = _signature_from_callable(
  2234|         0|            0|            0|  0.00%|            obj.__func__,
  2235|         0|            0|            0|  0.00%|            follow_wrapper_chains=follow_wrapper_chains,
  2236|         0|            0|            0|  0.00%|            skip_bound_arg=skip_bound_arg,
  2237|         0|            0|            0|  0.00%|            sigcls=sigcls)
  2238|         0|            0|            0|  0.00%|
  2239|         0|            0|            0|  0.00%|        if skip_bound_arg:
  2240|         0|            0|            0|  0.00%|            return _signature_bound_method(sig)
  2241|         0|            0|            0|  0.00%|        else:
  2242|         0|            0|            0|  0.00%|            return sig
  2243|         0|            0|            0|  0.00%|
  2244|         0|            0|            0|  0.00%|    # Was this function wrapped by a decorator?
  2245|         0|            0|            0|  0.00%|    if follow_wrapper_chains:
  2246|         0|            0|            0|  0.00%|        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")))
  2247|         0|            0|            0|  0.00%|        if isinstance(obj, types.MethodType):
  2248|         0|            0|            0|  0.00%|            # If the unwrapped object is a *method*, we might want to
  2249|         0|            0|            0|  0.00%|            # skip its first parameter (self).
  2250|         0|            0|            0|  0.00%|            # See test_signature_wrapped_bound_method for details.
  2251|         0|            0|            0|  0.00%|            return _signature_from_callable(
  2252|         0|            0|            0|  0.00%|                obj,
  2253|         0|            0|            0|  0.00%|                follow_wrapper_chains=follow_wrapper_chains,
  2254|         0|            0|            0|  0.00%|                skip_bound_arg=skip_bound_arg,
  2255|         0|            0|            0|  0.00%|                sigcls=sigcls)
  2256|         0|            0|            0|  0.00%|
  2257|         0|            0|            0|  0.00%|    try:
  2258|         0|            0|            0|  0.00%|        sig = obj.__signature__
  2259|         0|            0|            0|  0.00%|    except AttributeError:
  2260|         0|            0|            0|  0.00%|        pass
  2261|         0|            0|            0|  0.00%|    else:
  2262|         0|            0|            0|  0.00%|        if sig is not None:
  2263|         0|            0|            0|  0.00%|            if not isinstance(sig, Signature):
  2264|         0|            0|            0|  0.00%|                raise TypeError(
  2265|         0|            0|            0|  0.00%|                    'unexpected object {!r} in __signature__ '
  2266|         0|            0|            0|  0.00%|                    'attribute'.format(sig))
  2267|         0|            0|            0|  0.00%|            return sig
  2268|         0|            0|            0|  0.00%|
  2269|         0|            0|            0|  0.00%|    try:
  2270|         0|            0|            0|  0.00%|        partialmethod = obj._partialmethod
  2271|         0|            0|            0|  0.00%|    except AttributeError:
  2272|         0|            0|            0|  0.00%|        pass
  2273|         0|            0|            0|  0.00%|    else:
  2274|         0|            0|            0|  0.00%|        if isinstance(partialmethod, functools.partialmethod):
  2275|         0|            0|            0|  0.00%|            # Unbound partialmethod (see functools.partialmethod)
  2276|         0|            0|            0|  0.00%|            # This means, that we need to calculate the signature
  2277|         0|            0|            0|  0.00%|            # as if it's a regular partial object, but taking into
  2278|         0|            0|            0|  0.00%|            # account that the first positional argument
  2279|         0|            0|            0|  0.00%|            # (usually `self`, or `cls`) will not be passed
  2280|         0|            0|            0|  0.00%|            # automatically (as for boundmethods)
  2281|         0|            0|            0|  0.00%|
  2282|         0|            0|            0|  0.00%|            wrapped_sig = _signature_from_callable(
  2283|         0|            0|            0|  0.00%|                partialmethod.func,
  2284|         0|            0|            0|  0.00%|                follow_wrapper_chains=follow_wrapper_chains,
  2285|         0|            0|            0|  0.00%|                skip_bound_arg=skip_bound_arg,
  2286|         0|            0|            0|  0.00%|                sigcls=sigcls)
  2287|         0|            0|            0|  0.00%|
  2288|         0|            0|            0|  0.00%|            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))
  2289|         0|            0|            0|  0.00%|            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]
  2290|         0|            0|            0|  0.00%|            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:
  2291|         0|            0|            0|  0.00%|                # First argument of the wrapped callable is `*args`, as in
  2292|         0|            0|            0|  0.00%|                # `partialmethod(lambda *args)`.
  2293|         0|            0|            0|  0.00%|                return sig
  2294|         0|            0|            0|  0.00%|            else:
  2295|         0|            0|            0|  0.00%|                sig_params = tuple(sig.parameters.values())
  2296|         0|            0|            0|  0.00%|                assert (not sig_params or
  2297|         0|            0|            0|  0.00%|                        first_wrapped_param is not sig_params[0])
  2298|         0|            0|            0|  0.00%|                new_params = (first_wrapped_param,) + sig_params
  2299|         0|            0|            0|  0.00%|                return sig.replace(parameters=new_params)
  2300|         0|            0|            0|  0.00%|
  2301|         0|            0|            0|  0.00%|    if isfunction(obj) or _signature_is_functionlike(obj):
  2302|         0|            0|            0|  0.00%|        # If it's a pure Python function, or an object that is duck type
  2303|         0|            0|            0|  0.00%|        # of a Python function (Cython functions, for instance), then:
  2304|         0|            0|            0|  0.00%|        return _signature_from_function(sigcls, obj,
  2305|         0|            0|            0|  0.00%|                                        skip_bound_arg=skip_bound_arg)
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|    if _signature_is_builtin(obj):
  2308|         0|            0|            0|  0.00%|        return _signature_from_builtin(sigcls, obj,
  2309|         0|            0|            0|  0.00%|                                       skip_bound_arg=skip_bound_arg)
  2310|         0|            0|            0|  0.00%|
  2311|         0|            0|            0|  0.00%|    if isinstance(obj, functools.partial):
  2312|         0|            0|            0|  0.00%|        wrapped_sig = _signature_from_callable(
  2313|         0|            0|            0|  0.00%|            obj.func,
  2314|         0|            0|            0|  0.00%|            follow_wrapper_chains=follow_wrapper_chains,
  2315|         0|            0|            0|  0.00%|            skip_bound_arg=skip_bound_arg,
  2316|         0|            0|            0|  0.00%|            sigcls=sigcls)
  2317|         0|            0|            0|  0.00%|        return _signature_get_partial(wrapped_sig, obj)
  2318|         0|            0|            0|  0.00%|
  2319|         0|            0|            0|  0.00%|    sig = None
  2320|         0|            0|            0|  0.00%|    if isinstance(obj, type):
  2321|         0|            0|            0|  0.00%|        # obj is a class or a metaclass
  2322|         0|            0|            0|  0.00%|
  2323|         0|            0|            0|  0.00%|        # First, let's see if it has an overloaded __call__ defined
  2324|         0|            0|            0|  0.00%|        # in its metaclass
  2325|         0|            0|            0|  0.00%|        call = _signature_get_user_defined_method(type(obj), '__call__')
  2326|         0|            0|            0|  0.00%|        if call is not None:
  2327|         0|            0|            0|  0.00%|            sig = _signature_from_callable(
  2328|         0|            0|            0|  0.00%|                call,
  2329|         0|            0|            0|  0.00%|                follow_wrapper_chains=follow_wrapper_chains,
  2330|         0|            0|            0|  0.00%|                skip_bound_arg=skip_bound_arg,
  2331|         0|            0|            0|  0.00%|                sigcls=sigcls)
  2332|         0|            0|            0|  0.00%|        else:
  2333|         0|            0|            0|  0.00%|            # Now we check if the 'obj' class has a '__new__' method
  2334|         0|            0|            0|  0.00%|            new = _signature_get_user_defined_method(obj, '__new__')
  2335|         0|            0|            0|  0.00%|            if new is not None:
  2336|         0|            0|            0|  0.00%|                sig = _signature_from_callable(
  2337|         0|            0|            0|  0.00%|                    new,
  2338|         0|            0|            0|  0.00%|                    follow_wrapper_chains=follow_wrapper_chains,
  2339|         0|            0|            0|  0.00%|                    skip_bound_arg=skip_bound_arg,
  2340|         0|            0|            0|  0.00%|                    sigcls=sigcls)
  2341|         0|            0|            0|  0.00%|            else:
  2342|         0|            0|            0|  0.00%|                # Finally, we should have at least __init__ implemented
  2343|         0|            0|            0|  0.00%|                init = _signature_get_user_defined_method(obj, '__init__')
  2344|         0|            0|            0|  0.00%|                if init is not None:
  2345|         0|            0|            0|  0.00%|                    sig = _signature_from_callable(
  2346|         0|            0|            0|  0.00%|                        init,
  2347|         0|            0|            0|  0.00%|                        follow_wrapper_chains=follow_wrapper_chains,
  2348|         0|            0|            0|  0.00%|                        skip_bound_arg=skip_bound_arg,
  2349|         0|            0|            0|  0.00%|                        sigcls=sigcls)
  2350|         0|            0|            0|  0.00%|
  2351|         0|            0|            0|  0.00%|        if sig is None:
  2352|         0|            0|            0|  0.00%|            # At this point we know, that `obj` is a class, with no user-
  2353|         0|            0|            0|  0.00%|            # defined '__init__', '__new__', or class-level '__call__'
  2354|         0|            0|            0|  0.00%|
  2355|         0|            0|            0|  0.00%|            for base in obj.__mro__[:-1]:
  2356|         0|            0|            0|  0.00%|                # Since '__text_signature__' is implemented as a
  2357|         0|            0|            0|  0.00%|                # descriptor that extracts text signature from the
  2358|         0|            0|            0|  0.00%|                # class docstring, if 'obj' is derived from a builtin
  2359|         0|            0|            0|  0.00%|                # class, its own '__text_signature__' may be 'None'.
  2360|         0|            0|            0|  0.00%|                # Therefore, we go through the MRO (except the last
  2361|         0|            0|            0|  0.00%|                # class in there, which is 'object') to find the first
  2362|         0|            0|            0|  0.00%|                # class with non-empty text signature.
  2363|         0|            0|            0|  0.00%|                try:
  2364|         0|            0|            0|  0.00%|                    text_sig = base.__text_signature__
  2365|         0|            0|            0|  0.00%|                except AttributeError:
  2366|         0|            0|            0|  0.00%|                    pass
  2367|         0|            0|            0|  0.00%|                else:
  2368|         0|            0|            0|  0.00%|                    if text_sig:
  2369|         0|            0|            0|  0.00%|                        # If 'obj' class has a __text_signature__ attribute:
  2370|         0|            0|            0|  0.00%|                        # return a signature based on it
  2371|         0|            0|            0|  0.00%|                        return _signature_fromstr(sigcls, obj, text_sig)
  2372|         0|            0|            0|  0.00%|
  2373|         0|            0|            0|  0.00%|            # No '__text_signature__' was found for the 'obj' class.
  2374|         0|            0|            0|  0.00%|            # Last option is to check if its '__init__' is
  2375|         0|            0|            0|  0.00%|            # object.__init__ or type.__init__.
  2376|         0|            0|            0|  0.00%|            if type not in obj.__mro__:
  2377|         0|            0|            0|  0.00%|                # We have a class (not metaclass), but no user-defined
  2378|         0|            0|            0|  0.00%|                # __init__ or __new__ for it
  2379|         0|            0|            0|  0.00%|                if (obj.__init__ is object.__init__ and
  2380|         0|            0|            0|  0.00%|                    obj.__new__ is object.__new__):
  2381|         0|            0|            0|  0.00%|                    # Return a signature of 'object' builtin.
  2382|         0|            0|            0|  0.00%|                    return sigcls.from_callable(object)
  2383|         0|            0|            0|  0.00%|                else:
  2384|         0|            0|            0|  0.00%|                    raise ValueError(
  2385|         0|            0|            0|  0.00%|                        'no signature found for builtin type {!r}'.format(obj))
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|    elif not isinstance(obj, _NonUserDefinedCallables):
  2388|         0|            0|            0|  0.00%|        # An object with __call__
  2389|         0|            0|            0|  0.00%|        # We also check that the 'obj' is not an instance of
  2390|         0|            0|            0|  0.00%|        # _WrapperDescriptor or _MethodWrapper to avoid
  2391|         0|            0|            0|  0.00%|        # infinite recursion (and even potential segfault)
  2392|         0|            0|            0|  0.00%|        call = _signature_get_user_defined_method(type(obj), '__call__')
  2393|         0|            0|            0|  0.00%|        if call is not None:
  2394|         0|            0|            0|  0.00%|            try:
  2395|         0|            0|            0|  0.00%|                sig = _signature_from_callable(
  2396|         0|            0|            0|  0.00%|                    call,
  2397|         0|            0|            0|  0.00%|                    follow_wrapper_chains=follow_wrapper_chains,
  2398|         0|            0|            0|  0.00%|                    skip_bound_arg=skip_bound_arg,
  2399|         0|            0|            0|  0.00%|                    sigcls=sigcls)
  2400|         0|            0|            0|  0.00%|            except ValueError as ex:
  2401|         0|            0|            0|  0.00%|                msg = 'no signature found for {!r}'.format(obj)
  2402|         0|            0|            0|  0.00%|                raise ValueError(msg) from ex
  2403|         0|            0|            0|  0.00%|
  2404|         0|            0|            0|  0.00%|    if sig is not None:
  2405|         0|            0|            0|  0.00%|        # For classes and objects we skip the first parameter of their
  2406|         0|            0|            0|  0.00%|        # __call__, __new__, or __init__ methods
  2407|         0|            0|            0|  0.00%|        if skip_bound_arg:
  2408|         0|            0|            0|  0.00%|            return _signature_bound_method(sig)
  2409|         0|            0|            0|  0.00%|        else:
  2410|         0|            0|            0|  0.00%|            return sig
  2411|         0|            0|            0|  0.00%|
  2412|         0|            0|            0|  0.00%|    if isinstance(obj, types.BuiltinFunctionType):
  2413|         0|            0|            0|  0.00%|        # Raise a nicer error message for builtins
  2414|         0|            0|            0|  0.00%|        msg = 'no signature found for builtin function {!r}'.format(obj)
  2415|         0|            0|            0|  0.00%|        raise ValueError(msg)
  2416|         0|            0|            0|  0.00%|
  2417|         0|            0|            0|  0.00%|    raise ValueError('callable {!r} is not supported by signature'.format(obj))
  2418|         0|            0|            0|  0.00%|
  2419|         0|            0|            0|  0.00%|
  2420|         0|            0|            0|  0.00%|class _void:
  2421|         0|            0|            0|  0.00%|    """A private marker - used in Parameter & Signature."""
  2422|         0|            0|            0|  0.00%|
  2423|         0|            0|            0|  0.00%|
  2424|         0|            0|            0|  0.00%|class _empty:
  2425|         0|            0|            0|  0.00%|    """Marker object for Signature.empty and Parameter.empty."""
  2426|         0|            0|            0|  0.00%|
  2427|         0|            0|            0|  0.00%|
  2428|         0|            0|            0|  0.00%|class _ParameterKind(enum.IntEnum):
  2429|         0|            0|            0|  0.00%|    POSITIONAL_ONLY = 0
  2430|         0|            0|            0|  0.00%|    POSITIONAL_OR_KEYWORD = 1
  2431|         0|            0|            0|  0.00%|    VAR_POSITIONAL = 2
  2432|         0|            0|            0|  0.00%|    KEYWORD_ONLY = 3
  2433|         0|            0|            0|  0.00%|    VAR_KEYWORD = 4
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|    def __str__(self):
  2436|         0|            0|            0|  0.00%|        return self._name_
  2437|         0|            0|            0|  0.00%|
  2438|         0|            0|            0|  0.00%|    @property
  2439|         0|            0|            0|  0.00%|    def description(self):
  2440|         0|            0|            0|  0.00%|        return _PARAM_NAME_MAPPING[self]
  2441|         0|            0|            0|  0.00%|
  2442|         0|            0|            0|  0.00%|_POSITIONAL_ONLY         = _ParameterKind.POSITIONAL_ONLY
  2443|         0|            0|            0|  0.00%|_POSITIONAL_OR_KEYWORD   = _ParameterKind.POSITIONAL_OR_KEYWORD
  2444|         0|            0|            0|  0.00%|_VAR_POSITIONAL          = _ParameterKind.VAR_POSITIONAL
  2445|         0|            0|            0|  0.00%|_KEYWORD_ONLY            = _ParameterKind.KEYWORD_ONLY
  2446|         0|            0|            0|  0.00%|_VAR_KEYWORD             = _ParameterKind.VAR_KEYWORD
  2447|         0|            0|            0|  0.00%|
  2448|         0|            0|            0|  0.00%|_PARAM_NAME_MAPPING = {
  2449|         0|            0|            0|  0.00%|    _POSITIONAL_ONLY: 'positional-only',
  2450|         0|            0|            0|  0.00%|    _POSITIONAL_OR_KEYWORD: 'positional or keyword',
  2451|         0|            0|            0|  0.00%|    _VAR_POSITIONAL: 'variadic positional',
  2452|         0|            0|            0|  0.00%|    _KEYWORD_ONLY: 'keyword-only',
  2453|         0|            0|            0|  0.00%|    _VAR_KEYWORD: 'variadic keyword'
  2454|         0|            0|            0|  0.00%|}
  2455|         0|            0|            0|  0.00%|
  2456|         0|            0|            0|  0.00%|
  2457|         0|            0|            0|  0.00%|class Parameter:
  2458|         0|            0|            0|  0.00%|    """Represents a parameter in a function signature.
  2459|         0|            0|            0|  0.00%|
  2460|         0|            0|            0|  0.00%|    Has the following public attributes:
  2461|         0|            0|            0|  0.00%|
  2462|         0|            0|            0|  0.00%|    * name : str
  2463|         0|            0|            0|  0.00%|        The name of the parameter as a string.
  2464|         0|            0|            0|  0.00%|    * default : object
  2465|         0|            0|            0|  0.00%|        The default value for the parameter if specified.  If the
  2466|         0|            0|            0|  0.00%|        parameter has no default value, this attribute is set to
  2467|         0|            0|            0|  0.00%|        `Parameter.empty`.
  2468|         0|            0|            0|  0.00%|    * annotation
  2469|         0|            0|            0|  0.00%|        The annotation for the parameter if specified.  If the
  2470|         0|            0|            0|  0.00%|        parameter has no annotation, this attribute is set to
  2471|         0|            0|            0|  0.00%|        `Parameter.empty`.
  2472|         0|            0|            0|  0.00%|    * kind : str
  2473|         0|            0|            0|  0.00%|        Describes how argument values are bound to the parameter.
  2474|         0|            0|            0|  0.00%|        Possible values: `Parameter.POSITIONAL_ONLY`,
  2475|         0|            0|            0|  0.00%|        `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,
  2476|         0|            0|            0|  0.00%|        `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.
  2477|         0|            0|            0|  0.00%|    """
  2478|         0|            0|            0|  0.00%|
  2479|         0|            0|            0|  0.00%|    __slots__ = ('_name', '_kind', '_default', '_annotation')
  2480|         0|            0|            0|  0.00%|
  2481|         0|            0|            0|  0.00%|    POSITIONAL_ONLY         = _POSITIONAL_ONLY
  2482|         0|            0|            0|  0.00%|    POSITIONAL_OR_KEYWORD   = _POSITIONAL_OR_KEYWORD
  2483|         0|            0|            0|  0.00%|    VAR_POSITIONAL          = _VAR_POSITIONAL
  2484|         0|            0|            0|  0.00%|    KEYWORD_ONLY            = _KEYWORD_ONLY
  2485|         0|            0|            0|  0.00%|    VAR_KEYWORD             = _VAR_KEYWORD
  2486|         0|            0|            0|  0.00%|
  2487|         0|            0|            0|  0.00%|    empty = _empty
  2488|         0|            0|            0|  0.00%|
  2489|         0|            0|            0|  0.00%|    def __init__(self, name, kind, *, default=_empty, annotation=_empty):
  2490|         0|            0|            0|  0.00%|        try:
  2491|         0|            0|            0|  0.00%|            self._kind = _ParameterKind(kind)
  2492|         0|            0|            0|  0.00%|        except ValueError:
  2493|         0|            0|            0|  0.00%|            raise ValueError(f'value {kind!r} is not a valid Parameter.kind')
  2494|         0|            0|            0|  0.00%|        if default is not _empty:
  2495|         0|            0|            0|  0.00%|            if self._kind in (_VAR_POSITIONAL, _VAR_KEYWORD):
  2496|         0|            0|            0|  0.00%|                msg = '{} parameters cannot have default values'
  2497|         0|            0|            0|  0.00%|                msg = msg.format(self._kind.description)
  2498|         0|            0|            0|  0.00%|                raise ValueError(msg)
  2499|         0|            0|            0|  0.00%|        self._default = default
  2500|         0|            0|            0|  0.00%|        self._annotation = annotation
  2501|         0|            0|            0|  0.00%|
  2502|         0|            0|            0|  0.00%|        if name is _empty:
  2503|         0|            0|            0|  0.00%|            raise ValueError('name is a required attribute for Parameter')
  2504|         0|            0|            0|  0.00%|
  2505|         0|            0|            0|  0.00%|        if not isinstance(name, str):
  2506|         0|            0|            0|  0.00%|            msg = 'name must be a str, not a {}'.format(type(name).__name__)
  2507|         0|            0|            0|  0.00%|            raise TypeError(msg)
  2508|         0|            0|            0|  0.00%|
  2509|         0|            0|            0|  0.00%|        if name[0] == '.' and name[1:].isdigit():
  2510|         0|            0|            0|  0.00%|            # These are implicit arguments generated by comprehensions. In
  2511|         0|            0|            0|  0.00%|            # order to provide a friendlier interface to users, we recast
  2512|         0|            0|            0|  0.00%|            # their name as "implicitN" and treat them as positional-only.
  2513|         0|            0|            0|  0.00%|            # See issue 19611.
  2514|         0|            0|            0|  0.00%|            if self._kind != _POSITIONAL_OR_KEYWORD:
  2515|         0|            0|            0|  0.00%|                msg = (
  2516|         0|            0|            0|  0.00%|                    'implicit arguments must be passed as '
  2517|         0|            0|            0|  0.00%|                    'positional or keyword arguments, not {}'
  2518|         0|            0|            0|  0.00%|                )
  2519|         0|            0|            0|  0.00%|                msg = msg.format(self._kind.description)
  2520|         0|            0|            0|  0.00%|                raise ValueError(msg)
  2521|         0|            0|            0|  0.00%|            self._kind = _POSITIONAL_ONLY
  2522|         0|            0|            0|  0.00%|            name = 'implicit{}'.format(name[1:])
  2523|         0|            0|            0|  0.00%|
  2524|         0|            0|            0|  0.00%|        if not name.isidentifier():
  2525|         0|            0|            0|  0.00%|            raise ValueError('{!r} is not a valid parameter name'.format(name))
  2526|         0|            0|            0|  0.00%|
  2527|         0|            0|            0|  0.00%|        self._name = name
  2528|         0|            0|            0|  0.00%|
  2529|         0|            0|            0|  0.00%|    def __reduce__(self):
  2530|         0|            0|            0|  0.00%|        return (type(self),
  2531|         0|            0|            0|  0.00%|                (self._name, self._kind),
  2532|         0|            0|            0|  0.00%|                {'_default': self._default,
  2533|         0|            0|            0|  0.00%|                 '_annotation': self._annotation})
  2534|         0|            0|            0|  0.00%|
  2535|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  2536|         0|            0|            0|  0.00%|        self._default = state['_default']
  2537|         0|            0|            0|  0.00%|        self._annotation = state['_annotation']
  2538|         0|            0|            0|  0.00%|
  2539|         0|            0|            0|  0.00%|    @property
  2540|         0|            0|            0|  0.00%|    def name(self):
  2541|         0|            0|            0|  0.00%|        return self._name
  2542|         0|            0|            0|  0.00%|
  2543|         0|            0|            0|  0.00%|    @property
  2544|         0|            0|            0|  0.00%|    def default(self):
  2545|         0|            0|            0|  0.00%|        return self._default
  2546|         0|            0|            0|  0.00%|
  2547|         0|            0|            0|  0.00%|    @property
  2548|         0|            0|            0|  0.00%|    def annotation(self):
  2549|         0|            0|            0|  0.00%|        return self._annotation
  2550|         0|            0|            0|  0.00%|
  2551|         0|            0|            0|  0.00%|    @property
  2552|         0|            0|            0|  0.00%|    def kind(self):
  2553|         0|            0|            0|  0.00%|        return self._kind
  2554|         0|            0|            0|  0.00%|
  2555|         0|            0|            0|  0.00%|    def replace(self, *, name=_void, kind=_void,
  2556|         0|            0|            0|  0.00%|                annotation=_void, default=_void):
  2557|         0|            0|            0|  0.00%|        """Creates a customized copy of the Parameter."""
  2558|         0|            0|            0|  0.00%|
  2559|         0|            0|            0|  0.00%|        if name is _void:
  2560|         0|            0|            0|  0.00%|            name = self._name
  2561|         0|            0|            0|  0.00%|
  2562|         0|            0|            0|  0.00%|        if kind is _void:
  2563|         0|            0|            0|  0.00%|            kind = self._kind
  2564|         0|            0|            0|  0.00%|
  2565|         0|            0|            0|  0.00%|        if annotation is _void:
  2566|         0|            0|            0|  0.00%|            annotation = self._annotation
  2567|         0|            0|            0|  0.00%|
  2568|         0|            0|            0|  0.00%|        if default is _void:
  2569|         0|            0|            0|  0.00%|            default = self._default
  2570|         0|            0|            0|  0.00%|
  2571|         0|            0|            0|  0.00%|        return type(self)(name, kind, default=default, annotation=annotation)
  2572|         0|            0|            0|  0.00%|
  2573|         0|            0|            0|  0.00%|    def __str__(self):
  2574|         0|            0|            0|  0.00%|        kind = self.kind
  2575|         0|            0|            0|  0.00%|        formatted = self._name
  2576|         0|            0|            0|  0.00%|
  2577|         0|            0|            0|  0.00%|        # Add annotation and default value
  2578|         0|            0|            0|  0.00%|        if self._annotation is not _empty:
  2579|         0|            0|            0|  0.00%|            formatted = '{}: {}'.format(formatted,
  2580|         0|            0|            0|  0.00%|                                       formatannotation(self._annotation))
  2581|         0|            0|            0|  0.00%|
  2582|         0|            0|            0|  0.00%|        if self._default is not _empty:
  2583|         0|            0|            0|  0.00%|            if self._annotation is not _empty:
  2584|         0|            0|            0|  0.00%|                formatted = '{} = {}'.format(formatted, repr(self._default))
  2585|         0|            0|            0|  0.00%|            else:
  2586|         0|            0|            0|  0.00%|                formatted = '{}={}'.format(formatted, repr(self._default))
  2587|         0|            0|            0|  0.00%|
  2588|         0|            0|            0|  0.00%|        if kind == _VAR_POSITIONAL:
  2589|         0|            0|            0|  0.00%|            formatted = '*' + formatted
  2590|         0|            0|            0|  0.00%|        elif kind == _VAR_KEYWORD:
  2591|         0|            0|            0|  0.00%|            formatted = '**' + formatted
  2592|         0|            0|            0|  0.00%|
  2593|         0|            0|            0|  0.00%|        return formatted
  2594|         0|            0|            0|  0.00%|
  2595|         0|            0|            0|  0.00%|    def __repr__(self):
  2596|         0|            0|            0|  0.00%|        return '<{} "{}">'.format(self.__class__.__name__, self)
  2597|         0|            0|            0|  0.00%|
  2598|         0|            0|            0|  0.00%|    def __hash__(self):
  2599|         0|            0|            0|  0.00%|        return hash((self.name, self.kind, self.annotation, self.default))
  2600|         0|            0|            0|  0.00%|
  2601|         0|            0|            0|  0.00%|    def __eq__(self, other):
  2602|         0|            0|            0|  0.00%|        if self is other:
  2603|         0|            0|            0|  0.00%|            return True
  2604|         0|            0|            0|  0.00%|        if not isinstance(other, Parameter):
  2605|         0|            0|            0|  0.00%|            return NotImplemented
  2606|         0|            0|            0|  0.00%|        return (self._name == other._name and
  2607|         0|            0|            0|  0.00%|                self._kind == other._kind and
  2608|         0|            0|            0|  0.00%|                self._default == other._default and
  2609|         0|            0|            0|  0.00%|                self._annotation == other._annotation)
  2610|         0|            0|            0|  0.00%|
  2611|         0|            0|            0|  0.00%|
  2612|         0|            0|            0|  0.00%|class BoundArguments:
  2613|         0|            0|            0|  0.00%|    """Result of `Signature.bind` call.  Holds the mapping of arguments
  2614|         0|            0|            0|  0.00%|    to the function's parameters.
  2615|         0|            0|            0|  0.00%|
  2616|         0|            0|            0|  0.00%|    Has the following public attributes:
  2617|         0|            0|            0|  0.00%|
  2618|         0|            0|            0|  0.00%|    * arguments : OrderedDict
  2619|         0|            0|            0|  0.00%|        An ordered mutable mapping of parameters' names to arguments' values.
  2620|         0|            0|            0|  0.00%|        Does not contain arguments' default values.
  2621|         0|            0|            0|  0.00%|    * signature : Signature
  2622|         0|            0|            0|  0.00%|        The Signature object that created this instance.
  2623|         0|            0|            0|  0.00%|    * args : tuple
  2624|         0|            0|            0|  0.00%|        Tuple of positional arguments values.
  2625|         0|            0|            0|  0.00%|    * kwargs : dict
  2626|         0|            0|            0|  0.00%|        Dict of keyword arguments values.
  2627|         0|            0|            0|  0.00%|    """
  2628|         0|            0|            0|  0.00%|
  2629|         0|            0|            0|  0.00%|    __slots__ = ('arguments', '_signature', '__weakref__')
  2630|         0|            0|            0|  0.00%|
  2631|         0|            0|            0|  0.00%|    def __init__(self, signature, arguments):
  2632|         0|            0|            0|  0.00%|        self.arguments = arguments
  2633|         0|            0|            0|  0.00%|        self._signature = signature
  2634|         0|            0|            0|  0.00%|
  2635|         0|            0|            0|  0.00%|    @property
  2636|         0|            0|            0|  0.00%|    def signature(self):
  2637|         0|            0|            0|  0.00%|        return self._signature
  2638|         0|            0|            0|  0.00%|
  2639|         0|            0|            0|  0.00%|    @property
  2640|         0|            0|            0|  0.00%|    def args(self):
  2641|         0|            0|            0|  0.00%|        args = []
  2642|         0|            0|            0|  0.00%|        for param_name, param in self._signature.parameters.items():
  2643|         0|            0|            0|  0.00%|            if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  2644|         0|            0|            0|  0.00%|                break
  2645|         0|            0|            0|  0.00%|
  2646|         0|            0|            0|  0.00%|            try:
  2647|         0|            0|            0|  0.00%|                arg = self.arguments[param_name]
  2648|         0|            0|            0|  0.00%|            except KeyError:
  2649|         0|            0|            0|  0.00%|                # We're done here. Other arguments
  2650|         0|            0|            0|  0.00%|                # will be mapped in 'BoundArguments.kwargs'
  2651|         0|            0|            0|  0.00%|                break
  2652|         0|            0|            0|  0.00%|            else:
  2653|         0|            0|            0|  0.00%|                if param.kind == _VAR_POSITIONAL:
  2654|         0|            0|            0|  0.00%|                    # *args
  2655|         0|            0|            0|  0.00%|                    args.extend(arg)
  2656|         0|            0|            0|  0.00%|                else:
  2657|         0|            0|            0|  0.00%|                    # plain argument
  2658|         0|            0|            0|  0.00%|                    args.append(arg)
  2659|         0|            0|            0|  0.00%|
  2660|         0|            0|            0|  0.00%|        return tuple(args)
  2661|         0|            0|            0|  0.00%|
  2662|         0|            0|            0|  0.00%|    @property
  2663|         0|            0|            0|  0.00%|    def kwargs(self):
  2664|         0|            0|            0|  0.00%|        kwargs = {}
  2665|         0|            0|            0|  0.00%|        kwargs_started = False
  2666|         0|            0|            0|  0.00%|        for param_name, param in self._signature.parameters.items():
  2667|         0|            0|            0|  0.00%|            if not kwargs_started:
  2668|         0|            0|            0|  0.00%|                if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  2669|         0|            0|            0|  0.00%|                    kwargs_started = True
  2670|         0|            0|            0|  0.00%|                else:
  2671|         0|            0|            0|  0.00%|                    if param_name not in self.arguments:
  2672|         0|            0|            0|  0.00%|                        kwargs_started = True
  2673|         0|            0|            0|  0.00%|                        continue
  2674|         0|            0|            0|  0.00%|
  2675|         0|            0|            0|  0.00%|            if not kwargs_started:
  2676|         0|            0|            0|  0.00%|                continue
  2677|         0|            0|            0|  0.00%|
  2678|         0|            0|            0|  0.00%|            try:
  2679|         0|            0|            0|  0.00%|                arg = self.arguments[param_name]
  2680|         0|            0|            0|  0.00%|            except KeyError:
  2681|         0|            0|            0|  0.00%|                pass
  2682|         0|            0|            0|  0.00%|            else:
  2683|         0|            0|            0|  0.00%|                if param.kind == _VAR_KEYWORD:
  2684|         0|            0|            0|  0.00%|                    # **kwargs
  2685|         0|            0|            0|  0.00%|                    kwargs.update(arg)
  2686|         0|            0|            0|  0.00%|                else:
  2687|         0|            0|            0|  0.00%|                    # plain keyword argument
  2688|         0|            0|            0|  0.00%|                    kwargs[param_name] = arg
  2689|         0|            0|            0|  0.00%|
  2690|         0|            0|            0|  0.00%|        return kwargs
  2691|         0|            0|            0|  0.00%|
  2692|         0|            0|            0|  0.00%|    def apply_defaults(self):
  2693|         0|            0|            0|  0.00%|        """Set default values for missing arguments.
  2694|         0|            0|            0|  0.00%|
  2695|         0|            0|            0|  0.00%|        For variable-positional arguments (*args) the default is an
  2696|         0|            0|            0|  0.00%|        empty tuple.
  2697|         0|            0|            0|  0.00%|
  2698|         0|            0|            0|  0.00%|        For variable-keyword arguments (**kwargs) the default is an
  2699|         0|            0|            0|  0.00%|        empty dict.
  2700|         0|            0|            0|  0.00%|        """
  2701|         0|            0|            0|  0.00%|        arguments = self.arguments
  2702|         0|            0|            0|  0.00%|        new_arguments = []
  2703|         0|            0|            0|  0.00%|        for name, param in self._signature.parameters.items():
  2704|         0|            0|            0|  0.00%|            try:
  2705|         0|            0|            0|  0.00%|                new_arguments.append((name, arguments[name]))
  2706|         0|            0|            0|  0.00%|            except KeyError:
  2707|         0|            0|            0|  0.00%|                if param.default is not _empty:
  2708|         0|            0|            0|  0.00%|                    val = param.default
  2709|         0|            0|            0|  0.00%|                elif param.kind is _VAR_POSITIONAL:
  2710|         0|            0|            0|  0.00%|                    val = ()
  2711|         0|            0|            0|  0.00%|                elif param.kind is _VAR_KEYWORD:
  2712|         0|            0|            0|  0.00%|                    val = {}
  2713|         0|            0|            0|  0.00%|                else:
  2714|         0|            0|            0|  0.00%|                    # This BoundArguments was likely produced by
  2715|         0|            0|            0|  0.00%|                    # Signature.bind_partial().
  2716|         0|            0|            0|  0.00%|                    continue
  2717|         0|            0|            0|  0.00%|                new_arguments.append((name, val))
  2718|         0|            0|            0|  0.00%|        self.arguments = OrderedDict(new_arguments)
  2719|         0|            0|            0|  0.00%|
  2720|         0|            0|            0|  0.00%|    def __eq__(self, other):
  2721|         0|            0|            0|  0.00%|        if self is other:
  2722|         0|            0|            0|  0.00%|            return True
  2723|         0|            0|            0|  0.00%|        if not isinstance(other, BoundArguments):
  2724|         0|            0|            0|  0.00%|            return NotImplemented
  2725|         0|            0|            0|  0.00%|        return (self.signature == other.signature and
  2726|         0|            0|            0|  0.00%|                self.arguments == other.arguments)
  2727|         0|            0|            0|  0.00%|
  2728|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  2729|         0|            0|            0|  0.00%|        self._signature = state['_signature']
  2730|         0|            0|            0|  0.00%|        self.arguments = state['arguments']
  2731|         0|            0|            0|  0.00%|
  2732|         0|            0|            0|  0.00%|    def __getstate__(self):
  2733|         0|            0|            0|  0.00%|        return {'_signature': self._signature, 'arguments': self.arguments}
  2734|         0|            0|            0|  0.00%|
  2735|         0|            0|            0|  0.00%|    def __repr__(self):
  2736|         0|            0|            0|  0.00%|        args = []
  2737|         0|            0|            0|  0.00%|        for arg, value in self.arguments.items():
  2738|         0|            0|            0|  0.00%|            args.append('{}={!r}'.format(arg, value))
  2739|         0|            0|            0|  0.00%|        return '<{} ({})>'.format(self.__class__.__name__, ', '.join(args))
  2740|         0|            0|            0|  0.00%|
  2741|         0|            0|            0|  0.00%|
  2742|         0|            0|            0|  0.00%|class Signature:
  2743|         0|            0|            0|  0.00%|    """A Signature object represents the overall signature of a function.
  2744|         0|            0|            0|  0.00%|    It stores a Parameter object for each parameter accepted by the
  2745|         0|            0|            0|  0.00%|    function, as well as information specific to the function itself.
  2746|         0|            0|            0|  0.00%|
  2747|         0|            0|            0|  0.00%|    A Signature object has the following public attributes and methods:
  2748|         0|            0|            0|  0.00%|
  2749|         0|            0|            0|  0.00%|    * parameters : OrderedDict
  2750|         0|            0|            0|  0.00%|        An ordered mapping of parameters' names to the corresponding
  2751|         0|            0|            0|  0.00%|        Parameter objects (keyword-only arguments are in the same order
  2752|         0|            0|            0|  0.00%|        as listed in `code.co_varnames`).
  2753|         0|            0|            0|  0.00%|    * return_annotation : object
  2754|         0|            0|            0|  0.00%|        The annotation for the return type of the function if specified.
  2755|         0|            0|            0|  0.00%|        If the function has no annotation for its return type, this
  2756|         0|            0|            0|  0.00%|        attribute is set to `Signature.empty`.
  2757|         0|            0|            0|  0.00%|    * bind(*args, **kwargs) -> BoundArguments
  2758|         0|            0|            0|  0.00%|        Creates a mapping from positional and keyword arguments to
  2759|         0|            0|            0|  0.00%|        parameters.
  2760|         0|            0|            0|  0.00%|    * bind_partial(*args, **kwargs) -> BoundArguments
  2761|         0|            0|            0|  0.00%|        Creates a partial mapping from positional and keyword arguments
  2762|         0|            0|            0|  0.00%|        to parameters (simulating 'functools.partial' behavior.)
  2763|         0|            0|            0|  0.00%|    """
  2764|         0|            0|            0|  0.00%|
  2765|         0|            0|            0|  0.00%|    __slots__ = ('_return_annotation', '_parameters')
  2766|         0|            0|            0|  0.00%|
  2767|         0|            0|            0|  0.00%|    _parameter_cls = Parameter
  2768|         0|            0|            0|  0.00%|    _bound_arguments_cls = BoundArguments
  2769|         0|            0|            0|  0.00%|
  2770|         0|            0|            0|  0.00%|    empty = _empty
  2771|         0|            0|            0|  0.00%|
  2772|         0|            0|            0|  0.00%|    def __init__(self, parameters=None, *, return_annotation=_empty,
  2773|         0|            0|            0|  0.00%|                 __validate_parameters__=True):
  2774|         0|            0|            0|  0.00%|        """Constructs Signature from the given list of Parameter
  2775|         0|            0|            0|  0.00%|        objects and 'return_annotation'.  All arguments are optional.
  2776|         0|            0|            0|  0.00%|        """
  2777|         0|            0|            0|  0.00%|
  2778|         0|            0|            0|  0.00%|        if parameters is None:
  2779|         0|            0|            0|  0.00%|            params = OrderedDict()
  2780|         0|            0|            0|  0.00%|        else:
  2781|         0|            0|            0|  0.00%|            if __validate_parameters__:
  2782|         0|            0|            0|  0.00%|                params = OrderedDict()
  2783|         0|            0|            0|  0.00%|                top_kind = _POSITIONAL_ONLY
  2784|         0|            0|            0|  0.00%|                kind_defaults = False
  2785|         0|            0|            0|  0.00%|
  2786|         0|            0|            0|  0.00%|                for idx, param in enumerate(parameters):
  2787|         0|            0|            0|  0.00%|                    kind = param.kind
  2788|         0|            0|            0|  0.00%|                    name = param.name
  2789|         0|            0|            0|  0.00%|
  2790|         0|            0|            0|  0.00%|                    if kind < top_kind:
  2791|         0|            0|            0|  0.00%|                        msg = (
  2792|         0|            0|            0|  0.00%|                            'wrong parameter order: {} parameter before {} '
  2793|         0|            0|            0|  0.00%|                            'parameter'
  2794|         0|            0|            0|  0.00%|                        )
  2795|         0|            0|            0|  0.00%|                        msg = msg.format(top_kind.description,
  2796|         0|            0|            0|  0.00%|                                         kind.description)
  2797|         0|            0|            0|  0.00%|                        raise ValueError(msg)
  2798|         0|            0|            0|  0.00%|                    elif kind > top_kind:
  2799|         0|            0|            0|  0.00%|                        kind_defaults = False
  2800|         0|            0|            0|  0.00%|                        top_kind = kind
  2801|         0|            0|            0|  0.00%|
  2802|         0|            0|            0|  0.00%|                    if kind in (_POSITIONAL_ONLY, _POSITIONAL_OR_KEYWORD):
  2803|         0|            0|            0|  0.00%|                        if param.default is _empty:
  2804|         0|            0|            0|  0.00%|                            if kind_defaults:
  2805|         0|            0|            0|  0.00%|                                # No default for this parameter, but the
  2806|         0|            0|            0|  0.00%|                                # previous parameter of the same kind had
  2807|         0|            0|            0|  0.00%|                                # a default
  2808|         0|            0|            0|  0.00%|                                msg = 'non-default argument follows default ' \
  2809|         0|            0|            0|  0.00%|                                      'argument'
  2810|         0|            0|            0|  0.00%|                                raise ValueError(msg)
  2811|         0|            0|            0|  0.00%|                        else:
  2812|         0|            0|            0|  0.00%|                            # There is a default for this parameter.
  2813|         0|            0|            0|  0.00%|                            kind_defaults = True
  2814|         0|            0|            0|  0.00%|
  2815|         0|            0|            0|  0.00%|                    if name in params:
  2816|         0|            0|            0|  0.00%|                        msg = 'duplicate parameter name: {!r}'.format(name)
  2817|         0|            0|            0|  0.00%|                        raise ValueError(msg)
  2818|         0|            0|            0|  0.00%|
  2819|         0|            0|            0|  0.00%|                    params[name] = param
  2820|         0|            0|            0|  0.00%|            else:
  2821|         0|            0|            0|  0.00%|                params = OrderedDict(((param.name, param)
  2822|         0|            0|            0|  0.00%|                                                for param in parameters))
  2823|         0|            0|            0|  0.00%|
  2824|         0|            0|            0|  0.00%|        self._parameters = types.MappingProxyType(params)
  2825|         0|            0|            0|  0.00%|        self._return_annotation = return_annotation
  2826|         0|            0|            0|  0.00%|
  2827|         0|            0|            0|  0.00%|    @classmethod
  2828|         0|            0|            0|  0.00%|    def from_function(cls, func):
  2829|         0|            0|            0|  0.00%|        """Constructs Signature for the given python function.
  2830|         0|            0|            0|  0.00%|
  2831|         0|            0|            0|  0.00%|        Deprecated since Python 3.5, use `Signature.from_callable()`.
  2832|         0|            0|            0|  0.00%|        """
  2833|         0|            0|            0|  0.00%|
  2834|         0|            0|            0|  0.00%|        warnings.warn("inspect.Signature.from_function() is deprecated since "
  2835|         0|            0|            0|  0.00%|                      "Python 3.5, use Signature.from_callable()",
  2836|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=2)
  2837|         0|            0|            0|  0.00%|        return _signature_from_function(cls, func)
  2838|         0|            0|            0|  0.00%|
  2839|         0|            0|            0|  0.00%|    @classmethod
  2840|         0|            0|            0|  0.00%|    def from_builtin(cls, func):
  2841|         0|            0|            0|  0.00%|        """Constructs Signature for the given builtin function.
  2842|         0|            0|            0|  0.00%|
  2843|         0|            0|            0|  0.00%|        Deprecated since Python 3.5, use `Signature.from_callable()`.
  2844|         0|            0|            0|  0.00%|        """
  2845|         0|            0|            0|  0.00%|
  2846|         0|            0|            0|  0.00%|        warnings.warn("inspect.Signature.from_builtin() is deprecated since "
  2847|         0|            0|            0|  0.00%|                      "Python 3.5, use Signature.from_callable()",
  2848|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=2)
  2849|         0|            0|            0|  0.00%|        return _signature_from_builtin(cls, func)
  2850|         0|            0|            0|  0.00%|
  2851|         0|            0|            0|  0.00%|    @classmethod
  2852|         0|            0|            0|  0.00%|    def from_callable(cls, obj, *, follow_wrapped=True):
  2853|         0|            0|            0|  0.00%|        """Constructs Signature for the given callable object."""
  2854|         0|            0|            0|  0.00%|        return _signature_from_callable(obj, sigcls=cls,
  2855|         0|            0|            0|  0.00%|                                        follow_wrapper_chains=follow_wrapped)
  2856|         0|            0|            0|  0.00%|
  2857|         0|            0|            0|  0.00%|    @property
  2858|         0|            0|            0|  0.00%|    def parameters(self):
  2859|         0|            0|            0|  0.00%|        return self._parameters
  2860|         0|            0|            0|  0.00%|
  2861|         0|            0|            0|  0.00%|    @property
  2862|         0|            0|            0|  0.00%|    def return_annotation(self):
  2863|         0|            0|            0|  0.00%|        return self._return_annotation
  2864|         0|            0|            0|  0.00%|
  2865|         0|            0|            0|  0.00%|    def replace(self, *, parameters=_void, return_annotation=_void):
  2866|         0|            0|            0|  0.00%|        """Creates a customized copy of the Signature.
  2867|         0|            0|            0|  0.00%|        Pass 'parameters' and/or 'return_annotation' arguments
  2868|         0|            0|            0|  0.00%|        to override them in the new copy.
  2869|         0|            0|            0|  0.00%|        """
  2870|         0|            0|            0|  0.00%|
  2871|         0|            0|            0|  0.00%|        if parameters is _void:
  2872|         0|            0|            0|  0.00%|            parameters = self.parameters.values()
  2873|         0|            0|            0|  0.00%|
  2874|         0|            0|            0|  0.00%|        if return_annotation is _void:
  2875|         0|            0|            0|  0.00%|            return_annotation = self._return_annotation
  2876|         0|            0|            0|  0.00%|
  2877|         0|            0|            0|  0.00%|        return type(self)(parameters,
  2878|         0|            0|            0|  0.00%|                          return_annotation=return_annotation)
  2879|         0|            0|            0|  0.00%|
  2880|         0|            0|            0|  0.00%|    def _hash_basis(self):
  2881|         0|            0|            0|  0.00%|        params = tuple(param for param in self.parameters.values()
  2882|         0|            0|            0|  0.00%|                             if param.kind != _KEYWORD_ONLY)
  2883|         0|            0|            0|  0.00%|
  2884|         0|            0|            0|  0.00%|        kwo_params = {param.name: param for param in self.parameters.values()
  2885|         0|            0|            0|  0.00%|                                        if param.kind == _KEYWORD_ONLY}
  2886|         0|            0|            0|  0.00%|
  2887|         0|            0|            0|  0.00%|        return params, kwo_params, self.return_annotation
  2888|         0|            0|            0|  0.00%|
  2889|         0|            0|            0|  0.00%|    def __hash__(self):
  2890|         0|            0|            0|  0.00%|        params, kwo_params, return_annotation = self._hash_basis()
  2891|         0|            0|            0|  0.00%|        kwo_params = frozenset(kwo_params.values())
  2892|         0|            0|            0|  0.00%|        return hash((params, kwo_params, return_annotation))
  2893|         0|            0|            0|  0.00%|
  2894|         0|            0|            0|  0.00%|    def __eq__(self, other):
  2895|         0|            0|            0|  0.00%|        if self is other:
  2896|         0|            0|            0|  0.00%|            return True
  2897|         0|            0|            0|  0.00%|        if not isinstance(other, Signature):
  2898|         0|            0|            0|  0.00%|            return NotImplemented
  2899|         0|            0|            0|  0.00%|        return self._hash_basis() == other._hash_basis()
  2900|         0|            0|            0|  0.00%|
  2901|         0|            0|            0|  0.00%|    def _bind(self, args, kwargs, *, partial=False):
  2902|         0|            0|            0|  0.00%|        """Private method. Don't use directly."""
  2903|         0|            0|            0|  0.00%|
  2904|         0|            0|            0|  0.00%|        arguments = OrderedDict()
  2905|         0|            0|            0|  0.00%|
  2906|         0|            0|            0|  0.00%|        parameters = iter(self.parameters.values())
  2907|         0|            0|            0|  0.00%|        parameters_ex = ()
  2908|         0|            0|            0|  0.00%|        arg_vals = iter(args)
  2909|         0|            0|            0|  0.00%|
  2910|         0|            0|            0|  0.00%|        while True:
  2911|         0|            0|            0|  0.00%|            # Let's iterate through the positional arguments and corresponding
  2912|         0|            0|            0|  0.00%|            # parameters
  2913|         0|            0|            0|  0.00%|            try:
  2914|         0|            0|            0|  0.00%|                arg_val = next(arg_vals)
  2915|         0|            0|            0|  0.00%|            except StopIteration:
  2916|         0|            0|            0|  0.00%|                # No more positional arguments
  2917|         0|            0|            0|  0.00%|                try:
  2918|         0|            0|            0|  0.00%|                    param = next(parameters)
  2919|         0|            0|            0|  0.00%|                except StopIteration:
  2920|         0|            0|            0|  0.00%|                    # No more parameters. That's it. Just need to check that
  2921|         0|            0|            0|  0.00%|                    # we have no `kwargs` after this while loop
  2922|         0|            0|            0|  0.00%|                    break
  2923|         0|            0|            0|  0.00%|                else:
  2924|         0|            0|            0|  0.00%|                    if param.kind == _VAR_POSITIONAL:
  2925|         0|            0|            0|  0.00%|                        # That's OK, just empty *args.  Let's start parsing
  2926|         0|            0|            0|  0.00%|                        # kwargs
  2927|         0|            0|            0|  0.00%|                        break
  2928|         0|            0|            0|  0.00%|                    elif param.name in kwargs:
  2929|         0|            0|            0|  0.00%|                        if param.kind == _POSITIONAL_ONLY:
  2930|         0|            0|            0|  0.00%|                            msg = '{arg!r} parameter is positional only, ' \
  2931|         0|            0|            0|  0.00%|                                  'but was passed as a keyword'
  2932|         0|            0|            0|  0.00%|                            msg = msg.format(arg=param.name)
  2933|         0|            0|            0|  0.00%|                            raise TypeError(msg) from None
  2934|         0|            0|            0|  0.00%|                        parameters_ex = (param,)
  2935|         0|            0|            0|  0.00%|                        break
  2936|         0|            0|            0|  0.00%|                    elif (param.kind == _VAR_KEYWORD or
  2937|         0|            0|            0|  0.00%|                                                param.default is not _empty):
  2938|         0|            0|            0|  0.00%|                        # That's fine too - we have a default value for this
  2939|         0|            0|            0|  0.00%|                        # parameter.  So, lets start parsing `kwargs`, starting
  2940|         0|            0|            0|  0.00%|                        # with the current parameter
  2941|         0|            0|            0|  0.00%|                        parameters_ex = (param,)
  2942|         0|            0|            0|  0.00%|                        break
  2943|         0|            0|            0|  0.00%|                    else:
  2944|         0|            0|            0|  0.00%|                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
  2945|         0|            0|            0|  0.00%|                        # not in `kwargs`
  2946|         0|            0|            0|  0.00%|                        if partial:
  2947|         0|            0|            0|  0.00%|                            parameters_ex = (param,)
  2948|         0|            0|            0|  0.00%|                            break
  2949|         0|            0|            0|  0.00%|                        else:
  2950|         0|            0|            0|  0.00%|                            msg = 'missing a required argument: {arg!r}'
  2951|         0|            0|            0|  0.00%|                            msg = msg.format(arg=param.name)
  2952|         0|            0|            0|  0.00%|                            raise TypeError(msg) from None
  2953|         0|            0|            0|  0.00%|            else:
  2954|         0|            0|            0|  0.00%|                # We have a positional argument to process
  2955|         0|            0|            0|  0.00%|                try:
  2956|         0|            0|            0|  0.00%|                    param = next(parameters)
  2957|         0|            0|            0|  0.00%|                except StopIteration:
  2958|         0|            0|            0|  0.00%|                    raise TypeError('too many positional arguments') from None
  2959|         0|            0|            0|  0.00%|                else:
  2960|         0|            0|            0|  0.00%|                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  2961|         0|            0|            0|  0.00%|                        # Looks like we have no parameter for this positional
  2962|         0|            0|            0|  0.00%|                        # argument
  2963|         0|            0|            0|  0.00%|                        raise TypeError(
  2964|         0|            0|            0|  0.00%|                            'too many positional arguments') from None
  2965|         0|            0|            0|  0.00%|
  2966|         0|            0|            0|  0.00%|                    if param.kind == _VAR_POSITIONAL:
  2967|         0|            0|            0|  0.00%|                        # We have an '*args'-like argument, let's fill it with
  2968|         0|            0|            0|  0.00%|                        # all positional arguments we have left and move on to
  2969|         0|            0|            0|  0.00%|                        # the next phase
  2970|         0|            0|            0|  0.00%|                        values = [arg_val]
  2971|         0|            0|            0|  0.00%|                        values.extend(arg_vals)
  2972|         0|            0|            0|  0.00%|                        arguments[param.name] = tuple(values)
  2973|         0|            0|            0|  0.00%|                        break
  2974|         0|            0|            0|  0.00%|
  2975|         0|            0|            0|  0.00%|                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
  2976|         0|            0|            0|  0.00%|                        raise TypeError(
  2977|         0|            0|            0|  0.00%|                            'multiple values for argument {arg!r}'.format(
  2978|         0|            0|            0|  0.00%|                                arg=param.name)) from None
  2979|         0|            0|            0|  0.00%|
  2980|         0|            0|            0|  0.00%|                    arguments[param.name] = arg_val
  2981|         0|            0|            0|  0.00%|
  2982|         0|            0|            0|  0.00%|        # Now, we iterate through the remaining parameters to process
  2983|         0|            0|            0|  0.00%|        # keyword arguments
  2984|         0|            0|            0|  0.00%|        kwargs_param = None
  2985|         0|            0|            0|  0.00%|        for param in itertools.chain(parameters_ex, parameters):
  2986|         0|            0|            0|  0.00%|            if param.kind == _VAR_KEYWORD:
  2987|         0|            0|            0|  0.00%|                # Memorize that we have a '**kwargs'-like parameter
  2988|         0|            0|            0|  0.00%|                kwargs_param = param
  2989|         0|            0|            0|  0.00%|                continue
  2990|         0|            0|            0|  0.00%|
  2991|         0|            0|            0|  0.00%|            if param.kind == _VAR_POSITIONAL:
  2992|         0|            0|            0|  0.00%|                # Named arguments don't refer to '*args'-like parameters.
  2993|         0|            0|            0|  0.00%|                # We only arrive here if the positional arguments ended
  2994|         0|            0|            0|  0.00%|                # before reaching the last parameter before *args.
  2995|         0|            0|            0|  0.00%|                continue
  2996|         0|            0|            0|  0.00%|
  2997|         0|            0|            0|  0.00%|            param_name = param.name
  2998|         0|            0|            0|  0.00%|            try:
  2999|         0|            0|            0|  0.00%|                arg_val = kwargs.pop(param_name)
  3000|         0|            0|            0|  0.00%|            except KeyError:
  3001|         0|            0|            0|  0.00%|                # We have no value for this parameter.  It's fine though,
  3002|         0|            0|            0|  0.00%|                # if it has a default value, or it is an '*args'-like
  3003|         0|            0|            0|  0.00%|                # parameter, left alone by the processing of positional
  3004|         0|            0|            0|  0.00%|                # arguments.
  3005|         0|            0|            0|  0.00%|                if (not partial and param.kind != _VAR_POSITIONAL and
  3006|         0|            0|            0|  0.00%|                                                    param.default is _empty):
  3007|         0|            0|            0|  0.00%|                    raise TypeError('missing a required argument: {arg!r}'. \
  3008|         0|            0|            0|  0.00%|                                    format(arg=param_name)) from None
  3009|         0|            0|            0|  0.00%|
  3010|         0|            0|            0|  0.00%|            else:
  3011|         0|            0|            0|  0.00%|                if param.kind == _POSITIONAL_ONLY:
  3012|         0|            0|            0|  0.00%|                    # This should never happen in case of a properly built
  3013|         0|            0|            0|  0.00%|                    # Signature object (but let's have this check here
  3014|         0|            0|            0|  0.00%|                    # to ensure correct behaviour just in case)
  3015|         0|            0|            0|  0.00%|                    raise TypeError('{arg!r} parameter is positional only, '
  3016|         0|            0|            0|  0.00%|                                    'but was passed as a keyword'. \
  3017|         0|            0|            0|  0.00%|                                    format(arg=param.name))
  3018|         0|            0|            0|  0.00%|
  3019|         0|            0|            0|  0.00%|                arguments[param_name] = arg_val
  3020|         0|            0|            0|  0.00%|
  3021|         0|            0|            0|  0.00%|        if kwargs:
  3022|         0|            0|            0|  0.00%|            if kwargs_param is not None:
  3023|         0|            0|            0|  0.00%|                # Process our '**kwargs'-like parameter
  3024|         0|            0|            0|  0.00%|                arguments[kwargs_param.name] = kwargs
  3025|         0|            0|            0|  0.00%|            else:
  3026|         0|            0|            0|  0.00%|                raise TypeError(
  3027|         0|            0|            0|  0.00%|                    'got an unexpected keyword argument {arg!r}'.format(
  3028|         0|            0|            0|  0.00%|                        arg=next(iter(kwargs))))
  3029|         0|            0|            0|  0.00%|
  3030|         0|            0|            0|  0.00%|        return self._bound_arguments_cls(self, arguments)
  3031|         0|            0|            0|  0.00%|
  3032|         0|            0|            0|  0.00%|    def bind(self, /, *args, **kwargs):
  3033|         0|            0|            0|  0.00%|        """Get a BoundArguments object, that maps the passed `args`
  3034|         0|            0|            0|  0.00%|        and `kwargs` to the function's signature.  Raises `TypeError`
  3035|         0|            0|            0|  0.00%|        if the passed arguments can not be bound.
  3036|         0|            0|            0|  0.00%|        """
  3037|         0|            0|            0|  0.00%|        return self._bind(args, kwargs)
  3038|         0|            0|            0|  0.00%|
  3039|         0|            0|            0|  0.00%|    def bind_partial(self, /, *args, **kwargs):
  3040|         0|            0|            0|  0.00%|        """Get a BoundArguments object, that partially maps the
  3041|         0|            0|            0|  0.00%|        passed `args` and `kwargs` to the function's signature.
  3042|         0|            0|            0|  0.00%|        Raises `TypeError` if the passed arguments can not be bound.
  3043|         0|            0|            0|  0.00%|        """
  3044|         0|            0|            0|  0.00%|        return self._bind(args, kwargs, partial=True)
  3045|         0|            0|            0|  0.00%|
  3046|         0|            0|            0|  0.00%|    def __reduce__(self):
  3047|         0|            0|            0|  0.00%|        return (type(self),
  3048|         0|            0|            0|  0.00%|                (tuple(self._parameters.values()),),
  3049|         0|            0|            0|  0.00%|                {'_return_annotation': self._return_annotation})
  3050|         0|            0|            0|  0.00%|
  3051|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  3052|         0|            0|            0|  0.00%|        self._return_annotation = state['_return_annotation']
  3053|         0|            0|            0|  0.00%|
  3054|         0|            0|            0|  0.00%|    def __repr__(self):
  3055|         0|            0|            0|  0.00%|        return '<{} {}>'.format(self.__class__.__name__, self)
  3056|         0|            0|            0|  0.00%|
  3057|         0|            0|            0|  0.00%|    def __str__(self):
  3058|         0|            0|            0|  0.00%|        result = []
  3059|         0|            0|            0|  0.00%|        render_pos_only_separator = False
  3060|         0|            0|            0|  0.00%|        render_kw_only_separator = True
  3061|         0|            0|            0|  0.00%|        for param in self.parameters.values():
  3062|         0|            0|            0|  0.00%|            formatted = str(param)
  3063|         0|            0|            0|  0.00%|
  3064|         0|            0|            0|  0.00%|            kind = param.kind
  3065|         0|            0|            0|  0.00%|
  3066|         0|            0|            0|  0.00%|            if kind == _POSITIONAL_ONLY:
  3067|         0|            0|            0|  0.00%|                render_pos_only_separator = True
  3068|         0|            0|            0|  0.00%|            elif render_pos_only_separator:
  3069|         0|            0|            0|  0.00%|                # It's not a positional-only parameter, and the flag
  3070|         0|            0|            0|  0.00%|                # is set to 'True' (there were pos-only params before.)
  3071|         0|            0|            0|  0.00%|                result.append('/')
  3072|         0|            0|            0|  0.00%|                render_pos_only_separator = False
  3073|         0|            0|            0|  0.00%|
  3074|         0|            0|            0|  0.00%|            if kind == _VAR_POSITIONAL:
  3075|         0|            0|            0|  0.00%|                # OK, we have an '*args'-like parameter, so we won't need
  3076|         0|            0|            0|  0.00%|                # a '*' to separate keyword-only arguments
  3077|         0|            0|            0|  0.00%|                render_kw_only_separator = False
  3078|         0|            0|            0|  0.00%|            elif kind == _KEYWORD_ONLY and render_kw_only_separator:
  3079|         0|            0|            0|  0.00%|                # We have a keyword-only parameter to render and we haven't
  3080|         0|            0|            0|  0.00%|                # rendered an '*args'-like parameter before, so add a '*'
  3081|         0|            0|            0|  0.00%|                # separator to the parameters list ("foo(arg1, *, arg2)" case)
  3082|         0|            0|            0|  0.00%|                result.append('*')
  3083|         0|            0|            0|  0.00%|                # This condition should be only triggered once, so
  3084|         0|            0|            0|  0.00%|                # reset the flag
  3085|         0|            0|            0|  0.00%|                render_kw_only_separator = False
  3086|         0|            0|            0|  0.00%|
  3087|         0|            0|            0|  0.00%|            result.append(formatted)
  3088|         0|            0|            0|  0.00%|
  3089|         0|            0|            0|  0.00%|        if render_pos_only_separator:
  3090|         0|            0|            0|  0.00%|            # There were only positional-only parameters, hence the
  3091|         0|            0|            0|  0.00%|            # flag was not reset to 'False'
  3092|         0|            0|            0|  0.00%|            result.append('/')
  3093|         0|            0|            0|  0.00%|
  3094|         0|            0|            0|  0.00%|        rendered = '({})'.format(', '.join(result))
  3095|         0|            0|            0|  0.00%|
  3096|         0|            0|            0|  0.00%|        if self.return_annotation is not _empty:
  3097|         0|            0|            0|  0.00%|            anno = formatannotation(self.return_annotation)
  3098|         0|            0|            0|  0.00%|            rendered += ' -> {}'.format(anno)
  3099|         0|            0|            0|  0.00%|
  3100|         0|            0|            0|  0.00%|        return rendered
  3101|         0|            0|            0|  0.00%|
  3102|         0|            0|            0|  0.00%|
  3103|         0|            0|            0|  0.00%|def signature(obj, *, follow_wrapped=True):
  3104|         0|            0|            0|  0.00%|    """Get a signature object for the passed callable."""
  3105|         0|            0|            0|  0.00%|    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)
  3106|         0|            0|            0|  0.00%|
  3107|         0|            0|            0|  0.00%|
  3108|         0|            0|            0|  0.00%|def _main():
  3109|         0|            0|            0|  0.00%|    """ Logic for inspecting an object given at command line """
  3110|         0|            0|            0|  0.00%|    import argparse
  3111|         0|            0|            0|  0.00%|    import importlib
  3112|         0|            0|            0|  0.00%|
  3113|         0|            0|            0|  0.00%|    parser = argparse.ArgumentParser()
  3114|         0|            0|            0|  0.00%|    parser.add_argument(
  3115|         0|            0|            0|  0.00%|        'object',
  3116|         0|            0|            0|  0.00%|         help="The object to be analysed. "
  3117|         0|            0|            0|  0.00%|              "It supports the 'module:qualname' syntax")
  3118|         0|            0|            0|  0.00%|    parser.add_argument(
  3119|         0|            0|            0|  0.00%|        '-d', '--details', action='store_true',
  3120|         0|            0|            0|  0.00%|        help='Display info about the module rather than its source code')
  3121|         0|            0|            0|  0.00%|
  3122|         0|            0|            0|  0.00%|    args = parser.parse_args()
  3123|         0|            0|            0|  0.00%|
  3124|         0|            0|            0|  0.00%|    target = args.object
  3125|         0|            0|            0|  0.00%|    mod_name, has_attrs, attrs = target.partition(":")
  3126|         0|            0|            0|  0.00%|    try:
  3127|         0|            0|            0|  0.00%|        obj = module = importlib.import_module(mod_name)
  3128|         0|            0|            0|  0.00%|    except Exception as exc:
  3129|         0|            0|            0|  0.00%|        msg = "Failed to import {} ({}: {})".format(mod_name,
  3130|         0|            0|            0|  0.00%|                                                    type(exc).__name__,
  3131|         0|            0|            0|  0.00%|                                                    exc)
  3132|         0|            0|            0|  0.00%|        print(msg, file=sys.stderr)
  3133|         0|            0|            0|  0.00%|        sys.exit(2)
  3134|         0|            0|            0|  0.00%|
  3135|         0|            0|            0|  0.00%|    if has_attrs:
  3136|         0|            0|            0|  0.00%|        parts = attrs.split(".")
  3137|         0|            0|            0|  0.00%|        obj = module
  3138|         0|            0|            0|  0.00%|        for part in parts:
  3139|         0|            0|            0|  0.00%|            obj = getattr(obj, part)
  3140|         0|            0|            0|  0.00%|
  3141|         0|            0|            0|  0.00%|    if module.__name__ in sys.builtin_module_names:
  3142|         0|            0|            0|  0.00%|        print("Can't get info for builtin modules.", file=sys.stderr)
  3143|         0|            0|            0|  0.00%|        sys.exit(1)
  3144|         0|            0|            0|  0.00%|
  3145|         0|            0|            0|  0.00%|    if args.details:
  3146|         0|            0|            0|  0.00%|        print('Target: {}'.format(target))
  3147|         0|            0|            0|  0.00%|        print('Origin: {}'.format(getsourcefile(module)))
  3148|         0|            0|            0|  0.00%|        print('Cached: {}'.format(module.__cached__))
  3149|         0|            0|            0|  0.00%|        if obj is module:
  3150|         0|            0|            0|  0.00%|            print('Loader: {}'.format(repr(module.__loader__)))
  3151|         0|            0|            0|  0.00%|            if hasattr(module, '__path__'):
  3152|         0|            0|            0|  0.00%|                print('Submodule search path: {}'.format(module.__path__))
  3153|         0|            0|            0|  0.00%|        else:
  3154|         0|            0|            0|  0.00%|            try:
  3155|         0|            0|            0|  0.00%|                __, lineno = findsource(obj)
  3156|         0|            0|            0|  0.00%|            except Exception:
  3157|         0|            0|            0|  0.00%|                pass
  3158|         0|            0|            0|  0.00%|            else:
  3159|         0|            0|            0|  0.00%|                print('Line: {}'.format(lineno))
  3160|         0|            0|            0|  0.00%|
  3161|         0|            0|            0|  0.00%|        print('\n')
  3162|         0|            0|            0|  0.00%|    else:
  3163|         0|            0|            0|  0.00%|        print(getsource(obj))
  3164|         0|            0|            0|  0.00%|
  3165|         0|            0|            0|  0.00%|
  3166|         0|            0|            0|  0.00%|if __name__ == "__main__":
  3167|         0|            0|            0|  0.00%|    _main()
File: /opt/conda/lib/python3.8/sre_parse.py
File duration: 0.289801s (0.21%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Secret Labs' Regular Expression Engine
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# convert re-style regular expression to sre pattern
     5|         0|            0|            0|  0.00%|#
     6|         0|            0|            0|  0.00%|# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# See the sre.py file for information on usage and redistribution.
     9|         0|            0|            0|  0.00%|#
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|"""Internal support module for sre"""
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|# XXX: show string offset and offending character for all errors
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|from sre_constants import *
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|SPECIAL_CHARS = ".\\[{()*+?^$|"
    18|         0|            0|            0|  0.00%|REPEAT_CHARS = "*+?{"
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|DIGITS = frozenset("0123456789")
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|OCTDIGITS = frozenset("01234567")
    23|         0|            0|            0|  0.00%|HEXDIGITS = frozenset("0123456789abcdefABCDEF")
    24|         0|            0|            0|  0.00%|ASCIILETTERS = frozenset("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|WHITESPACE = frozenset(" \t\n\r\v\f")
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT})
    29|         0|            0|            0|  0.00%|_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|ESCAPES = {
    32|         0|            0|            0|  0.00%|    r"\a": (LITERAL, ord("\a")),
    33|         0|            0|            0|  0.00%|    r"\b": (LITERAL, ord("\b")),
    34|         0|            0|            0|  0.00%|    r"\f": (LITERAL, ord("\f")),
    35|         0|            0|            0|  0.00%|    r"\n": (LITERAL, ord("\n")),
    36|         0|            0|            0|  0.00%|    r"\r": (LITERAL, ord("\r")),
    37|         0|            0|            0|  0.00%|    r"\t": (LITERAL, ord("\t")),
    38|         0|            0|            0|  0.00%|    r"\v": (LITERAL, ord("\v")),
    39|         0|            0|            0|  0.00%|    r"\\": (LITERAL, ord("\\"))
    40|         0|            0|            0|  0.00%|}
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|CATEGORIES = {
    43|         0|            0|            0|  0.00%|    r"\A": (AT, AT_BEGINNING_STRING), # start of string
    44|         0|            0|            0|  0.00%|    r"\b": (AT, AT_BOUNDARY),
    45|         0|            0|            0|  0.00%|    r"\B": (AT, AT_NON_BOUNDARY),
    46|         0|            0|            0|  0.00%|    r"\d": (IN, [(CATEGORY, CATEGORY_DIGIT)]),
    47|         0|            0|            0|  0.00%|    r"\D": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),
    48|         0|            0|            0|  0.00%|    r"\s": (IN, [(CATEGORY, CATEGORY_SPACE)]),
    49|         0|            0|            0|  0.00%|    r"\S": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),
    50|         0|            0|            0|  0.00%|    r"\w": (IN, [(CATEGORY, CATEGORY_WORD)]),
    51|         0|            0|            0|  0.00%|    r"\W": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),
    52|         0|            0|            0|  0.00%|    r"\Z": (AT, AT_END_STRING), # end of string
    53|         0|            0|            0|  0.00%|}
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|FLAGS = {
    56|         0|            0|            0|  0.00%|    # standard flags
    57|         0|            0|            0|  0.00%|    "i": SRE_FLAG_IGNORECASE,
    58|         0|            0|            0|  0.00%|    "L": SRE_FLAG_LOCALE,
    59|         0|            0|            0|  0.00%|    "m": SRE_FLAG_MULTILINE,
    60|         0|            0|            0|  0.00%|    "s": SRE_FLAG_DOTALL,
    61|         0|            0|            0|  0.00%|    "x": SRE_FLAG_VERBOSE,
    62|         0|            0|            0|  0.00%|    # extensions
    63|         0|            0|            0|  0.00%|    "a": SRE_FLAG_ASCII,
    64|         0|            0|            0|  0.00%|    "t": SRE_FLAG_TEMPLATE,
    65|         0|            0|            0|  0.00%|    "u": SRE_FLAG_UNICODE,
    66|         0|            0|            0|  0.00%|}
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|TYPE_FLAGS = SRE_FLAG_ASCII | SRE_FLAG_LOCALE | SRE_FLAG_UNICODE
    69|         0|            0|            0|  0.00%|GLOBAL_FLAGS = SRE_FLAG_DEBUG | SRE_FLAG_TEMPLATE
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|class Verbose(Exception):
    72|         0|            0|            0|  0.00%|    pass
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|class State:
    75|         0|            0|            0|  0.00%|    # keeps track of state for parsing
    76|         2|  1.16825e-05|  5.84126e-06|  0.00%|    def __init__(self):
    77|         2|   1.0252e-05|    5.126e-06|  0.00%|        self.flags = 0
    78|         2|  9.53674e-06|  4.76837e-06|  0.00%|        self.groupdict = {}
    79|         2|  9.05991e-06|  4.52995e-06|  0.00%|        self.groupwidths = [None]  # group 0
    80|         2|  9.53674e-06|  4.76837e-06|  0.00%|        self.lookbehindgroups = None
    81|        57|  0.000238419|  4.18278e-06|  0.00%|    @property
    82|         0|            0|            0|  0.00%|    def groups(self):
    83|        57|  0.000329256|  5.77642e-06|  0.00%|        return len(self.groupwidths)
    84|        26|  0.000151634|  5.83209e-06|  0.00%|    def opengroup(self, name=None):
    85|        26|  0.000320673|  1.23336e-05|  0.00%|        gid = self.groups
(call)|        26|  0.000268936|  1.03437e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:81 groups
    86|        26|  0.000161886|  6.22639e-06|  0.00%|        self.groupwidths.append(None)
    87|        26|  0.000314474|  1.20952e-05|  0.00%|        if self.groups > MAXGROUPS:
(call)|        26|  0.000241756|  9.29832e-06|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:81 groups
    88|         0|            0|            0|  0.00%|            raise error("too many groups")
    89|        26|  0.000105143|  4.04395e-06|  0.00%|        if name is not None:
    90|         0|            0|            0|  0.00%|            ogid = self.groupdict.get(name, None)
    91|         0|            0|            0|  0.00%|            if ogid is not None:
    92|         0|            0|            0|  0.00%|                raise error("redefinition of group name %r as group %d; "
    93|         0|            0|            0|  0.00%|                            "was group %d" % (name, gid,  ogid))
    94|         0|            0|            0|  0.00%|            self.groupdict[name] = gid
    95|        26|  0.000100613|  3.86972e-06|  0.00%|        return gid
    96|        26|  0.000140905|  5.41944e-06|  0.00%|    def closegroup(self, gid, p):
    97|        26|   0.00037384|  1.43785e-05|  0.00%|        self.groupwidths[gid] = p.getwidth()
(call)|        26|    0.0312304|   0.00120117|  0.02%|# /opt/conda/lib/python3.8/sre_parse.py:174 getwidth
    98|         0|            0|            0|  0.00%|    def checkgroup(self, gid):
    99|         0|            0|            0|  0.00%|        return gid < self.groups and self.groupwidths[gid] is not None
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    def checklookbehindgroup(self, gid, source):
   102|         0|            0|            0|  0.00%|        if self.lookbehindgroups is not None:
   103|         0|            0|            0|  0.00%|            if not self.checkgroup(gid):
   104|         0|            0|            0|  0.00%|                raise source.error('cannot refer to an open group')
   105|         0|            0|            0|  0.00%|            if gid >= self.lookbehindgroups:
   106|         0|            0|            0|  0.00%|                raise source.error('cannot refer to group defined in the same '
   107|         0|            0|            0|  0.00%|                                   'lookbehind subpattern')
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|class SubPattern:
   110|         0|            0|            0|  0.00%|    # a subpattern, in intermediate form
   111|       305|   0.00162554|  5.32963e-06|  0.00%|    def __init__(self, state, data=None):
   112|       305|   0.00128794|  4.22274e-06|  0.00%|        self.state = state
   113|       305|   0.00109386|  3.58644e-06|  0.00%|        if data is None:
   114|       243|  0.000848293|  3.49092e-06|  0.00%|            data = []
   115|       305|   0.00107765|  3.53329e-06|  0.00%|        self.data = data
   116|       305|   0.00108695|  3.56377e-06|  0.00%|        self.width = None
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    def dump(self, level=0):
   119|         0|            0|            0|  0.00%|        nl = True
   120|         0|            0|            0|  0.00%|        seqtypes = (tuple, list)
   121|         0|            0|            0|  0.00%|        for op, av in self.data:
   122|         0|            0|            0|  0.00%|            print(level*"  " + str(op), end='')
   123|         0|            0|            0|  0.00%|            if op is IN:
   124|         0|            0|            0|  0.00%|                # member sublanguage
   125|         0|            0|            0|  0.00%|                print()
   126|         0|            0|            0|  0.00%|                for op, a in av:
   127|         0|            0|            0|  0.00%|                    print((level+1)*"  " + str(op), a)
   128|         0|            0|            0|  0.00%|            elif op is BRANCH:
   129|         0|            0|            0|  0.00%|                print()
   130|         0|            0|            0|  0.00%|                for i, a in enumerate(av[1]):
   131|         0|            0|            0|  0.00%|                    if i:
   132|         0|            0|            0|  0.00%|                        print(level*"  " + "OR")
   133|         0|            0|            0|  0.00%|                    a.dump(level+1)
   134|         0|            0|            0|  0.00%|            elif op is GROUPREF_EXISTS:
   135|         0|            0|            0|  0.00%|                condgroup, item_yes, item_no = av
   136|         0|            0|            0|  0.00%|                print('', condgroup)
   137|         0|            0|            0|  0.00%|                item_yes.dump(level+1)
   138|         0|            0|            0|  0.00%|                if item_no:
   139|         0|            0|            0|  0.00%|                    print(level*"  " + "ELSE")
   140|         0|            0|            0|  0.00%|                    item_no.dump(level+1)
   141|         0|            0|            0|  0.00%|            elif isinstance(av, seqtypes):
   142|         0|            0|            0|  0.00%|                nl = False
   143|         0|            0|            0|  0.00%|                for a in av:
   144|         0|            0|            0|  0.00%|                    if isinstance(a, SubPattern):
   145|         0|            0|            0|  0.00%|                        if not nl:
   146|         0|            0|            0|  0.00%|                            print()
   147|         0|            0|            0|  0.00%|                        a.dump(level+1)
   148|         0|            0|            0|  0.00%|                        nl = True
   149|         0|            0|            0|  0.00%|                    else:
   150|         0|            0|            0|  0.00%|                        if not nl:
   151|         0|            0|            0|  0.00%|                            print(' ', end='')
   152|         0|            0|            0|  0.00%|                        print(a, end='')
   153|         0|            0|            0|  0.00%|                        nl = False
   154|         0|            0|            0|  0.00%|                if not nl:
   155|         0|            0|            0|  0.00%|                    print()
   156|         0|            0|            0|  0.00%|            else:
   157|         0|            0|            0|  0.00%|                print('', av)
   158|         0|            0|            0|  0.00%|    def __repr__(self):
   159|         0|            0|            0|  0.00%|        return repr(self.data)
   160|       478|   0.00228715|  4.78483e-06|  0.00%|    def __len__(self):
   161|       478|    0.0026989|  5.64623e-06|  0.00%|        return len(self.data)
   162|         0|            0|            0|  0.00%|    def __delitem__(self, index):
   163|         0|            0|            0|  0.00%|        del self.data[index]
   164|      1537|   0.00726962|  4.72975e-06|  0.01%|    def __getitem__(self, index):
   165|      1537|   0.00879407|  5.72158e-06|  0.01%|        if isinstance(index, slice):
   166|        62|  0.000804901|  1.29823e-05|  0.00%|            return SubPattern(self.state, self.data[index])
(call)|        62|   0.00128055|   2.0654e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:111 __init__
   167|      1475|   0.00594926|   4.0334e-06|  0.00%|        return self.data[index]
   168|        63|  0.000331163|  5.25656e-06|  0.00%|    def __setitem__(self, index, code):
   169|        63|  0.000299215|  4.74945e-06|  0.00%|        self.data[index] = code
(call)|         1|  1.14441e-05|  1.14441e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
(call)|         2|  2.93255e-05|  1.46627e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   170|         0|            0|            0|  0.00%|    def insert(self, index, code):
   171|         0|            0|            0|  0.00%|        self.data.insert(index, code)
   172|       443|   0.00237513|  5.36146e-06|  0.00%|    def append(self, code):
   173|       443|   0.00264764|  5.97661e-06|  0.00%|        self.data.append(code)
   174|       306|   0.00156426|  5.11197e-06|  0.00%|    def getwidth(self):
   175|         0|            0|            0|  0.00%|        # determine the width (min, max) for this subpattern
   176|       306|    0.0015018|  4.90784e-06|  0.00%|        if self.width is not None:
   177|        26|   0.00012207|  4.69501e-06|  0.00%|            return self.width
   178|       280|   0.00128198|  4.57849e-06|  0.00%|        lo = hi = 0
   179|       760|   0.00328612|  4.32385e-06|  0.00%|        for op, av in self.data:
   180|       480|   0.00204587|  4.26223e-06|  0.00%|            if op is BRANCH:
   181|        21|  0.000102043|   4.8592e-06|  0.00%|                i = MAXREPEAT - 1
   182|        21|  9.17912e-05|  4.37101e-06|  0.00%|                j = 0
   183|       210|  0.000854731|  4.07015e-06|  0.00%|                for av in av[1]:
   184|       189|   0.00249958|  1.32253e-05|  0.00%|                    l, h = av.getwidth()
(call)|       189|    0.0179751|  9.51063e-05|  0.01%|# /opt/conda/lib/python3.8/sre_parse.py:174 getwidth
   185|       189|   0.00117898|  6.23799e-06|  0.00%|                    i = min(i, l)
   186|       189|    0.0011766|  6.22537e-06|  0.00%|                    j = max(j, h)
   187|        21|  8.15392e-05|  3.88282e-06|  0.00%|                lo = lo + i
   188|        21|  8.55923e-05|  4.07582e-06|  0.00%|                hi = hi + j
   189|       459|   0.00194502|  4.23751e-06|  0.00%|            elif op is CALL:
   190|         0|            0|            0|  0.00%|                i, j = av.getwidth()
   191|         0|            0|            0|  0.00%|                lo = lo + i
   192|         0|            0|            0|  0.00%|                hi = hi + j
   193|       459|   0.00192547|  4.19492e-06|  0.00%|            elif op is SUBPATTERN:
   194|        26|  0.000382423|  1.47086e-05|  0.00%|                i, j = av[-1].getwidth()
(call)|        26|  0.000379801|  1.46077e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:174 getwidth
   195|        26|  0.000117302|  4.51161e-06|  0.00%|                lo = lo + i
   196|        26|  0.000112295|  4.31904e-06|  0.00%|                hi = hi + j
   197|       433|   0.00184727|  4.26621e-06|  0.00%|            elif op in _REPEATCODES:
   198|        62|  0.000860929|   1.3886e-05|  0.00%|                i, j = av[2].getwidth()
(call)|        62|   0.00518918|  8.36965e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:174 getwidth
   199|        62|  0.000285625|  4.60686e-06|  0.00%|                lo = lo + i * av[0]
   200|        62|  0.000289917|  4.67608e-06|  0.00%|                hi = hi + j * av[1]
   201|       371|   0.00157714|  4.25105e-06|  0.00%|            elif op in _UNITCODES:
   202|       367|   0.00154877|  4.22007e-06|  0.00%|                lo = lo + 1
   203|       367|   0.00154042|  4.19734e-06|  0.00%|                hi = hi + 1
   204|         4|  1.69277e-05|  4.23193e-06|  0.00%|            elif op is GROUPREF:
   205|         0|            0|            0|  0.00%|                i, j = self.state.groupwidths[av]
   206|         0|            0|            0|  0.00%|                lo = lo + i
   207|         0|            0|            0|  0.00%|                hi = hi + j
   208|         4|   2.0504e-05|    5.126e-06|  0.00%|            elif op is GROUPREF_EXISTS:
   209|         0|            0|            0|  0.00%|                i, j = av[1].getwidth()
   210|         0|            0|            0|  0.00%|                if av[2] is not None:
   211|         0|            0|            0|  0.00%|                    l, h = av[2].getwidth()
   212|         0|            0|            0|  0.00%|                    i = min(i, l)
   213|         0|            0|            0|  0.00%|                    j = max(j, h)
   214|         0|            0|            0|  0.00%|                else:
   215|         0|            0|            0|  0.00%|                    i = 0
   216|         0|            0|            0|  0.00%|                lo = lo + i
   217|         0|            0|            0|  0.00%|                hi = hi + j
   218|         4|  1.81198e-05|  4.52995e-06|  0.00%|            elif op is SUCCESS:
   219|         0|            0|            0|  0.00%|                break
   220|       280|   0.00248241|  8.86577e-06|  0.00%|        self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
   221|       280|   0.00129604|  4.62873e-06|  0.00%|        return self.width
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|class Tokenizer:
   224|         2|  1.50204e-05|  7.51019e-06|  0.00%|    def __init__(self, string):
   225|         2|  3.00407e-05|  1.50204e-05|  0.00%|        self.istext = isinstance(string, str)
   226|         2|  1.66893e-05|  8.34465e-06|  0.00%|        self.string = string
   227|         2|  9.05991e-06|  4.52995e-06|  0.00%|        if not self.istext:
   228|         0|            0|            0|  0.00%|            string = str(string, 'latin1')
   229|         2|  9.05991e-06|  4.52995e-06|  0.00%|        self.decoded_string = string
   230|         2|  9.29832e-06|  4.64916e-06|  0.00%|        self.index = 0
   231|         2|  1.45435e-05|  7.27177e-06|  0.00%|        self.next = None
   232|         2|  3.79086e-05|  1.89543e-05|  0.00%|        self.__next()
(call)|         2|  7.65324e-05|  3.82662e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:233 __next
   233|       949|   0.00410628|  4.32696e-06|  0.00%|    def __next(self):
   234|       949|   0.00384951|  4.05638e-06|  0.00%|        index = self.index
   235|       949|   0.00352597|  3.71546e-06|  0.00%|        try:
   236|       949|   0.00368595|  3.88404e-06|  0.00%|            char = self.decoded_string[index]
   237|         2|  1.00136e-05|  5.00679e-06|  0.00%|        except IndexError:
   238|         2|  1.19209e-05|  5.96046e-06|  0.00%|            self.next = None
   239|         2|  1.12057e-05|  5.60284e-06|  0.00%|            return
   240|       947|   0.00343561|  3.62789e-06|  0.00%|        if char == "\\":
   241|        67|  0.000232458|  3.46952e-06|  0.00%|            index += 1
   242|        67|  0.000229836|  3.43038e-06|  0.00%|            try:
   243|        67|  0.000266314|  3.97483e-06|  0.00%|                char += self.decoded_string[index]
   244|         0|            0|            0|  0.00%|            except IndexError:
   245|         0|            0|            0|  0.00%|                raise error("bad escape (end of pattern)",
   246|         0|            0|            0|  0.00%|                            self.string, len(self.string) - 1) from None
   247|       947|   0.00353694|  3.73489e-06|  0.00%|        self.index = index + 1
   248|       947|   0.00343156|  3.62361e-06|  0.00%|        self.next = char
   249|       510|   0.00247073|  4.84457e-06|  0.00%|    def match(self, char):
   250|       510|   0.00203896|  3.99795e-06|  0.00%|        if char == self.next:
   251|       280|   0.00322104|  1.15037e-05|  0.00%|            self.__next()
(call)|       280|   0.00789285|  2.81887e-05|  0.01%|# /opt/conda/lib/python3.8/sre_parse.py:233 __next
   252|       280|   0.00101137|  3.61204e-06|  0.00%|            return True
   253|       230|   0.00080657|  3.50683e-06|  0.00%|        return False
   254|       667|   0.00350595|  5.25629e-06|  0.00%|    def get(self):
   255|       667|   0.00267625|  4.01237e-06|  0.00%|        this = self.next
   256|       667|   0.00754929|  1.13183e-05|  0.01%|        self.__next()
(call)|       667|    0.0183642|  2.75325e-05|  0.01%|# /opt/conda/lib/python3.8/sre_parse.py:233 __next
   257|       667|   0.00238824|  3.58057e-06|  0.00%|        return this
   258|         0|            0|            0|  0.00%|    def getwhile(self, n, charset):
   259|         0|            0|            0|  0.00%|        result = ''
   260|         0|            0|            0|  0.00%|        for _ in range(n):
   261|         0|            0|            0|  0.00%|            c = self.next
   262|         0|            0|            0|  0.00%|            if c not in charset:
   263|         0|            0|            0|  0.00%|                break
   264|         0|            0|            0|  0.00%|            result += c
   265|         0|            0|            0|  0.00%|            self.__next()
   266|         0|            0|            0|  0.00%|        return result
   267|         0|            0|            0|  0.00%|    def getuntil(self, terminator, name):
   268|         0|            0|            0|  0.00%|        result = ''
   269|         0|            0|            0|  0.00%|        while True:
   270|         0|            0|            0|  0.00%|            c = self.next
   271|         0|            0|            0|  0.00%|            self.__next()
   272|         0|            0|            0|  0.00%|            if c is None:
   273|         0|            0|            0|  0.00%|                if not result:
   274|         0|            0|            0|  0.00%|                    raise self.error("missing " + name)
   275|         0|            0|            0|  0.00%|                raise self.error("missing %s, unterminated name" % terminator,
   276|         0|            0|            0|  0.00%|                                 len(result))
   277|         0|            0|            0|  0.00%|            if c == terminator:
   278|         0|            0|            0|  0.00%|                if not result:
   279|         0|            0|            0|  0.00%|                    raise self.error("missing " + name, 1)
   280|         0|            0|            0|  0.00%|                break
   281|         0|            0|            0|  0.00%|            result += c
   282|         0|            0|            0|  0.00%|        return result
   283|         0|            0|            0|  0.00%|    @property
   284|         0|            0|            0|  0.00%|    def pos(self):
   285|         0|            0|            0|  0.00%|        return self.index - len(self.next or '')
   286|       214|   0.00106549|  4.97894e-06|  0.00%|    def tell(self):
   287|       214|   0.00130606|  6.10307e-06|  0.00%|        return self.index - len(self.next or '')
   288|         0|            0|            0|  0.00%|    def seek(self, index):
   289|         0|            0|            0|  0.00%|        self.index = index
   290|         0|            0|            0|  0.00%|        self.__next()
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|    def error(self, msg, offset=0):
   293|         0|            0|            0|  0.00%|        return error(msg, self.string, self.tell() - offset)
   294|         0|            0|            0|  0.00%|
   295|        12|  7.82013e-05|  6.51677e-06|  0.00%|def _class_escape(source, escape):
   296|         0|            0|            0|  0.00%|    # handle escape code inside character class
   297|        12|  9.01222e-05|  7.51019e-06|  0.00%|    code = ESCAPES.get(escape)
   298|        12|  5.88894e-05|  4.90745e-06|  0.00%|    if code:
   299|        12|   5.4121e-05|  4.51008e-06|  0.00%|        return code
   300|         0|            0|            0|  0.00%|    code = CATEGORIES.get(escape)
   301|         0|            0|            0|  0.00%|    if code and code[0] is IN:
   302|         0|            0|            0|  0.00%|        return code
   303|         0|            0|            0|  0.00%|    try:
   304|         0|            0|            0|  0.00%|        c = escape[1:2]
   305|         0|            0|            0|  0.00%|        if c == "x":
   306|         0|            0|            0|  0.00%|            # hexadecimal escape (exactly two digits)
   307|         0|            0|            0|  0.00%|            escape += source.getwhile(2, HEXDIGITS)
   308|         0|            0|            0|  0.00%|            if len(escape) != 4:
   309|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   310|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   311|         0|            0|            0|  0.00%|        elif c == "u" and source.istext:
   312|         0|            0|            0|  0.00%|            # unicode escape (exactly four digits)
   313|         0|            0|            0|  0.00%|            escape += source.getwhile(4, HEXDIGITS)
   314|         0|            0|            0|  0.00%|            if len(escape) != 6:
   315|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   316|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   317|         0|            0|            0|  0.00%|        elif c == "U" and source.istext:
   318|         0|            0|            0|  0.00%|            # unicode escape (exactly eight digits)
   319|         0|            0|            0|  0.00%|            escape += source.getwhile(8, HEXDIGITS)
   320|         0|            0|            0|  0.00%|            if len(escape) != 10:
   321|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   322|         0|            0|            0|  0.00%|            c = int(escape[2:], 16)
   323|         0|            0|            0|  0.00%|            chr(c) # raise ValueError for invalid code
   324|         0|            0|            0|  0.00%|            return LITERAL, c
   325|         0|            0|            0|  0.00%|        elif c == "N" and source.istext:
   326|         0|            0|            0|  0.00%|            import unicodedata
   327|         0|            0|            0|  0.00%|            # named unicode escape e.g. \N{EM DASH}
   328|         0|            0|            0|  0.00%|            if not source.match('{'):
   329|         0|            0|            0|  0.00%|                raise source.error("missing {")
   330|         0|            0|            0|  0.00%|            charname = source.getuntil('}', 'character name')
   331|         0|            0|            0|  0.00%|            try:
   332|         0|            0|            0|  0.00%|                c = ord(unicodedata.lookup(charname))
   333|         0|            0|            0|  0.00%|            except KeyError:
   334|         0|            0|            0|  0.00%|                raise source.error("undefined character name %r" % charname,
   335|         0|            0|            0|  0.00%|                                   len(charname) + len(r'\N{}'))
   336|         0|            0|            0|  0.00%|            return LITERAL, c
   337|         0|            0|            0|  0.00%|        elif c in OCTDIGITS:
   338|         0|            0|            0|  0.00%|            # octal escape (up to three digits)
   339|         0|            0|            0|  0.00%|            escape += source.getwhile(2, OCTDIGITS)
   340|         0|            0|            0|  0.00%|            c = int(escape[1:], 8)
   341|         0|            0|            0|  0.00%|            if c > 0o377:
   342|         0|            0|            0|  0.00%|                raise source.error('octal escape value %s outside of '
   343|         0|            0|            0|  0.00%|                                   'range 0-0o377' % escape, len(escape))
   344|         0|            0|            0|  0.00%|            return LITERAL, c
   345|         0|            0|            0|  0.00%|        elif c in DIGITS:
   346|         0|            0|            0|  0.00%|            raise ValueError
   347|         0|            0|            0|  0.00%|        if len(escape) == 2:
   348|         0|            0|            0|  0.00%|            if c in ASCIILETTERS:
   349|         0|            0|            0|  0.00%|                raise source.error('bad escape %s' % escape, len(escape))
   350|         0|            0|            0|  0.00%|            return LITERAL, ord(escape[1])
   351|         0|            0|            0|  0.00%|    except ValueError:
   352|         0|            0|            0|  0.00%|        pass
   353|         0|            0|            0|  0.00%|    raise source.error("bad escape %s" % escape, len(escape))
   354|         0|            0|            0|  0.00%|
   355|        55|   0.00036025|  6.55001e-06|  0.00%|def _escape(source, escape, state):
   356|         0|            0|            0|  0.00%|    # handle escape code in expression
   357|        55|  0.000410557|  7.46467e-06|  0.00%|    code = CATEGORIES.get(escape)
   358|        55|  0.000268936|  4.88975e-06|  0.00%|    if code:
   359|        10|  5.55515e-05|  5.55515e-06|  0.00%|        return code
   360|        45|  0.000351667|  7.81483e-06|  0.00%|    code = ESCAPES.get(escape)
   361|        45|  0.000222921|  4.95381e-06|  0.00%|    if code:
   362|        13|  6.10352e-05|  4.69501e-06|  0.00%|        return code
   363|        32|  0.000143766|   4.4927e-06|  0.00%|    try:
   364|        32|  0.000170231|  5.31971e-06|  0.00%|        c = escape[1:2]
   365|        32|  0.000165939|   5.1856e-06|  0.00%|        if c == "x":
   366|         0|            0|            0|  0.00%|            # hexadecimal escape
   367|         0|            0|            0|  0.00%|            escape += source.getwhile(2, HEXDIGITS)
   368|         0|            0|            0|  0.00%|            if len(escape) != 4:
   369|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   370|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   371|        32|  0.000146866|  4.58956e-06|  0.00%|        elif c == "u" and source.istext:
   372|         0|            0|            0|  0.00%|            # unicode escape (exactly four digits)
   373|         0|            0|            0|  0.00%|            escape += source.getwhile(4, HEXDIGITS)
   374|         0|            0|            0|  0.00%|            if len(escape) != 6:
   375|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   376|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   377|        32|  0.000142097|  4.44055e-06|  0.00%|        elif c == "U" and source.istext:
   378|         0|            0|            0|  0.00%|            # unicode escape (exactly eight digits)
   379|         0|            0|            0|  0.00%|            escape += source.getwhile(8, HEXDIGITS)
   380|         0|            0|            0|  0.00%|            if len(escape) != 10:
   381|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   382|         0|            0|            0|  0.00%|            c = int(escape[2:], 16)
   383|         0|            0|            0|  0.00%|            chr(c) # raise ValueError for invalid code
   384|         0|            0|            0|  0.00%|            return LITERAL, c
   385|        32|  0.000142813|   4.4629e-06|  0.00%|        elif c == "N" and source.istext:
   386|         0|            0|            0|  0.00%|            import unicodedata
   387|         0|            0|            0|  0.00%|            # named unicode escape e.g. \N{EM DASH}
   388|         0|            0|            0|  0.00%|            if not source.match('{'):
   389|         0|            0|            0|  0.00%|                raise source.error("missing {")
   390|         0|            0|            0|  0.00%|            charname = source.getuntil('}', 'character name')
   391|         0|            0|            0|  0.00%|            try:
   392|         0|            0|            0|  0.00%|                c = ord(unicodedata.lookup(charname))
   393|         0|            0|            0|  0.00%|            except KeyError:
   394|         0|            0|            0|  0.00%|                raise source.error("undefined character name %r" % charname,
   395|         0|            0|            0|  0.00%|                                   len(charname) + len(r'\N{}'))
   396|         0|            0|            0|  0.00%|            return LITERAL, c
   397|        32|  0.000156164|  4.88013e-06|  0.00%|        elif c == "0":
   398|         0|            0|            0|  0.00%|            # octal escape
   399|         0|            0|            0|  0.00%|            escape += source.getwhile(2, OCTDIGITS)
   400|         0|            0|            0|  0.00%|            return LITERAL, int(escape[1:], 8)
   401|        32|  0.000154018|  4.81308e-06|  0.00%|        elif c in DIGITS:
   402|         0|            0|            0|  0.00%|            # octal escape *or* decimal group reference (sigh)
   403|         0|            0|            0|  0.00%|            if source.next in DIGITS:
   404|         0|            0|            0|  0.00%|                escape += source.get()
   405|         0|            0|            0|  0.00%|                if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and
   406|         0|            0|            0|  0.00%|                    source.next in OCTDIGITS):
   407|         0|            0|            0|  0.00%|                    # got three octal digits; this is an octal escape
   408|         0|            0|            0|  0.00%|                    escape += source.get()
   409|         0|            0|            0|  0.00%|                    c = int(escape[1:], 8)
   410|         0|            0|            0|  0.00%|                    if c > 0o377:
   411|         0|            0|            0|  0.00%|                        raise source.error('octal escape value %s outside of '
   412|         0|            0|            0|  0.00%|                                           'range 0-0o377' % escape,
   413|         0|            0|            0|  0.00%|                                           len(escape))
   414|         0|            0|            0|  0.00%|                    return LITERAL, c
   415|         0|            0|            0|  0.00%|            # not an octal escape, so this is a group reference
   416|         0|            0|            0|  0.00%|            group = int(escape[1:])
   417|         0|            0|            0|  0.00%|            if group < state.groups:
   418|         0|            0|            0|  0.00%|                if not state.checkgroup(group):
   419|         0|            0|            0|  0.00%|                    raise source.error("cannot refer to an open group",
   420|         0|            0|            0|  0.00%|                                       len(escape))
   421|         0|            0|            0|  0.00%|                state.checklookbehindgroup(group, source)
   422|         0|            0|            0|  0.00%|                return GROUPREF, group
   423|         0|            0|            0|  0.00%|            raise source.error("invalid group reference %d" % group, len(escape) - 1)
   424|        32|    0.0002141|  6.69062e-06|  0.00%|        if len(escape) == 2:
   425|        32|  0.000154734|  4.83543e-06|  0.00%|            if c in ASCIILETTERS:
   426|         0|            0|            0|  0.00%|                raise source.error("bad escape %s" % escape, len(escape))
   427|        32|  0.000228882|  7.15256e-06|  0.00%|            return LITERAL, ord(escape[1])
   428|         0|            0|            0|  0.00%|    except ValueError:
   429|         0|            0|            0|  0.00%|        pass
   430|         0|            0|            0|  0.00%|    raise source.error("bad escape %s" % escape, len(escape))
   431|         0|            0|            0|  0.00%|
   432|        51|  0.000277758|  5.44623e-06|  0.00%|def _uniq(items):
   433|        51|  0.000439644|  8.62047e-06|  0.00%|    return list(dict.fromkeys(items))
   434|         0|            0|            0|  0.00%|
   435|        52|  0.000370264|  7.12046e-06|  0.00%|def _parse_sub(source, state, verbose, nested):
   436|         0|            0|            0|  0.00%|    # parse an alternation: a|b|c
   437|         0|            0|            0|  0.00%|
   438|        52|  0.000298738|  5.74497e-06|  0.00%|    items = []
   439|        52|  0.000293255|  5.63952e-06|  0.00%|    itemsappend = items.append
   440|        52|   0.00027132|   5.2177e-06|  0.00%|    sourcematch = source.match
   441|        52|  0.000696421|  1.33927e-05|  0.00%|    start = source.tell()
(call)|        52|  0.000525951|  1.01144e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:286 tell
   442|         0|            0|            0|  0.00%|    while True:
   443|       442|   0.00638413|  1.44437e-05|  0.00%|        itemsappend(_parse(source, state, verbose, nested + 1,
(call)|       221|     0.275368|   0.00124601|  0.20%|# /opt/conda/lib/python3.8/sre_parse.py:493 _parse
   444|       221|   0.00109768|  4.96687e-06|  0.00%|                           not nested and not items))
   445|       221|    0.0028739|  1.30041e-05|  0.00%|        if not sourcematch("|"):
(call)|       221|   0.00940394|  4.25518e-05|  0.01%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   446|        52|  0.000254869|  4.90134e-06|  0.00%|            break
   447|         0|            0|            0|  0.00%|
   448|        52|  0.000355244|  6.83161e-06|  0.00%|    if len(items) == 1:
   449|        30|  0.000148773|  4.95911e-06|  0.00%|        return items[0]
   450|         0|            0|            0|  0.00%|
   451|        22|  0.000304699|    1.385e-05|  0.00%|    subpattern = SubPattern(state)
(call)|        22|  0.000512838|  2.33108e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:111 __init__
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    # check if all items share a common prefix
   454|         0|            0|            0|  0.00%|    while True:
   455|        22|  0.000112295|  5.10433e-06|  0.00%|        prefix = None
   456|        42|  0.000212193|   5.0522e-06|  0.00%|        for item in items:
   457|        42|  0.000523806|  1.24716e-05|  0.00%|            if not item:
(call)|        42|  0.000405073|   9.6446e-06|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
   458|         4|  1.85966e-05|  4.64916e-06|  0.00%|                break
   459|        38|   0.00019455|  5.11973e-06|  0.00%|            if prefix is None:
   460|        18|   0.00023675|  1.31528e-05|  0.00%|                prefix = item[0]
(call)|        18|  0.000244856|  1.36031e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   461|        20|  0.000248194|  1.24097e-05|  0.00%|            elif item[0] != prefix:
(call)|        20|  0.000267267|  1.33634e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   462|        18|  8.65459e-05|  4.80811e-06|  0.00%|                break
   463|         0|            0|            0|  0.00%|        else:
   464|         0|            0|            0|  0.00%|            # all subitems start with a common "prefix".
   465|         0|            0|            0|  0.00%|            # move it out of the branch
   466|         0|            0|            0|  0.00%|            for item in items:
   467|         0|            0|            0|  0.00%|                del item[0]
   468|         0|            0|            0|  0.00%|            subpattern.append(prefix)
   469|         0|            0|            0|  0.00%|            continue # check next one
   470|         0|            0|            0|  0.00%|        break
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    # check if the branch can be replaced by a character set
   473|        22|  0.000105381|  4.79005e-06|  0.00%|    set = []
   474|        28|  0.000132561|  4.73431e-06|  0.00%|    for item in items:
   475|        27|    0.0003829|  1.41815e-05|  0.00%|        if len(item) != 1:
(call)|        27|  0.000258207|  9.56323e-06|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
   476|        19|  8.82149e-05|  4.64289e-06|  0.00%|            break
   477|         8|  0.000102043|  1.27554e-05|  0.00%|        op, av = item[0]
(call)|         8|  0.000106573|  1.33216e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   478|         8|   3.8147e-05|  4.76837e-06|  0.00%|        if op is LITERAL:
   479|         5|  3.33786e-05|  6.67572e-06|  0.00%|            set.append((op, av))
   480|         3|  1.33514e-05|  4.45048e-06|  0.00%|        elif op is IN and av[0][0] is not NEGATE:
   481|         1|   2.0504e-05|   2.0504e-05|  0.00%|            set.extend(av)
   482|         0|            0|            0|  0.00%|        else:
   483|         2|  8.34465e-06|  4.17233e-06|  0.00%|            break
   484|         0|            0|            0|  0.00%|    else:
   485|         0|            0|            0|  0.00%|        # we can store this as a character set instead of a
   486|         0|            0|            0|  0.00%|        # branch (the compiler may optimize this even more)
   487|         1|  2.88486e-05|  2.88486e-05|  0.00%|        subpattern.append((IN, _uniq(set)))
(call)|         1|  2.76566e-05|  2.76566e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:432 _uniq
(call)|         1|  2.07424e-05|  2.07424e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   488|         1|  1.33514e-05|  1.33514e-05|  0.00%|        return subpattern
   489|         0|            0|            0|  0.00%|
   490|        21|  0.000281811|  1.34196e-05|  0.00%|    subpattern.append((BRANCH, (None, items)))
(call)|        21|  0.000212669|  1.01271e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   491|        21|  9.56059e-05|  4.55266e-06|  0.00%|    return subpattern
   492|         0|            0|            0|  0.00%|
   493|       221|   0.00248027|  1.12229e-05|  0.00%|def _parse(source, state, verbose, nested, first=False):
   494|         0|            0|            0|  0.00%|    # parse a simple pattern
   495|       221|   0.00481343|  2.17802e-05|  0.00%|    subpattern = SubPattern(state)
(call)|       221|   0.00522685|  2.36509e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:111 __init__
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    # precompute constants into local variables
   498|       221|   0.00229478|  1.03836e-05|  0.00%|    subpatternappend = subpattern.append
   499|       221|   0.00220513|  9.97798e-06|  0.00%|    sourceget = source.get
   500|       221|   0.00221372|  1.00168e-05|  0.00%|    sourcematch = source.match
   501|       221|   0.00220966|  9.99848e-06|  0.00%|    _len = len
   502|       221|   0.00217175|  9.82694e-06|  0.00%|    _ord = ord
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    while True:
   505|         0|            0|            0|  0.00%|
   506|       704|   0.00642705|  9.12933e-06|  0.00%|        this = source.next
   507|       704|   0.00625014|  8.87804e-06|  0.00%|        if this is None:
   508|         2|  1.74046e-05|  8.70228e-06|  0.00%|            break # end of pattern
   509|       702|   0.00630999|  8.98858e-06|  0.00%|        if this in "|)":
   510|       219|   0.00200677|  9.16333e-06|  0.00%|            break # end of subpattern
   511|       483|   0.00905538|  1.87482e-05|  0.01%|        sourceget()
(call)|       483|    0.0250084|  5.17773e-05|  0.02%|# /opt/conda/lib/python3.8/sre_parse.py:254 get
   512|         0|            0|            0|  0.00%|
   513|       483|   0.00438643|  9.08163e-06|  0.00%|        if verbose:
   514|         0|            0|            0|  0.00%|            # skip whitespace and comments
   515|         0|            0|            0|  0.00%|            if this in WHITESPACE:
   516|         0|            0|            0|  0.00%|                continue
   517|         0|            0|            0|  0.00%|            if this == "#":
   518|         0|            0|            0|  0.00%|                while True:
   519|         0|            0|            0|  0.00%|                    this = sourceget()
   520|         0|            0|            0|  0.00%|                    if this is None or this == "\n":
   521|         0|            0|            0|  0.00%|                        break
   522|         0|            0|            0|  0.00%|                continue
   523|         0|            0|            0|  0.00%|
   524|       483|   0.00439167|  9.09248e-06|  0.00%|        if this[0] == "\\":
   525|        55|   0.00117946|  2.14447e-05|  0.00%|            code = _escape(source, this, state)
(call)|        55|   0.00355053|  6.45551e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:355 _escape
   526|        55|   0.00107193|  1.94896e-05|  0.00%|            subpatternappend(code)
(call)|        55|  0.000613451|  1.11537e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   527|         0|            0|            0|  0.00%|
   528|       428|   0.00390196|  9.11673e-06|  0.00%|        elif this not in SPECIAL_CHARS:
   529|       261|   0.00551534|  2.11316e-05|  0.00%|            subpatternappend((LITERAL, _ord(this)))
(call)|       261|   0.00294518|  1.12842e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   530|         0|            0|            0|  0.00%|
   531|       167|   0.00146413|  8.76724e-06|  0.00%|        elif this == "[":
   532|        50|  0.000955343|  1.91069e-05|  0.00%|            here = source.tell() - 1
(call)|        50|   0.00057292|  1.14584e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:286 tell
   533|         0|            0|            0|  0.00%|            # character set
   534|        50|  0.000458241|  9.16481e-06|  0.00%|            set = []
   535|        50|  0.000478983|  9.57966e-06|  0.00%|            setappend = set.append
   536|         0|            0|            0|  0.00%|##          if sourcematch(":"):
   537|         0|            0|            0|  0.00%|##              pass # handle character classes
   538|        50|  0.000462055|   9.2411e-06|  0.00%|            if source.next == '[':
   539|         0|            0|            0|  0.00%|                import warnings
   540|         0|            0|            0|  0.00%|                warnings.warn(
   541|         0|            0|            0|  0.00%|                    'Possible nested set at position %d' % source.tell(),
   542|         0|            0|            0|  0.00%|                    FutureWarning, stacklevel=nested + 6
   543|         0|            0|            0|  0.00%|                )
   544|        50|  0.000937939|  1.87588e-05|  0.00%|            negate = sourcematch("^")
(call)|        50|  0.000870943|  1.74189e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   545|         0|            0|            0|  0.00%|            # check remaining characters
   546|         0|            0|            0|  0.00%|            while True:
   547|       127|   0.00237489|  1.86999e-05|  0.00%|                this = sourceget()
(call)|       127|   0.00652409|  5.13708e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:254 get
   548|       127|   0.00111222|  8.75766e-06|  0.00%|                if this is None:
   549|         0|            0|            0|  0.00%|                    raise source.error("unterminated character set",
   550|         0|            0|            0|  0.00%|                                       source.tell() - here)
   551|       127|   0.00108433|  8.53801e-06|  0.00%|                if this == "]" and set:
   552|        50|  0.000413418|  8.26836e-06|  0.00%|                    break
   553|        77|  0.000670671|  8.71002e-06|  0.00%|                elif this[0] == "\\":
   554|        12|  0.000270844|  2.25703e-05|  0.00%|                    code1 = _class_escape(source, this)
(call)|        12|  0.000281334|  2.34445e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:295 _class_escape
   555|         0|            0|            0|  0.00%|                else:
   556|        65|  0.000563622|   8.6711e-06|  0.00%|                    if set and this in '-&~|' and source.next == this:
   557|         0|            0|            0|  0.00%|                        import warnings
   558|         0|            0|            0|  0.00%|                        warnings.warn(
   559|         0|            0|            0|  0.00%|                            'Possible set %s at position %d' % (
   560|         0|            0|            0|  0.00%|                                'difference' if this == '-' else
   561|         0|            0|            0|  0.00%|                                'intersection' if this == '&' else
   562|         0|            0|            0|  0.00%|                                'symmetric difference' if this == '~' else
   563|         0|            0|            0|  0.00%|                                'union',
   564|         0|            0|            0|  0.00%|                                source.tell() - 1),
   565|         0|            0|            0|  0.00%|                            FutureWarning, stacklevel=nested + 6
   566|         0|            0|            0|  0.00%|                        )
   567|        65|  0.000716209|  1.10186e-05|  0.00%|                    code1 = LITERAL, _ord(this)
   568|        77|   0.00144529|    1.877e-05|  0.00%|                if sourcematch("-"):
(call)|        77|   0.00222373|  2.88796e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   569|         0|            0|            0|  0.00%|                    # potential range
   570|        32|  0.000601768|  1.88053e-05|  0.00%|                    that = sourceget()
(call)|        32|   0.00166178|  5.19305e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:254 get
   571|        32|  0.000295401|  9.23127e-06|  0.00%|                    if that is None:
   572|         0|            0|            0|  0.00%|                        raise source.error("unterminated character set",
   573|         0|            0|            0|  0.00%|                                           source.tell() - here)
   574|        32|  0.000294924|  9.21637e-06|  0.00%|                    if that == "]":
   575|         0|            0|            0|  0.00%|                        if code1[0] is IN:
   576|         0|            0|            0|  0.00%|                            code1 = code1[1][0]
   577|         0|            0|            0|  0.00%|                        setappend(code1)
   578|         0|            0|            0|  0.00%|                        setappend((LITERAL, _ord("-")))
   579|         0|            0|            0|  0.00%|                        break
   580|        32|  0.000289202|  9.03755e-06|  0.00%|                    if that[0] == "\\":
   581|         0|            0|            0|  0.00%|                        code2 = _class_escape(source, that)
   582|         0|            0|            0|  0.00%|                    else:
   583|        32|  0.000287771|  8.99285e-06|  0.00%|                        if that == '-':
   584|         0|            0|            0|  0.00%|                            import warnings
   585|         0|            0|            0|  0.00%|                            warnings.warn(
   586|         0|            0|            0|  0.00%|                                'Possible set difference at position %d' % (
   587|         0|            0|            0|  0.00%|                                    source.tell() - 2),
   588|         0|            0|            0|  0.00%|                                FutureWarning, stacklevel=nested + 6
   589|         0|            0|            0|  0.00%|                            )
   590|        32|  0.000367165|  1.14739e-05|  0.00%|                        code2 = LITERAL, _ord(that)
   591|        32|  0.000306606|  9.58145e-06|  0.00%|                    if code1[0] != LITERAL or code2[0] != LITERAL:
   592|         0|            0|            0|  0.00%|                        msg = "bad character range %s-%s" % (this, that)
   593|         0|            0|            0|  0.00%|                        raise source.error(msg, len(this) + 1 + len(that))
   594|        32|  0.000284195|  8.88109e-06|  0.00%|                    lo = code1[1]
   595|        32|  0.000276089|  8.62777e-06|  0.00%|                    hi = code2[1]
   596|        32|  0.000272512|  8.51601e-06|  0.00%|                    if hi < lo:
   597|         0|            0|            0|  0.00%|                        msg = "bad character range %s-%s" % (this, that)
   598|         0|            0|            0|  0.00%|                        raise source.error(msg, len(this) + 1 + len(that))
   599|        32|  0.000359535|  1.12355e-05|  0.00%|                    setappend((RANGE, (lo, hi)))
   600|         0|            0|            0|  0.00%|                else:
   601|        45|  0.000416756|  9.26124e-06|  0.00%|                    if code1[0] is IN:
   602|         0|            0|            0|  0.00%|                        code1 = code1[1][0]
   603|        45|  0.000477314|   1.0607e-05|  0.00%|                    setappend(code1)
   604|         0|            0|            0|  0.00%|
   605|        50|  0.000994682|  1.98936e-05|  0.00%|            set = _uniq(set)
(call)|        50|  0.000689745|  1.37949e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:432 _uniq
   606|         0|            0|            0|  0.00%|            # XXX: <fl> should move set optimization to compiler!
   607|        50|  0.000556231|  1.11246e-05|  0.00%|            if _len(set) == 1 and set[0][0] is LITERAL:
   608|         0|            0|            0|  0.00%|                # optimization
   609|         0|            0|            0|  0.00%|                if negate:
   610|         0|            0|            0|  0.00%|                    subpatternappend((NOT_LITERAL, set[0][1]))
   611|         0|            0|            0|  0.00%|                else:
   612|         0|            0|            0|  0.00%|                    subpatternappend(set[0])
   613|         0|            0|            0|  0.00%|            else:
   614|        50|   0.00043273|  8.65459e-06|  0.00%|                if negate:
   615|         5|  5.96046e-05|  1.19209e-05|  0.00%|                    set.insert(0, (NEGATE, None))
   616|         0|            0|            0|  0.00%|                # charmap optimization can't be added here because
   617|         0|            0|            0|  0.00%|                # global flags still are not known
   618|        50|  0.000943899|   1.8878e-05|  0.00%|                subpatternappend((IN, set))
(call)|        50|  0.000596046|  1.19209e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   619|         0|            0|            0|  0.00%|
   620|       117|   0.00103426|  8.83983e-06|  0.00%|        elif this in REPEAT_CHARS:
   621|         0|            0|            0|  0.00%|            # repeat previous item
   622|        62|    0.0011754|  1.89581e-05|  0.00%|            here = source.tell()
(call)|        62|  0.000699997|  1.12903e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:286 tell
   623|        62|  0.000555515|  8.95992e-06|  0.00%|            if this == "?":
   624|        30|  0.000278473|  9.28243e-06|  0.00%|                min, max = 0, 1
   625|        32|  0.000271082|  8.47131e-06|  0.00%|            elif this == "*":
   626|        27|  0.000228882|  8.47711e-06|  0.00%|                min, max = 0, MAXREPEAT
   627|         0|            0|            0|  0.00%|
   628|         5|  4.29153e-05|  8.58307e-06|  0.00%|            elif this == "+":
   629|         5|  4.79221e-05|  9.58443e-06|  0.00%|                min, max = 1, MAXREPEAT
   630|         0|            0|            0|  0.00%|            elif this == "{":
   631|         0|            0|            0|  0.00%|                if source.next == "}":
   632|         0|            0|            0|  0.00%|                    subpatternappend((LITERAL, _ord(this)))
   633|         0|            0|            0|  0.00%|                    continue
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|                min, max = 0, MAXREPEAT
   636|         0|            0|            0|  0.00%|                lo = hi = ""
   637|         0|            0|            0|  0.00%|                while source.next in DIGITS:
   638|         0|            0|            0|  0.00%|                    lo += sourceget()
   639|         0|            0|            0|  0.00%|                if sourcematch(","):
   640|         0|            0|            0|  0.00%|                    while source.next in DIGITS:
   641|         0|            0|            0|  0.00%|                        hi += sourceget()
   642|         0|            0|            0|  0.00%|                else:
   643|         0|            0|            0|  0.00%|                    hi = lo
   644|         0|            0|            0|  0.00%|                if not sourcematch("}"):
   645|         0|            0|            0|  0.00%|                    subpatternappend((LITERAL, _ord(this)))
   646|         0|            0|            0|  0.00%|                    source.seek(here)
   647|         0|            0|            0|  0.00%|                    continue
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|                if lo:
   650|         0|            0|            0|  0.00%|                    min = int(lo)
   651|         0|            0|            0|  0.00%|                    if min >= MAXREPEAT:
   652|         0|            0|            0|  0.00%|                        raise OverflowError("the repetition number is too large")
   653|         0|            0|            0|  0.00%|                if hi:
   654|         0|            0|            0|  0.00%|                    max = int(hi)
   655|         0|            0|            0|  0.00%|                    if max >= MAXREPEAT:
   656|         0|            0|            0|  0.00%|                        raise OverflowError("the repetition number is too large")
   657|         0|            0|            0|  0.00%|                    if max < min:
   658|         0|            0|            0|  0.00%|                        raise source.error("min repeat greater than max repeat",
   659|         0|            0|            0|  0.00%|                                           source.tell() - here)
   660|         0|            0|            0|  0.00%|            else:
   661|         0|            0|            0|  0.00%|                raise AssertionError("unsupported quantifier %r" % (char,))
   662|         0|            0|            0|  0.00%|            # figure out which item to repeat
   663|        62|   0.00117064|  1.88812e-05|  0.00%|            if subpattern:
(call)|        62|  0.000674248|   1.0875e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
   664|        62|   0.00122881|  1.98195e-05|  0.00%|                item = subpattern[-1:]
(call)|        62|   0.00277162|  4.47035e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   665|         0|            0|            0|  0.00%|            else:
   666|         0|            0|            0|  0.00%|                item = None
   667|        62|   0.00181556|  2.92832e-05|  0.00%|            if not item or item[0][0] is AT:
(call)|        62|  0.000659943|  1.06442e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
(call)|        62|  0.000900507|  1.45243e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   668|         0|            0|            0|  0.00%|                raise source.error("nothing to repeat",
   669|         0|            0|            0|  0.00%|                                   source.tell() - here + len(this))
   670|        62|   0.00120401|  1.94196e-05|  0.00%|            if item[0][0] in _REPEATCODES:
(call)|        62|  0.000893593|  1.44128e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   671|         0|            0|            0|  0.00%|                raise source.error("multiple repeat",
   672|         0|            0|            0|  0.00%|                                   source.tell() - here + len(this))
   673|        62|   0.00117898|  1.90158e-05|  0.00%|            if item[0][0] is SUBPATTERN:
(call)|        62|   0.00088954|  1.43474e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   674|        24|   0.00043869|  1.82788e-05|  0.00%|                group, add_flags, del_flags, p = item[0][1]
(call)|        24|  0.000344276|  1.43449e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   675|        24|  0.000207663|  8.65261e-06|  0.00%|                if group is None and not add_flags and not del_flags:
   676|        22|  0.000188589|  8.57223e-06|  0.00%|                    item = p
   677|        62|   0.00115252|   1.8589e-05|  0.00%|            if sourcematch("?"):
(call)|        62|  0.000779152|   1.2567e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   678|         0|            0|            0|  0.00%|                subpattern[-1] = (MIN_REPEAT, (min, max, item))
   679|         0|            0|            0|  0.00%|            else:
   680|        62|   0.00117779|  1.89966e-05|  0.00%|                subpattern[-1] = (MAX_REPEAT, (min, max, item))
(call)|        62|  0.000588417|   9.4906e-06|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:168 __setitem__
   681|         0|            0|            0|  0.00%|
   682|        55|  0.000488997|  8.89085e-06|  0.00%|        elif this == ".":
   683|         3|  6.03199e-05|  2.01066e-05|  0.00%|            subpatternappend((ANY, None))
(call)|         3|   3.3617e-05|  1.12057e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   684|         0|            0|            0|  0.00%|
   685|        52|  0.000472307|  9.08283e-06|  0.00%|        elif this == "(":
   686|        50|  0.000963688|  1.92738e-05|  0.00%|            start = source.tell() - 1
(call)|        50|  0.000572681|  1.14536e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:286 tell
   687|        50|  0.000461817|  9.23634e-06|  0.00%|            group = True
   688|        50|  0.000442505|   8.8501e-06|  0.00%|            name = None
   689|        50|  0.000440836|  8.81672e-06|  0.00%|            add_flags = 0
   690|        50|  0.000437737|  8.75473e-06|  0.00%|            del_flags = 0
   691|        50|  0.000938654|  1.87731e-05|  0.00%|            if sourcematch("?"):
(call)|        50|   0.00154781|  3.09563e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   692|         0|            0|            0|  0.00%|                # options
   693|        24|  0.000454426|  1.89344e-05|  0.00%|                char = sourceget()
(call)|        24|   0.00122738|  5.11408e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:254 get
   694|        24|  0.000211716|  8.82149e-06|  0.00%|                if char is None:
   695|         0|            0|            0|  0.00%|                    raise source.error("unexpected end of pattern")
   696|        24|  0.000213623|  8.90096e-06|  0.00%|                if char == "P":
   697|         0|            0|            0|  0.00%|                    # python extensions
   698|         0|            0|            0|  0.00%|                    if sourcematch("<"):
   699|         0|            0|            0|  0.00%|                        # named group: skip forward to end of name
   700|         0|            0|            0|  0.00%|                        name = source.getuntil(">", "group name")
   701|         0|            0|            0|  0.00%|                        if not name.isidentifier():
   702|         0|            0|            0|  0.00%|                            msg = "bad character in group name %r" % name
   703|         0|            0|            0|  0.00%|                            raise source.error(msg, len(name) + 1)
   704|         0|            0|            0|  0.00%|                    elif sourcematch("="):
   705|         0|            0|            0|  0.00%|                        # named backreference
   706|         0|            0|            0|  0.00%|                        name = source.getuntil(")", "group name")
   707|         0|            0|            0|  0.00%|                        if not name.isidentifier():
   708|         0|            0|            0|  0.00%|                            msg = "bad character in group name %r" % name
   709|         0|            0|            0|  0.00%|                            raise source.error(msg, len(name) + 1)
   710|         0|            0|            0|  0.00%|                        gid = state.groupdict.get(name)
   711|         0|            0|            0|  0.00%|                        if gid is None:
   712|         0|            0|            0|  0.00%|                            msg = "unknown group name %r" % name
   713|         0|            0|            0|  0.00%|                            raise source.error(msg, len(name) + 1)
   714|         0|            0|            0|  0.00%|                        if not state.checkgroup(gid):
   715|         0|            0|            0|  0.00%|                            raise source.error("cannot refer to an open group",
   716|         0|            0|            0|  0.00%|                                               len(name) + 1)
   717|         0|            0|            0|  0.00%|                        state.checklookbehindgroup(gid, source)
   718|         0|            0|            0|  0.00%|                        subpatternappend((GROUPREF, gid))
   719|         0|            0|            0|  0.00%|                        continue
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|                    else:
   722|         0|            0|            0|  0.00%|                        char = sourceget()
   723|         0|            0|            0|  0.00%|                        if char is None:
   724|         0|            0|            0|  0.00%|                            raise source.error("unexpected end of pattern")
   725|         0|            0|            0|  0.00%|                        raise source.error("unknown extension ?P" + char,
   726|         0|            0|            0|  0.00%|                                           len(char) + 2)
   727|        24|  0.000200272|  8.34465e-06|  0.00%|                elif char == ":":
   728|         0|            0|            0|  0.00%|                    # non-capturing group
   729|        23|  0.000190973|  8.30319e-06|  0.00%|                    group = None
   730|         1|  1.12057e-05|  1.12057e-05|  0.00%|                elif char == "#":
   731|         0|            0|            0|  0.00%|                    # comment
   732|         0|            0|            0|  0.00%|                    while True:
   733|         0|            0|            0|  0.00%|                        if source.next is None:
   734|         0|            0|            0|  0.00%|                            raise source.error("missing ), unterminated comment",
   735|         0|            0|            0|  0.00%|                                               source.tell() - start)
   736|         0|            0|            0|  0.00%|                        if sourceget() == ")":
   737|         0|            0|            0|  0.00%|                            break
   738|         0|            0|            0|  0.00%|                    continue
   739|         0|            0|            0|  0.00%|
   740|         1|  1.14441e-05|  1.14441e-05|  0.00%|                elif char in "=!<":
   741|         0|            0|            0|  0.00%|                    # lookahead assertions
   742|         1|  1.12057e-05|  1.12057e-05|  0.00%|                    dir = 1
   743|         1|  1.09673e-05|  1.09673e-05|  0.00%|                    if char == "<":
   744|         1|  2.36034e-05|  2.36034e-05|  0.00%|                        char = sourceget()
(call)|         1|  6.22272e-05|  6.22272e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:254 get
   745|         1|  1.23978e-05|  1.23978e-05|  0.00%|                        if char is None:
   746|         0|            0|            0|  0.00%|                            raise source.error("unexpected end of pattern")
   747|         1|  1.09673e-05|  1.09673e-05|  0.00%|                        if char not in "=!":
   748|         0|            0|            0|  0.00%|                            raise source.error("unknown extension ?<" + char,
   749|         0|            0|            0|  0.00%|                                               len(char) + 2)
   750|         1|  1.12057e-05|  1.12057e-05|  0.00%|                        dir = -1 # lookbehind
   751|         1|  1.12057e-05|  1.12057e-05|  0.00%|                        lookbehindgroups = state.lookbehindgroups
   752|         1|  1.16825e-05|  1.16825e-05|  0.00%|                        if lookbehindgroups is None:
   753|         1|   3.8147e-05|   3.8147e-05|  0.00%|                            state.lookbehindgroups = state.groups
(call)|         1|   1.4782e-05|   1.4782e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:81 groups
   754|         1|  2.76566e-05|  2.76566e-05|  0.00%|                    p = _parse_sub(source, state, verbose, nested + 1)
(call)|         1|  0.000567913|  0.000567913|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:435 _parse_sub
   755|         1|   1.3113e-05|   1.3113e-05|  0.00%|                    if dir < 0:
   756|         1|  1.12057e-05|  1.12057e-05|  0.00%|                        if lookbehindgroups is None:
   757|         1|  1.16825e-05|  1.16825e-05|  0.00%|                            state.lookbehindgroups = None
   758|         1|   2.6226e-05|   2.6226e-05|  0.00%|                    if not sourcematch(")"):
(call)|         1|  6.05583e-05|  6.05583e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   759|         0|            0|            0|  0.00%|                        raise source.error("missing ), unterminated subpattern",
   760|         0|            0|            0|  0.00%|                                           source.tell() - start)
   761|         1|  1.26362e-05|  1.26362e-05|  0.00%|                    if char == "=":
   762|         0|            0|            0|  0.00%|                        subpatternappend((ASSERT, (dir, p)))
   763|         0|            0|            0|  0.00%|                    else:
   764|         1|  2.40803e-05|  2.40803e-05|  0.00%|                        subpatternappend((ASSERT_NOT, (dir, p)))
(call)|         1|  1.16825e-05|  1.16825e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   765|         1|  1.12057e-05|  1.12057e-05|  0.00%|                    continue
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|                elif char == "(":
   768|         0|            0|            0|  0.00%|                    # conditional backreference group
   769|         0|            0|            0|  0.00%|                    condname = source.getuntil(")", "group name")
   770|         0|            0|            0|  0.00%|                    if condname.isidentifier():
   771|         0|            0|            0|  0.00%|                        condgroup = state.groupdict.get(condname)
   772|         0|            0|            0|  0.00%|                        if condgroup is None:
   773|         0|            0|            0|  0.00%|                            msg = "unknown group name %r" % condname
   774|         0|            0|            0|  0.00%|                            raise source.error(msg, len(condname) + 1)
   775|         0|            0|            0|  0.00%|                    else:
   776|         0|            0|            0|  0.00%|                        try:
   777|         0|            0|            0|  0.00%|                            condgroup = int(condname)
   778|         0|            0|            0|  0.00%|                            if condgroup < 0:
   779|         0|            0|            0|  0.00%|                                raise ValueError
   780|         0|            0|            0|  0.00%|                        except ValueError:
   781|         0|            0|            0|  0.00%|                            msg = "bad character in group name %r" % condname
   782|         0|            0|            0|  0.00%|                            raise source.error(msg, len(condname) + 1) from None
   783|         0|            0|            0|  0.00%|                        if not condgroup:
   784|         0|            0|            0|  0.00%|                            raise source.error("bad group number",
   785|         0|            0|            0|  0.00%|                                               len(condname) + 1)
   786|         0|            0|            0|  0.00%|                        if condgroup >= MAXGROUPS:
   787|         0|            0|            0|  0.00%|                            msg = "invalid group reference %d" % condgroup
   788|         0|            0|            0|  0.00%|                            raise source.error(msg, len(condname) + 1)
   789|         0|            0|            0|  0.00%|                    state.checklookbehindgroup(condgroup, source)
   790|         0|            0|            0|  0.00%|                    item_yes = _parse(source, state, verbose, nested + 1)
   791|         0|            0|            0|  0.00%|                    if source.match("|"):
   792|         0|            0|            0|  0.00%|                        item_no = _parse(source, state, verbose, nested + 1)
   793|         0|            0|            0|  0.00%|                        if source.next == "|":
   794|         0|            0|            0|  0.00%|                            raise source.error("conditional backref with more than two branches")
   795|         0|            0|            0|  0.00%|                    else:
   796|         0|            0|            0|  0.00%|                        item_no = None
   797|         0|            0|            0|  0.00%|                    if not source.match(")"):
   798|         0|            0|            0|  0.00%|                        raise source.error("missing ), unterminated subpattern",
   799|         0|            0|            0|  0.00%|                                           source.tell() - start)
   800|         0|            0|            0|  0.00%|                    subpatternappend((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))
   801|         0|            0|            0|  0.00%|                    continue
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|                elif char in FLAGS or char == "-":
   804|         0|            0|            0|  0.00%|                    # flags
   805|         0|            0|            0|  0.00%|                    flags = _parse_flags(source, state, char)
   806|         0|            0|            0|  0.00%|                    if flags is None:  # global flags
   807|         0|            0|            0|  0.00%|                        if not first or subpattern:
   808|         0|            0|            0|  0.00%|                            import warnings
   809|         0|            0|            0|  0.00%|                            warnings.warn(
   810|         0|            0|            0|  0.00%|                                'Flags not at the start of the expression %r%s' % (
   811|         0|            0|            0|  0.00%|                                    source.string[:20],  # truncate long regexes
   812|         0|            0|            0|  0.00%|                                    ' (truncated)' if len(source.string) > 20 else '',
   813|         0|            0|            0|  0.00%|                                ),
   814|         0|            0|            0|  0.00%|                                DeprecationWarning, stacklevel=nested + 6
   815|         0|            0|            0|  0.00%|                            )
   816|         0|            0|            0|  0.00%|                        if (state.flags & SRE_FLAG_VERBOSE) and not verbose:
   817|         0|            0|            0|  0.00%|                            raise Verbose
   818|         0|            0|            0|  0.00%|                        continue
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|                    add_flags, del_flags = flags
   821|         0|            0|            0|  0.00%|                    group = None
   822|         0|            0|            0|  0.00%|                else:
   823|         0|            0|            0|  0.00%|                    raise source.error("unknown extension ?" + char,
   824|         0|            0|            0|  0.00%|                                       len(char) + 1)
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|            # parse group contents
   827|        49|  0.000447512|  9.13289e-06|  0.00%|            if group is not None:
   828|        26|  0.000237465|  9.13327e-06|  0.00%|                try:
   829|        26|  0.000582457|  2.24022e-05|  0.00%|                    group = state.opengroup(name)
(call)|        26|   0.00166512|  6.40429e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:84 opengroup
   830|         0|            0|            0|  0.00%|                except error as err:
   831|         0|            0|            0|  0.00%|                    raise source.error(err.msg, len(name) + 1) from None
   832|        98|  0.000904799|  9.23264e-06|  0.00%|            sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and
   833|         0|            0|            0|  0.00%|                           not (del_flags & SRE_FLAG_VERBOSE))
   834|        49|   0.00106621|  2.17593e-05|  0.00%|            p = _parse_sub(source, state, sub_verbose, nested + 1)
(call)|        49|     0.265881|   0.00542613|  0.19%|# /opt/conda/lib/python3.8/sre_parse.py:435 _parse_sub
   835|        49|  0.000969172|   1.9779e-05|  0.00%|            if not source.match(")"):
(call)|        49|   0.00255537|  5.21504e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:249 match
   836|         0|            0|            0|  0.00%|                raise source.error("missing ), unterminated subpattern",
   837|         0|            0|            0|  0.00%|                                   source.tell() - start)
   838|        49|  0.000451326|  9.21074e-06|  0.00%|            if group is not None:
   839|        26|  0.000545263|  2.09717e-05|  0.00%|                state.closegroup(group, p)
(call)|        26|    0.0317452|   0.00122097|  0.02%|# /opt/conda/lib/python3.8/sre_parse.py:96 closegroup
   840|        49|  0.000945568|  1.92973e-05|  0.00%|            subpatternappend((SUBPATTERN, (group, add_flags, del_flags, p)))
(call)|        49|  0.000551939|  1.12641e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   841|         0|            0|            0|  0.00%|
   842|         2|  2.19345e-05|  1.09673e-05|  0.00%|        elif this == "^":
   843|         2|  5.55515e-05|  2.77758e-05|  0.00%|            subpatternappend((AT, AT_BEGINNING))
(call)|         2|  3.74317e-05|  1.87159e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:172 append
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|        elif this == "$":
   846|         0|            0|            0|  0.00%|            subpatternappend((AT, AT_END))
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|        else:
   849|         0|            0|            0|  0.00%|            raise AssertionError("unsupported special character %r" % (char,))
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|    # unpack non-capturing groups
   852|       642|   0.00898027|   1.3988e-05|  0.01%|    for i in range(len(subpattern))[::-1]:
(call)|       221|   0.00236273|  1.06911e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
   853|       421|   0.00815058|    1.936e-05|  0.01%|        op, av = subpattern[i]
(call)|       421|   0.00622272|  1.47808e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   854|       421|   0.00393343|  9.34306e-06|  0.00%|        if op is SUBPATTERN:
   855|        25|  0.000219822|  8.79288e-06|  0.00%|            group, add_flags, del_flags, p = av
   856|        25|  0.000216484|  8.65936e-06|  0.00%|            if group is None and not add_flags and not del_flags:
   857|         1|  2.21729e-05|  2.21729e-05|  0.00%|                subpattern[i: i+1] = p
(call)|         1|  8.27312e-05|  8.27312e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:168 __setitem__
   858|         0|            0|            0|  0.00%|
   859|       221|   0.00190091|  8.60141e-06|  0.00%|    return subpattern
   860|         0|            0|            0|  0.00%|
   861|         0|            0|            0|  0.00%|def _parse_flags(source, state, char):
   862|         0|            0|            0|  0.00%|    sourceget = source.get
   863|         0|            0|            0|  0.00%|    add_flags = 0
   864|         0|            0|            0|  0.00%|    del_flags = 0
   865|         0|            0|            0|  0.00%|    if char != "-":
   866|         0|            0|            0|  0.00%|        while True:
   867|         0|            0|            0|  0.00%|            flag = FLAGS[char]
   868|         0|            0|            0|  0.00%|            if source.istext:
   869|         0|            0|            0|  0.00%|                if char == 'L':
   870|         0|            0|            0|  0.00%|                    msg = "bad inline flags: cannot use 'L' flag with a str pattern"
   871|         0|            0|            0|  0.00%|                    raise source.error(msg)
   872|         0|            0|            0|  0.00%|            else:
   873|         0|            0|            0|  0.00%|                if char == 'u':
   874|         0|            0|            0|  0.00%|                    msg = "bad inline flags: cannot use 'u' flag with a bytes pattern"
   875|         0|            0|            0|  0.00%|                    raise source.error(msg)
   876|         0|            0|            0|  0.00%|            add_flags |= flag
   877|         0|            0|            0|  0.00%|            if (flag & TYPE_FLAGS) and (add_flags & TYPE_FLAGS) != flag:
   878|         0|            0|            0|  0.00%|                msg = "bad inline flags: flags 'a', 'u' and 'L' are incompatible"
   879|         0|            0|            0|  0.00%|                raise source.error(msg)
   880|         0|            0|            0|  0.00%|            char = sourceget()
   881|         0|            0|            0|  0.00%|            if char is None:
   882|         0|            0|            0|  0.00%|                raise source.error("missing -, : or )")
   883|         0|            0|            0|  0.00%|            if char in ")-:":
   884|         0|            0|            0|  0.00%|                break
   885|         0|            0|            0|  0.00%|            if char not in FLAGS:
   886|         0|            0|            0|  0.00%|                msg = "unknown flag" if char.isalpha() else "missing -, : or )"
   887|         0|            0|            0|  0.00%|                raise source.error(msg, len(char))
   888|         0|            0|            0|  0.00%|    if char == ")":
   889|         0|            0|            0|  0.00%|        state.flags |= add_flags
   890|         0|            0|            0|  0.00%|        return None
   891|         0|            0|            0|  0.00%|    if add_flags & GLOBAL_FLAGS:
   892|         0|            0|            0|  0.00%|        raise source.error("bad inline flags: cannot turn on global flag", 1)
   893|         0|            0|            0|  0.00%|    if char == "-":
   894|         0|            0|            0|  0.00%|        char = sourceget()
   895|         0|            0|            0|  0.00%|        if char is None:
   896|         0|            0|            0|  0.00%|            raise source.error("missing flag")
   897|         0|            0|            0|  0.00%|        if char not in FLAGS:
   898|         0|            0|            0|  0.00%|            msg = "unknown flag" if char.isalpha() else "missing flag"
   899|         0|            0|            0|  0.00%|            raise source.error(msg, len(char))
   900|         0|            0|            0|  0.00%|        while True:
   901|         0|            0|            0|  0.00%|            flag = FLAGS[char]
   902|         0|            0|            0|  0.00%|            if flag & TYPE_FLAGS:
   903|         0|            0|            0|  0.00%|                msg = "bad inline flags: cannot turn off flags 'a', 'u' and 'L'"
   904|         0|            0|            0|  0.00%|                raise source.error(msg)
   905|         0|            0|            0|  0.00%|            del_flags |= flag
   906|         0|            0|            0|  0.00%|            char = sourceget()
   907|         0|            0|            0|  0.00%|            if char is None:
   908|         0|            0|            0|  0.00%|                raise source.error("missing :")
   909|         0|            0|            0|  0.00%|            if char == ":":
   910|         0|            0|            0|  0.00%|                break
   911|         0|            0|            0|  0.00%|            if char not in FLAGS:
   912|         0|            0|            0|  0.00%|                msg = "unknown flag" if char.isalpha() else "missing :"
   913|         0|            0|            0|  0.00%|                raise source.error(msg, len(char))
   914|         0|            0|            0|  0.00%|    assert char == ":"
   915|         0|            0|            0|  0.00%|    if del_flags & GLOBAL_FLAGS:
   916|         0|            0|            0|  0.00%|        raise source.error("bad inline flags: cannot turn off global flag", 1)
   917|         0|            0|            0|  0.00%|    if add_flags & del_flags:
   918|         0|            0|            0|  0.00%|        raise source.error("bad inline flags: flag turned on and off", 1)
   919|         0|            0|            0|  0.00%|    return add_flags, del_flags
   920|         0|            0|            0|  0.00%|
   921|         2|  1.21593e-05|  6.07967e-06|  0.00%|def fix_flags(src, flags):
   922|         0|            0|            0|  0.00%|    # Check and fix flags according to the type of pattern (str or bytes)
   923|         2|  1.45435e-05|  7.27177e-06|  0.00%|    if isinstance(src, str):
   924|         2|  1.00136e-05|  5.00679e-06|  0.00%|        if flags & SRE_FLAG_LOCALE:
   925|         0|            0|            0|  0.00%|            raise ValueError("cannot use LOCALE flag with a str pattern")
   926|         2|  9.53674e-06|  4.76837e-06|  0.00%|        if not flags & SRE_FLAG_ASCII:
   927|         2|   1.0252e-05|    5.126e-06|  0.00%|            flags |= SRE_FLAG_UNICODE
   928|         0|            0|            0|  0.00%|        elif flags & SRE_FLAG_UNICODE:
   929|         0|            0|            0|  0.00%|            raise ValueError("ASCII and UNICODE flags are incompatible")
   930|         0|            0|            0|  0.00%|    else:
   931|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_UNICODE:
   932|         0|            0|            0|  0.00%|            raise ValueError("cannot use UNICODE flag with a bytes pattern")
   933|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_LOCALE and flags & SRE_FLAG_ASCII:
   934|         0|            0|            0|  0.00%|            raise ValueError("ASCII and LOCALE flags are incompatible")
   935|         2|  8.82149e-06|  4.41074e-06|  0.00%|    return flags
   936|         0|            0|            0|  0.00%|
   937|         2|  1.64509e-05|  8.22544e-06|  0.00%|def parse(str, flags=0, state=None):
   938|         0|            0|            0|  0.00%|    # parse 're' pattern into list of (opcode, argument) tuples
   939|         0|            0|            0|  0.00%|
   940|         2|  5.07832e-05|  2.53916e-05|  0.00%|    source = Tokenizer(str)
(call)|         2|  0.000218153|  0.000109076|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:224 __init__
   941|         0|            0|            0|  0.00%|
   942|         2|  1.04904e-05|  5.24521e-06|  0.00%|    if state is None:
   943|         2|   4.3869e-05|  2.19345e-05|  0.00%|        state = State()
(call)|         2|  5.00679e-05|   2.5034e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:76 __init__
   944|         2|  1.07288e-05|  5.36442e-06|  0.00%|    state.flags = flags
   945|         2|  1.00136e-05|  5.00679e-06|  0.00%|    state.str = str
   946|         0|            0|            0|  0.00%|
   947|         2|  9.53674e-06|  4.76837e-06|  0.00%|    try:
   948|         2|  5.17368e-05|  2.58684e-05|  0.00%|        p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
(call)|         2|     0.276188|     0.138094|  0.20%|# /opt/conda/lib/python3.8/sre_parse.py:435 _parse_sub
   949|         0|            0|            0|  0.00%|    except Verbose:
   950|         0|            0|            0|  0.00%|        # the VERBOSE flag was switched on inside the pattern.  to be
   951|         0|            0|            0|  0.00%|        # on the safe side, we'll parse the whole thing again...
   952|         0|            0|            0|  0.00%|        state = State()
   953|         0|            0|            0|  0.00%|        state.flags = flags | SRE_FLAG_VERBOSE
   954|         0|            0|            0|  0.00%|        state.str = str
   955|         0|            0|            0|  0.00%|        source.seek(0)
   956|         0|            0|            0|  0.00%|        p = _parse_sub(source, state, True, 0)
   957|         0|            0|            0|  0.00%|
   958|         2|  4.33922e-05|  2.16961e-05|  0.00%|    p.state.flags = fix_flags(str, p.state.flags)
(call)|         2|  6.53267e-05|  3.26633e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:921 fix_flags
   959|         0|            0|            0|  0.00%|
   960|         2|  1.04904e-05|  5.24521e-06|  0.00%|    if source.next is not None:
   961|         0|            0|            0|  0.00%|        assert source.next == ")"
   962|         0|            0|            0|  0.00%|        raise source.error("unbalanced parenthesis")
   963|         0|            0|            0|  0.00%|
   964|         2|  1.00136e-05|  5.00679e-06|  0.00%|    if flags & SRE_FLAG_DEBUG:
   965|         0|            0|            0|  0.00%|        p.dump()
   966|         0|            0|            0|  0.00%|
   967|         2|  1.83582e-05|  9.17912e-06|  0.00%|    return p
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|def parse_template(source, state):
   970|         0|            0|            0|  0.00%|    # parse 're' replacement string into list of literals and
   971|         0|            0|            0|  0.00%|    # group references
   972|         0|            0|            0|  0.00%|    s = Tokenizer(source)
   973|         0|            0|            0|  0.00%|    sget = s.get
   974|         0|            0|            0|  0.00%|    groups = []
   975|         0|            0|            0|  0.00%|    literals = []
   976|         0|            0|            0|  0.00%|    literal = []
   977|         0|            0|            0|  0.00%|    lappend = literal.append
   978|         0|            0|            0|  0.00%|    def addgroup(index, pos):
   979|         0|            0|            0|  0.00%|        if index > state.groups:
   980|         0|            0|            0|  0.00%|            raise s.error("invalid group reference %d" % index, pos)
   981|         0|            0|            0|  0.00%|        if literal:
   982|         0|            0|            0|  0.00%|            literals.append(''.join(literal))
   983|         0|            0|            0|  0.00%|            del literal[:]
   984|         0|            0|            0|  0.00%|        groups.append((len(literals), index))
   985|         0|            0|            0|  0.00%|        literals.append(None)
   986|         0|            0|            0|  0.00%|    groupindex = state.groupindex
   987|         0|            0|            0|  0.00%|    while True:
   988|         0|            0|            0|  0.00%|        this = sget()
   989|         0|            0|            0|  0.00%|        if this is None:
   990|         0|            0|            0|  0.00%|            break # end of replacement string
   991|         0|            0|            0|  0.00%|        if this[0] == "\\":
   992|         0|            0|            0|  0.00%|            # group
   993|         0|            0|            0|  0.00%|            c = this[1]
   994|         0|            0|            0|  0.00%|            if c == "g":
   995|         0|            0|            0|  0.00%|                name = ""
   996|         0|            0|            0|  0.00%|                if not s.match("<"):
   997|         0|            0|            0|  0.00%|                    raise s.error("missing <")
   998|         0|            0|            0|  0.00%|                name = s.getuntil(">", "group name")
   999|         0|            0|            0|  0.00%|                if name.isidentifier():
  1000|         0|            0|            0|  0.00%|                    try:
  1001|         0|            0|            0|  0.00%|                        index = groupindex[name]
  1002|         0|            0|            0|  0.00%|                    except KeyError:
  1003|         0|            0|            0|  0.00%|                        raise IndexError("unknown group name %r" % name)
  1004|         0|            0|            0|  0.00%|                else:
  1005|         0|            0|            0|  0.00%|                    try:
  1006|         0|            0|            0|  0.00%|                        index = int(name)
  1007|         0|            0|            0|  0.00%|                        if index < 0:
  1008|         0|            0|            0|  0.00%|                            raise ValueError
  1009|         0|            0|            0|  0.00%|                    except ValueError:
  1010|         0|            0|            0|  0.00%|                        raise s.error("bad character in group name %r" % name,
  1011|         0|            0|            0|  0.00%|                                      len(name) + 1) from None
  1012|         0|            0|            0|  0.00%|                    if index >= MAXGROUPS:
  1013|         0|            0|            0|  0.00%|                        raise s.error("invalid group reference %d" % index,
  1014|         0|            0|            0|  0.00%|                                      len(name) + 1)
  1015|         0|            0|            0|  0.00%|                addgroup(index, len(name) + 1)
  1016|         0|            0|            0|  0.00%|            elif c == "0":
  1017|         0|            0|            0|  0.00%|                if s.next in OCTDIGITS:
  1018|         0|            0|            0|  0.00%|                    this += sget()
  1019|         0|            0|            0|  0.00%|                    if s.next in OCTDIGITS:
  1020|         0|            0|            0|  0.00%|                        this += sget()
  1021|         0|            0|            0|  0.00%|                lappend(chr(int(this[1:], 8) & 0xff))
  1022|         0|            0|            0|  0.00%|            elif c in DIGITS:
  1023|         0|            0|            0|  0.00%|                isoctal = False
  1024|         0|            0|            0|  0.00%|                if s.next in DIGITS:
  1025|         0|            0|            0|  0.00%|                    this += sget()
  1026|         0|            0|            0|  0.00%|                    if (c in OCTDIGITS and this[2] in OCTDIGITS and
  1027|         0|            0|            0|  0.00%|                        s.next in OCTDIGITS):
  1028|         0|            0|            0|  0.00%|                        this += sget()
  1029|         0|            0|            0|  0.00%|                        isoctal = True
  1030|         0|            0|            0|  0.00%|                        c = int(this[1:], 8)
  1031|         0|            0|            0|  0.00%|                        if c > 0o377:
  1032|         0|            0|            0|  0.00%|                            raise s.error('octal escape value %s outside of '
  1033|         0|            0|            0|  0.00%|                                          'range 0-0o377' % this, len(this))
  1034|         0|            0|            0|  0.00%|                        lappend(chr(c))
  1035|         0|            0|            0|  0.00%|                if not isoctal:
  1036|         0|            0|            0|  0.00%|                    addgroup(int(this[1:]), len(this) - 1)
  1037|         0|            0|            0|  0.00%|            else:
  1038|         0|            0|            0|  0.00%|                try:
  1039|         0|            0|            0|  0.00%|                    this = chr(ESCAPES[this][1])
  1040|         0|            0|            0|  0.00%|                except KeyError:
  1041|         0|            0|            0|  0.00%|                    if c in ASCIILETTERS:
  1042|         0|            0|            0|  0.00%|                        raise s.error('bad escape %s' % this, len(this))
  1043|         0|            0|            0|  0.00%|                lappend(this)
  1044|         0|            0|            0|  0.00%|        else:
  1045|         0|            0|            0|  0.00%|            lappend(this)
  1046|         0|            0|            0|  0.00%|    if literal:
  1047|         0|            0|            0|  0.00%|        literals.append(''.join(literal))
  1048|         0|            0|            0|  0.00%|    if not isinstance(source, str):
  1049|         0|            0|            0|  0.00%|        # The tokenizer implicitly decodes bytes objects as latin-1, we must
  1050|         0|            0|            0|  0.00%|        # therefore re-encode the final representation.
  1051|         0|            0|            0|  0.00%|        literals = [None if s is None else s.encode('latin-1') for s in literals]
  1052|         0|            0|            0|  0.00%|    return groups, literals
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|def expand_template(template, match):
  1055|         0|            0|            0|  0.00%|    g = match.group
  1056|         0|            0|            0|  0.00%|    empty = match.string[:0]
  1057|         0|            0|            0|  0.00%|    groups, literals = template
  1058|         0|            0|            0|  0.00%|    literals = literals[:]
  1059|         0|            0|            0|  0.00%|    try:
  1060|         0|            0|            0|  0.00%|        for index, group in groups:
  1061|         0|            0|            0|  0.00%|            literals[index] = g(group) or empty
  1062|         0|            0|            0|  0.00%|    except IndexError:
  1063|         0|            0|            0|  0.00%|        raise error("invalid group reference %d" % index)
  1064|         0|            0|            0|  0.00%|    return empty.join(literals)
File: /opt/conda/lib/python3.8/sre_compile.py
File duration: 0.0998807s (0.07%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Secret Labs' Regular Expression Engine
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# convert template to internal format
     5|         0|            0|            0|  0.00%|#
     6|         0|            0|            0|  0.00%|# Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# See the sre.py file for information on usage and redistribution.
     9|         0|            0|            0|  0.00%|#
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|"""Internal support module for sre"""
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|import _sre
    14|         0|            0|            0|  0.00%|import sre_parse
    15|         0|            0|            0|  0.00%|from sre_constants import *
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|assert _sre.MAGIC == MAGIC, "SRE module mismatch"
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|_LITERAL_CODES = {LITERAL, NOT_LITERAL}
    20|         0|            0|            0|  0.00%|_REPEATING_CODES = {REPEAT, MIN_REPEAT, MAX_REPEAT}
    21|         0|            0|            0|  0.00%|_SUCCESS_CODES = {SUCCESS, FAILURE}
    22|         0|            0|            0|  0.00%|_ASSERT_CODES = {ASSERT, ASSERT_NOT}
    23|         0|            0|            0|  0.00%|_UNIT_CODES = _LITERAL_CODES | {ANY, IN}
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# Sets of lowercase characters which have the same uppercase.
    26|         0|            0|            0|  0.00%|_equivalences = (
    27|         0|            0|            0|  0.00%|    # LATIN SMALL LETTER I, LATIN SMALL LETTER DOTLESS I
    28|         0|            0|            0|  0.00%|    (0x69, 0x131), # i
    29|         0|            0|            0|  0.00%|    # LATIN SMALL LETTER S, LATIN SMALL LETTER LONG S
    30|         0|            0|            0|  0.00%|    (0x73, 0x17f), # s
    31|         0|            0|            0|  0.00%|    # MICRO SIGN, GREEK SMALL LETTER MU
    32|         0|            0|            0|  0.00%|    (0xb5, 0x3bc), # 
    33|         0|            0|            0|  0.00%|    # COMBINING GREEK YPOGEGRAMMENI, GREEK SMALL LETTER IOTA, GREEK PROSGEGRAMMENI
    34|         0|            0|            0|  0.00%|    (0x345, 0x3b9, 0x1fbe), # \u0345
    35|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS, GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA
    36|         0|            0|            0|  0.00%|    (0x390, 0x1fd3), # 
    37|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS, GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND OXIA
    38|         0|            0|            0|  0.00%|    (0x3b0, 0x1fe3), # 
    39|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER BETA, GREEK BETA SYMBOL
    40|         0|            0|            0|  0.00%|    (0x3b2, 0x3d0), # 
    41|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER EPSILON, GREEK LUNATE EPSILON SYMBOL
    42|         0|            0|            0|  0.00%|    (0x3b5, 0x3f5), # 
    43|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER THETA, GREEK THETA SYMBOL
    44|         0|            0|            0|  0.00%|    (0x3b8, 0x3d1), # 
    45|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER KAPPA, GREEK KAPPA SYMBOL
    46|         0|            0|            0|  0.00%|    (0x3ba, 0x3f0), # 
    47|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER PI, GREEK PI SYMBOL
    48|         0|            0|            0|  0.00%|    (0x3c0, 0x3d6), # 
    49|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER RHO, GREEK RHO SYMBOL
    50|         0|            0|            0|  0.00%|    (0x3c1, 0x3f1), # 
    51|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER FINAL SIGMA, GREEK SMALL LETTER SIGMA
    52|         0|            0|            0|  0.00%|    (0x3c2, 0x3c3), # 
    53|         0|            0|            0|  0.00%|    # GREEK SMALL LETTER PHI, GREEK PHI SYMBOL
    54|         0|            0|            0|  0.00%|    (0x3c6, 0x3d5), # 
    55|         0|            0|            0|  0.00%|    # LATIN SMALL LETTER S WITH DOT ABOVE, LATIN SMALL LETTER LONG S WITH DOT ABOVE
    56|         0|            0|            0|  0.00%|    (0x1e61, 0x1e9b), # 
    57|         0|            0|            0|  0.00%|    # LATIN SMALL LIGATURE LONG S T, LATIN SMALL LIGATURE ST
    58|         0|            0|            0|  0.00%|    (0xfb05, 0xfb06), # 
    59|         0|            0|            0|  0.00%|)
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|# Maps the lowercase code to lowercase codes which have the same uppercase.
    62|         0|            0|            0|  0.00%|_ignorecase_fixes = {i: tuple(j for j in t if i != j)
    63|         0|            0|            0|  0.00%|                     for t in _equivalences for i in t}
    64|         0|            0|            0|  0.00%|
    65|        26|  0.000128031|  4.92426e-06|  0.00%|def _combine_flags(flags, add_flags, del_flags,
    66|         0|            0|            0|  0.00%|                   TYPE_FLAGS=sre_parse.TYPE_FLAGS):
    67|        26|  0.000108957|  4.19067e-06|  0.00%|    if add_flags & TYPE_FLAGS:
    68|         0|            0|            0|  0.00%|        flags &= ~TYPE_FLAGS
    69|        26|  0.000108719|   4.1815e-06|  0.00%|    return (flags | add_flags) & ~del_flags
    70|         0|            0|            0|  0.00%|
    71|       280|   0.00225115|  8.03982e-06|  0.00%|def _compile(code, pattern, flags):
    72|         0|            0|            0|  0.00%|    # internal: compile a (sub)pattern
    73|       280|   0.00207376|   7.4063e-06|  0.00%|    emit = code.append
    74|       280|   0.00198412|  7.08614e-06|  0.00%|    _len = len
    75|       280|   0.00195956|  6.99844e-06|  0.00%|    LITERAL_CODES = _LITERAL_CODES
    76|       280|    0.0018692|  6.67572e-06|  0.00%|    REPEATING_CODES = _REPEATING_CODES
    77|       280|   0.00186038|  6.64421e-06|  0.00%|    SUCCESS_CODES = _SUCCESS_CODES
    78|       280|   0.00181603|  6.48584e-06|  0.00%|    ASSERT_CODES = _ASSERT_CODES
    79|       280|   0.00177836|   6.3513e-06|  0.00%|    iscased = None
    80|       280|   0.00183439|   6.5514e-06|  0.00%|    tolower = None
    81|       280|   0.00179648|  6.41601e-06|  0.00%|    fixes = None
    82|       280|   0.00183606|  6.55736e-06|  0.00%|    if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:
    83|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_UNICODE:
    84|         0|            0|            0|  0.00%|            iscased = _sre.unicode_iscased
    85|         0|            0|            0|  0.00%|            tolower = _sre.unicode_tolower
    86|         0|            0|            0|  0.00%|            fixes = _ignorecase_fixes
    87|         0|            0|            0|  0.00%|        else:
    88|         0|            0|            0|  0.00%|            iscased = _sre.ascii_iscased
    89|         0|            0|            0|  0.00%|            tolower = _sre.ascii_tolower
    90|       760|    0.0116656|  1.53495e-05|  0.01%|    for op, av in pattern:
(call)|       755|    0.0108724|  1.44005e-05|  0.01%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
    91|       480|   0.00309229|  6.44227e-06|  0.00%|        if op in LITERAL_CODES:
    92|       305|   0.00195217|  6.40056e-06|  0.00%|            if not flags & SRE_FLAG_IGNORECASE:
    93|       305|   0.00240684|  7.89126e-06|  0.00%|                emit(op)
    94|       305|   0.00241518|  7.91862e-06|  0.00%|                emit(av)
    95|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_LOCALE:
    96|         0|            0|            0|  0.00%|                emit(OP_LOCALE_IGNORE[op])
    97|         0|            0|            0|  0.00%|                emit(av)
    98|         0|            0|            0|  0.00%|            elif not iscased(av):
    99|         0|            0|            0|  0.00%|                emit(op)
   100|         0|            0|            0|  0.00%|                emit(av)
   101|         0|            0|            0|  0.00%|            else:
   102|         0|            0|            0|  0.00%|                lo = tolower(av)
   103|         0|            0|            0|  0.00%|                if not fixes:  # ascii
   104|         0|            0|            0|  0.00%|                    emit(OP_IGNORE[op])
   105|         0|            0|            0|  0.00%|                    emit(lo)
   106|         0|            0|            0|  0.00%|                elif lo not in fixes:
   107|         0|            0|            0|  0.00%|                    emit(OP_UNICODE_IGNORE[op])
   108|         0|            0|            0|  0.00%|                    emit(lo)
   109|         0|            0|            0|  0.00%|                else:
   110|         0|            0|            0|  0.00%|                    emit(IN_UNI_IGNORE)
   111|         0|            0|            0|  0.00%|                    skip = _len(code); emit(0)
   112|         0|            0|            0|  0.00%|                    if op is NOT_LITERAL:
   113|         0|            0|            0|  0.00%|                        emit(NEGATE)
   114|         0|            0|            0|  0.00%|                    for k in (lo,) + fixes[lo]:
   115|         0|            0|            0|  0.00%|                        emit(LITERAL)
   116|         0|            0|            0|  0.00%|                        emit(k)
   117|         0|            0|            0|  0.00%|                    emit(FAILURE)
   118|         0|            0|            0|  0.00%|                    code[skip] = _len(code) - skip
   119|       175|   0.00109291|   6.2452e-06|  0.00%|        elif op is IN:
   120|        59|   0.00115895|  1.96433e-05|  0.00%|            charset, hascased = _optimize_charset(av, iscased, tolower, fixes)
(call)|        59|    0.0183008|  0.000310183|  0.01%|# /opt/conda/lib/python3.8/sre_compile.py:276 _optimize_charset
   121|        59|  0.000403643|   6.8414e-06|  0.00%|            if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:
   122|         0|            0|            0|  0.00%|                emit(IN_LOC_IGNORE)
   123|        59|   0.00036788|  6.23525e-06|  0.00%|            elif not hascased:
   124|        59|  0.000472784|  8.01329e-06|  0.00%|                emit(IN)
   125|         0|            0|            0|  0.00%|            elif not fixes:  # ascii
   126|         0|            0|            0|  0.00%|                emit(IN_IGNORE)
   127|         0|            0|            0|  0.00%|            else:
   128|         0|            0|            0|  0.00%|                emit(IN_UNI_IGNORE)
   129|        59|  0.000575304|  9.75092e-06|  0.00%|            skip = _len(code); emit(0)
   130|        59|  0.000962496|  1.63135e-05|  0.00%|            _compile_charset(charset, flags, code)
(call)|        59|   0.00349569|   5.9249e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:249 _compile_charset
   131|        59|  0.000485897|  8.23554e-06|  0.00%|            code[skip] = _len(code) - skip
   132|       116|  0.000712156|  6.13928e-06|  0.00%|        elif op is ANY:
   133|         3|  1.90735e-05|  6.35783e-06|  0.00%|            if flags & SRE_FLAG_DOTALL:
   134|         0|            0|            0|  0.00%|                emit(ANY_ALL)
   135|         0|            0|            0|  0.00%|            else:
   136|         3|  2.71797e-05|  9.05991e-06|  0.00%|                emit(ANY)
   137|       113|  0.000695705|  6.15669e-06|  0.00%|        elif op in REPEATING_CODES:
   138|        62|  0.000383377|   6.1835e-06|  0.00%|            if flags & SRE_FLAG_TEMPLATE:
   139|         0|            0|            0|  0.00%|                raise error("internal: unsupported template operator %r" % (op,))
   140|        62|  0.000974178|  1.57126e-05|  0.00%|            if _simple(av[2]):
(call)|        62|   0.00319648|  5.15561e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:423 _simple
   141|        38|  0.000240564|  6.33064e-06|  0.00%|                if op is MAX_REPEAT:
   142|        38|  0.000303984|  7.99957e-06|  0.00%|                    emit(REPEAT_ONE)
   143|         0|            0|            0|  0.00%|                else:
   144|         0|            0|            0|  0.00%|                    emit(MIN_REPEAT_ONE)
   145|        38|  0.000372887|  9.81281e-06|  0.00%|                skip = _len(code); emit(0)
   146|        38|  0.000308275|  8.11251e-06|  0.00%|                emit(av[0])
   147|        38|  0.000306845|  8.07486e-06|  0.00%|                emit(av[1])
   148|        38|  0.000742912|  1.95503e-05|  0.00%|                _compile(code, av[2], flags)
(call)|        38|    0.0131795|   0.00034683|  0.01%|# /opt/conda/lib/python3.8/sre_compile.py:71 _compile
   149|        38|  0.000322342|  8.48268e-06|  0.00%|                emit(SUCCESS)
   150|        38|  0.000329971|  8.68346e-06|  0.00%|                code[skip] = _len(code) - skip
   151|         0|            0|            0|  0.00%|            else:
   152|        24|  0.000188589|  7.85788e-06|  0.00%|                emit(REPEAT)
   153|        24|  0.000240564|  1.00235e-05|  0.00%|                skip = _len(code); emit(0)
   154|        24|  0.000189304|  7.88768e-06|  0.00%|                emit(av[0])
   155|        24|   0.00018549|  7.72874e-06|  0.00%|                emit(av[1])
   156|        24|  0.000468969|  1.95404e-05|  0.00%|                _compile(code, av[2], flags)
(call)|        24|    0.0172288|  0.000717868|  0.01%|# /opt/conda/lib/python3.8/sre_compile.py:71 _compile
   157|        24|  0.000204563|  8.52346e-06|  0.00%|                code[skip] = _len(code) - skip
   158|        24|  0.000151396|  6.30816e-06|  0.00%|                if op is MAX_REPEAT:
   159|        24|  0.000187397|  7.80821e-06|  0.00%|                    emit(MAX_UNTIL)
   160|         0|            0|            0|  0.00%|                else:
   161|         0|            0|            0|  0.00%|                    emit(MIN_UNTIL)
   162|        51|  0.000315666|  6.18953e-06|  0.00%|        elif op is SUBPATTERN:
   163|        26|  0.000157833|   6.0705e-06|  0.00%|            group, add_flags, del_flags, p = av
   164|        26|  0.000156879|  6.03382e-06|  0.00%|            if group:
   165|        26|   0.00021553|  8.28963e-06|  0.00%|                emit(MARK)
   166|        26|  0.000208378|  8.01453e-06|  0.00%|                emit((group-1)*2)
   167|         0|            0|            0|  0.00%|            # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))
   168|        26|  0.000743866|  2.86102e-05|  0.00%|            _compile(code, p, _combine_flags(flags, add_flags, del_flags))
(call)|        26|  0.000345707|  1.32964e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:65 _combine_flags
(call)|        26|    0.0256879|  0.000987997|  0.02%|# /opt/conda/lib/python3.8/sre_compile.py:71 _compile
   169|        26|  0.000168324|  6.47398e-06|  0.00%|            if group:
   170|        26|  0.000207186|  7.96868e-06|  0.00%|                emit(MARK)
   171|        26|  0.000207186|  7.96868e-06|  0.00%|                emit((group-1)*2+1)
   172|        25|  0.000157118|  6.28471e-06|  0.00%|        elif op in SUCCESS_CODES:
   173|         0|            0|            0|  0.00%|            emit(op)
   174|        25|  0.000155926|  6.23703e-06|  0.00%|        elif op in ASSERT_CODES:
   175|         1|  7.62939e-06|  7.62939e-06|  0.00%|            emit(op)
   176|         1|  1.21593e-05|  1.21593e-05|  0.00%|            skip = _len(code); emit(0)
   177|         1|  8.82149e-06|  8.82149e-06|  0.00%|            if av[0] >= 0:
   178|         0|            0|            0|  0.00%|                emit(0) # look ahead
   179|         0|            0|            0|  0.00%|            else:
   180|         1|  2.14577e-05|  2.14577e-05|  0.00%|                lo, hi = av[1].getwidth()
(call)|         1|  7.27177e-05|  7.27177e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:174 getwidth
   181|         1|  9.53674e-06|  9.53674e-06|  0.00%|                if lo != hi:
   182|         0|            0|            0|  0.00%|                    raise error("look-behind requires fixed-width pattern")
   183|         1|   1.0252e-05|   1.0252e-05|  0.00%|                emit(lo) # look behind
   184|         1|   2.5034e-05|   2.5034e-05|  0.00%|            _compile(code, av[1], flags)
(call)|         1|  0.000442982|  0.000442982|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:71 _compile
   185|         1|  1.19209e-05|  1.19209e-05|  0.00%|            emit(SUCCESS)
   186|         1|  1.04904e-05|  1.04904e-05|  0.00%|            code[skip] = _len(code) - skip
   187|        24|  0.000150919|  6.28829e-06|  0.00%|        elif op is CALL:
   188|         0|            0|            0|  0.00%|            emit(op)
   189|         0|            0|            0|  0.00%|            skip = _len(code); emit(0)
   190|         0|            0|            0|  0.00%|            _compile(code, av, flags)
   191|         0|            0|            0|  0.00%|            emit(SUCCESS)
   192|         0|            0|            0|  0.00%|            code[skip] = _len(code) - skip
   193|        24|  0.000151634|  6.31809e-06|  0.00%|        elif op is AT:
   194|         3|  2.36034e-05|  7.86781e-06|  0.00%|            emit(op)
   195|         3|  2.31266e-05|  7.70887e-06|  0.00%|            if flags & SRE_FLAG_MULTILINE:
   196|         0|            0|            0|  0.00%|                av = AT_MULTILINE.get(av, av)
   197|         3|  2.12193e-05|  7.07308e-06|  0.00%|            if flags & SRE_FLAG_LOCALE:
   198|         0|            0|            0|  0.00%|                av = AT_LOCALE.get(av, av)
   199|         3|  2.14577e-05|  7.15256e-06|  0.00%|            elif flags & SRE_FLAG_UNICODE:
   200|         3|  2.81334e-05|   9.3778e-06|  0.00%|                av = AT_UNICODE.get(av, av)
   201|         3|  3.62396e-05|  1.20799e-05|  0.00%|            emit(av)
   202|        21|  0.000139475|  6.64166e-06|  0.00%|        elif op is BRANCH:
   203|        21|  0.000172138|  8.19706e-06|  0.00%|            emit(op)
   204|        21|  0.000138044|  6.57354e-06|  0.00%|            tail = []
   205|        21|  0.000136852|  6.51677e-06|  0.00%|            tailappend = tail.append
   206|       210|   0.00133324|  6.34875e-06|  0.00%|            for av in av[1]:
   207|       189|   0.00174999|  9.25922e-06|  0.00%|                skip = _len(code); emit(0)
   208|         0|            0|            0|  0.00%|                # _compile_info(code, av, flags)
   209|       189|   0.00365138|  1.93195e-05|  0.00%|                _compile(code, av, flags)
(call)|       189|    0.0531771|   0.00028136|  0.04%|# /opt/conda/lib/python3.8/sre_compile.py:71 _compile
   210|       189|   0.00155807|  8.24373e-06|  0.00%|                emit(JUMP)
   211|       189|   0.00208735|  1.10442e-05|  0.00%|                tailappend(_len(code)); emit(0)
   212|       189|   0.00154114|  8.15417e-06|  0.00%|                code[skip] = _len(code) - skip
   213|        21|  0.000175476|    8.356e-06|  0.00%|            emit(FAILURE) # end of branch
   214|       210|   0.00132203|  6.29539e-06|  0.00%|            for tail in tail:
   215|       189|   0.00152898|  8.08983e-06|  0.00%|                code[tail] = _len(code) - tail
   216|         0|            0|            0|  0.00%|        elif op is CATEGORY:
   217|         0|            0|            0|  0.00%|            emit(op)
   218|         0|            0|            0|  0.00%|            if flags & SRE_FLAG_LOCALE:
   219|         0|            0|            0|  0.00%|                av = CH_LOCALE[av]
   220|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_UNICODE:
   221|         0|            0|            0|  0.00%|                av = CH_UNICODE[av]
   222|         0|            0|            0|  0.00%|            emit(av)
   223|         0|            0|            0|  0.00%|        elif op is GROUPREF:
   224|         0|            0|            0|  0.00%|            if not flags & SRE_FLAG_IGNORECASE:
   225|         0|            0|            0|  0.00%|                emit(op)
   226|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_LOCALE:
   227|         0|            0|            0|  0.00%|                emit(GROUPREF_LOC_IGNORE)
   228|         0|            0|            0|  0.00%|            elif not fixes:  # ascii
   229|         0|            0|            0|  0.00%|                emit(GROUPREF_IGNORE)
   230|         0|            0|            0|  0.00%|            else:
   231|         0|            0|            0|  0.00%|                emit(GROUPREF_UNI_IGNORE)
   232|         0|            0|            0|  0.00%|            emit(av-1)
   233|         0|            0|            0|  0.00%|        elif op is GROUPREF_EXISTS:
   234|         0|            0|            0|  0.00%|            emit(op)
   235|         0|            0|            0|  0.00%|            emit(av[0]-1)
   236|         0|            0|            0|  0.00%|            skipyes = _len(code); emit(0)
   237|         0|            0|            0|  0.00%|            _compile(code, av[1], flags)
   238|         0|            0|            0|  0.00%|            if av[2]:
   239|         0|            0|            0|  0.00%|                emit(JUMP)
   240|         0|            0|            0|  0.00%|                skipno = _len(code); emit(0)
   241|         0|            0|            0|  0.00%|                code[skipyes] = _len(code) - skipyes + 1
   242|         0|            0|            0|  0.00%|                _compile(code, av[2], flags)
   243|         0|            0|            0|  0.00%|                code[skipno] = _len(code) - skipno
   244|         0|            0|            0|  0.00%|            else:
   245|         0|            0|            0|  0.00%|                code[skipyes] = _len(code) - skipyes + 1
   246|         0|            0|            0|  0.00%|        else:
   247|         0|            0|            0|  0.00%|            raise error("internal: unsupported operand type %r" % (op,))
   248|         0|            0|            0|  0.00%|
   249|        59|  0.000318766|  5.40281e-06|  0.00%|def _compile_charset(charset, flags, code):
   250|         0|            0|            0|  0.00%|    # compile charset subprogram
   251|        59|  0.000270844|  4.59057e-06|  0.00%|    emit = code.append
   252|       138|  0.000572681|  4.14987e-06|  0.00%|    for op, av in charset:
   253|        79|    0.0004282|  5.42025e-06|  0.00%|        emit(op)
   254|        79|  0.000316858|  4.01086e-06|  0.00%|        if op is NEGATE:
   255|         5|  1.83582e-05|  3.67165e-06|  0.00%|            pass
   256|        74|  0.000282049|  3.81148e-06|  0.00%|        elif op is LITERAL:
   257|        29|  0.000150919|   5.2041e-06|  0.00%|            emit(av)
   258|        45|  0.000174284|  3.87298e-06|  0.00%|        elif op is RANGE or op is RANGE_UNI_IGNORE:
   259|        30|  0.000164032|  5.46773e-06|  0.00%|            emit(av[0])
   260|        30|  0.000174761|  5.82536e-06|  0.00%|            emit(av[1])
   261|        15|  6.05583e-05|  4.03722e-06|  0.00%|        elif op is CHARSET:
   262|         6|  3.60012e-05|   6.0002e-06|  0.00%|            code.extend(av)
   263|         9|  3.60012e-05|  4.00013e-06|  0.00%|        elif op is BIGCHARSET:
   264|         0|            0|            0|  0.00%|            code.extend(av)
   265|         9|   3.6478e-05|  4.05312e-06|  0.00%|        elif op is CATEGORY:
   266|         9|  3.71933e-05|  4.13259e-06|  0.00%|            if flags & SRE_FLAG_LOCALE:
   267|         0|            0|            0|  0.00%|                emit(CH_LOCALE[av])
   268|         9|  3.67165e-05|  4.07961e-06|  0.00%|            elif flags & SRE_FLAG_UNICODE:
   269|         9|  5.38826e-05|  5.98696e-06|  0.00%|                emit(CH_UNICODE[av])
   270|         0|            0|            0|  0.00%|            else:
   271|         0|            0|            0|  0.00%|                emit(av)
   272|         0|            0|            0|  0.00%|        else:
   273|         0|            0|            0|  0.00%|            raise error("internal: unsupported set operator %r" % (op,))
   274|        59|   0.00032711|  5.54424e-06|  0.00%|    emit(FAILURE)
   275|         0|            0|            0|  0.00%|
   276|        59|  0.000440836|   7.4718e-06|  0.00%|def _optimize_charset(charset, iscased=None, fixup=None, fixes=None):
   277|         0|            0|            0|  0.00%|    # internal: optimize character set
   278|        59|   0.00041914|  7.10407e-06|  0.00%|    out = []
   279|        59|  0.000378132|  6.40901e-06|  0.00%|    tail = []
   280|        59|  0.000445604|  7.55262e-06|  0.00%|    charmap = bytearray(256)
   281|        59|  0.000362873|  6.15039e-06|  0.00%|    hascased = False
   282|       151|  0.000867128|  5.74257e-06|  0.00%|    for op, av in charset:
   283|         0|            0|            0|  0.00%|        while True:
   284|        92|   0.00051856|  5.63653e-06|  0.00%|            try:
   285|        92|  0.000540495|  5.87494e-06|  0.00%|                if op is LITERAL:
   286|        46|  0.000260115|  5.65467e-06|  0.00%|                    if fixup:
   287|         0|            0|            0|  0.00%|                        lo = fixup(av)
   288|         0|            0|            0|  0.00%|                        charmap[lo] = 1
   289|         0|            0|            0|  0.00%|                        if fixes and lo in fixes:
   290|         0|            0|            0|  0.00%|                            for k in fixes[lo]:
   291|         0|            0|            0|  0.00%|                                charmap[k] = 1
   292|         0|            0|            0|  0.00%|                        if not hascased and iscased(av):
   293|         0|            0|            0|  0.00%|                            hascased = True
   294|         0|            0|            0|  0.00%|                    else:
   295|        46|  0.000272274|    5.919e-06|  0.00%|                        charmap[av] = 1
   296|        46|   0.00026679|  5.79979e-06|  0.00%|                elif op is RANGE:
   297|        32|  0.000222921|  6.96629e-06|  0.00%|                    r = range(av[0], av[1]+1)
   298|        32|  0.000191212|  5.97537e-06|  0.00%|                    if fixup:
   299|         0|            0|            0|  0.00%|                        if fixes:
   300|         0|            0|            0|  0.00%|                            for i in map(fixup, r):
   301|         0|            0|            0|  0.00%|                                charmap[i] = 1
   302|         0|            0|            0|  0.00%|                                if i in fixes:
   303|         0|            0|            0|  0.00%|                                    for k in fixes[i]:
   304|         0|            0|            0|  0.00%|                                        charmap[k] = 1
   305|         0|            0|            0|  0.00%|                        else:
   306|         0|            0|            0|  0.00%|                            for i in map(fixup, r):
   307|         0|            0|            0|  0.00%|                                charmap[i] = 1
   308|         0|            0|            0|  0.00%|                        if not hascased:
   309|         0|            0|            0|  0.00%|                            hascased = any(map(iscased, r))
   310|         0|            0|            0|  0.00%|                    else:
   311|       341|   0.00187397|  5.49551e-06|  0.00%|                        for i in r:
   312|       309|   0.00168085|  5.43965e-06|  0.00%|                            charmap[i] = 1
   313|        14|  8.13007e-05|   5.8072e-06|  0.00%|                elif op is NEGATE:
   314|         5|  4.07696e-05|  8.15392e-06|  0.00%|                    out.append((op, av))
   315|         0|            0|            0|  0.00%|                else:
   316|         9|   8.2016e-05|  9.11289e-06|  0.00%|                    tail.append((op, av))
   317|         0|            0|            0|  0.00%|            except IndexError:
   318|         0|            0|            0|  0.00%|                if len(charmap) == 256:
   319|         0|            0|            0|  0.00%|                    # character set contains non-UCS1 character codes
   320|         0|            0|            0|  0.00%|                    charmap += b'\0' * 0xff00
   321|         0|            0|            0|  0.00%|                    continue
   322|         0|            0|            0|  0.00%|                # Character set contains non-BMP character codes.
   323|         0|            0|            0|  0.00%|                if fixup:
   324|         0|            0|            0|  0.00%|                    hascased = True
   325|         0|            0|            0|  0.00%|                    # There are only two ranges of cased non-BMP characters:
   326|         0|            0|            0|  0.00%|                    # 10400-1044F (Deseret) and 118A0-118DF (Warang Citi),
   327|         0|            0|            0|  0.00%|                    # and for both ranges RANGE_UNI_IGNORE works.
   328|         0|            0|            0|  0.00%|                    if op is RANGE:
   329|         0|            0|            0|  0.00%|                        op = RANGE_UNI_IGNORE
   330|         0|            0|            0|  0.00%|                tail.append((op, av))
   331|        92|  0.000509501|  5.53805e-06|  0.00%|            break
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    # compress character map
   334|        59|  0.000332594|  5.63719e-06|  0.00%|    runs = []
   335|        59|  0.000326872|   5.5402e-06|  0.00%|    q = 0
   336|         0|            0|            0|  0.00%|    while True:
   337|       130|   0.00108242|  8.32631e-06|  0.00%|        p = charmap.find(1, q)
   338|       130|  0.000741959|  5.70737e-06|  0.00%|        if p < 0:
   339|        53|  0.000278711|   5.2587e-06|  0.00%|            break
   340|        77|   0.00056529|  7.34143e-06|  0.00%|        if len(runs) >= 2:
   341|         6|  3.38554e-05|  5.64257e-06|  0.00%|            runs = None
   342|         6|  3.55244e-05|  5.92073e-06|  0.00%|            break
   343|        71|  0.000552177|  7.77715e-06|  0.00%|        q = charmap.find(0, p)
   344|        71|  0.000396013|  5.57765e-06|  0.00%|        if q < 0:
   345|         0|            0|            0|  0.00%|            runs.append((p, len(charmap)))
   346|         0|            0|            0|  0.00%|            break
   347|        71|  0.000521421|  7.34396e-06|  0.00%|        runs.append((p, q))
   348|        59|  0.000315428|  5.34623e-06|  0.00%|    if runs is not None:
   349|         0|            0|            0|  0.00%|        # use literal/range
   350|       112|  0.000627279|  5.60071e-06|  0.00%|        for p, q in runs:
   351|        59|  0.000326157|  5.52808e-06|  0.00%|            if q - p == 1:
   352|        29|  0.000231028|  7.96647e-06|  0.00%|                out.append((LITERAL, p))
   353|         0|            0|            0|  0.00%|            else:
   354|        30|  0.000226259|  7.54197e-06|  0.00%|                out.append((RANGE, (p, q - 1)))
   355|        53|  0.000292778|  5.52411e-06|  0.00%|        out += tail
   356|         0|            0|            0|  0.00%|        # if the case was changed or new representation is more compact
   357|        53|  0.000463247|  8.74052e-06|  0.00%|        if hascased or len(out) < len(charset):
   358|         1|  5.72205e-06|  5.72205e-06|  0.00%|            return out, hascased
   359|         0|            0|            0|  0.00%|        # else original character set is good enough
   360|        52|  0.000283241|  5.44695e-06|  0.00%|        return charset, hascased
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    # use bitmap
   363|         6|  4.43459e-05|  7.39098e-06|  0.00%|    if len(charmap) == 256:
   364|         6|  0.000152588|  2.54313e-05|  0.00%|        data = _mk_bitmap(charmap)
(call)|         6|  0.000884056|  0.000147343|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:411 _mk_bitmap
   365|         6|  5.50747e-05|  9.17912e-06|  0.00%|        out.append((CHARSET, data))
   366|         6|   3.8147e-05|  6.35783e-06|  0.00%|        out += tail
   367|         6|  3.40939e-05|  5.68231e-06|  0.00%|        return out, hascased
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|    # To represent a big charset, first a bitmap of all characters in the
   370|         0|            0|            0|  0.00%|    # set is constructed. Then, this bitmap is sliced into chunks of 256
   371|         0|            0|            0|  0.00%|    # characters, duplicate chunks are eliminated, and each chunk is
   372|         0|            0|            0|  0.00%|    # given a number. In the compiled expression, the charset is
   373|         0|            0|            0|  0.00%|    # represented by a 32-bit word sequence, consisting of one word for
   374|         0|            0|            0|  0.00%|    # the number of different chunks, a sequence of 256 bytes (64 words)
   375|         0|            0|            0|  0.00%|    # of chunk numbers indexed by their original chunk position, and a
   376|         0|            0|            0|  0.00%|    # sequence of 256-bit chunks (8 words each).
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|    # Compression is normally good: in a typical charset, large ranges of
   379|         0|            0|            0|  0.00%|    # Unicode will be either completely excluded (e.g. if only cyrillic
   380|         0|            0|            0|  0.00%|    # letters are to be matched), or completely included (e.g. if large
   381|         0|            0|            0|  0.00%|    # subranges of Kanji match). These ranges will be represented by
   382|         0|            0|            0|  0.00%|    # chunks of all one-bits or all zero-bits.
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    # Matching can be also done efficiently: the more significant byte of
   385|         0|            0|            0|  0.00%|    # the Unicode character is an index into the chunk number, and the
   386|         0|            0|            0|  0.00%|    # less significant byte is a bit index in the chunk (just like the
   387|         0|            0|            0|  0.00%|    # CHARSET matching).
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    charmap = bytes(charmap) # should be hashable
   390|         0|            0|            0|  0.00%|    comps = {}
   391|         0|            0|            0|  0.00%|    mapping = bytearray(256)
   392|         0|            0|            0|  0.00%|    block = 0
   393|         0|            0|            0|  0.00%|    data = bytearray()
   394|         0|            0|            0|  0.00%|    for i in range(0, 65536, 256):
   395|         0|            0|            0|  0.00%|        chunk = charmap[i: i + 256]
   396|         0|            0|            0|  0.00%|        if chunk in comps:
   397|         0|            0|            0|  0.00%|            mapping[i // 256] = comps[chunk]
   398|         0|            0|            0|  0.00%|        else:
   399|         0|            0|            0|  0.00%|            mapping[i // 256] = comps[chunk] = block
   400|         0|            0|            0|  0.00%|            block += 1
   401|         0|            0|            0|  0.00%|            data += chunk
   402|         0|            0|            0|  0.00%|    data = _mk_bitmap(data)
   403|         0|            0|            0|  0.00%|    data[0:0] = [block] + _bytes_to_codes(mapping)
   404|         0|            0|            0|  0.00%|    out.append((BIGCHARSET, data))
   405|         0|            0|            0|  0.00%|    out += tail
   406|         0|            0|            0|  0.00%|    return out, hascased
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|_CODEBITS = _sre.CODESIZE * 8
   409|         0|            0|            0|  0.00%|MAXCODE = (1 << _CODEBITS) - 1
   410|         0|            0|            0|  0.00%|_BITS_TRANS = b'0' + b'1' * 255
   411|         6|  3.83854e-05|  6.39757e-06|  0.00%|def _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):
   412|         6|   6.4373e-05|  1.07288e-05|  0.00%|    s = bits.translate(_BITS_TRANS)[::-1]
   413|       120|  0.000568151|   4.7346e-06|  0.00%|    return [_int(s[i - _CODEBITS: i], 2)
(call)|         6|  0.000615597|  0.000102599|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:413 <listcomp>
   414|        54|  0.000213146|  3.94715e-06|  0.00%|            for i in range(len(s), 0, -_CODEBITS)]
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|def _bytes_to_codes(b):
   417|         0|            0|            0|  0.00%|    # Convert block indices to word array
   418|         0|            0|            0|  0.00%|    a = memoryview(b).cast('I')
   419|         0|            0|            0|  0.00%|    assert a.itemsize == _sre.CODESIZE
   420|         0|            0|            0|  0.00%|    assert len(a) * a.itemsize == len(b)
   421|         0|            0|            0|  0.00%|    return a.tolist()
   422|         0|            0|            0|  0.00%|
   423|        62|  0.000305176|  4.92219e-06|  0.00%|def _simple(p):
   424|         0|            0|            0|  0.00%|    # check if this subpattern is a "simple" operator
   425|        62|  0.000880957|   1.4209e-05|  0.00%|    if len(p) != 1:
(call)|        62|   0.00059557|  9.60596e-06|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
   426|        22|  8.91685e-05|  4.05312e-06|  0.00%|        return False
   427|        40|  0.000469685|  1.17421e-05|  0.00%|    op, av = p[0]
(call)|        40|  0.000540018|  1.35005e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   428|        40|   0.00016284|    4.071e-06|  0.00%|    if op is SUBPATTERN:
   429|         2|  7.39098e-06|  3.69549e-06|  0.00%|        return av[0] is None and _simple(av[-1])
   430|        38|  0.000145674|  3.83352e-06|  0.00%|    return op in _UNIT_CODES
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|def _generate_overlap_table(prefix):
   433|         0|            0|            0|  0.00%|    """
   434|         0|            0|            0|  0.00%|    Generate an overlap table for the following prefix.
   435|         0|            0|            0|  0.00%|    An overlap table is a table of the same size as the prefix which
   436|         0|            0|            0|  0.00%|    informs about the potential self-overlap for each index in the prefix:
   437|         0|            0|            0|  0.00%|    - if overlap[i] == 0, prefix[i:] can't overlap prefix[0:...]
   438|         0|            0|            0|  0.00%|    - if overlap[i] == k with 0 < k <= i, prefix[i-k+1:i+1] overlaps with
   439|         0|            0|            0|  0.00%|      prefix[0:k]
   440|         0|            0|            0|  0.00%|    """
   441|         0|            0|            0|  0.00%|    table = [0] * len(prefix)
   442|         0|            0|            0|  0.00%|    for i in range(1, len(prefix)):
   443|         0|            0|            0|  0.00%|        idx = table[i - 1]
   444|         0|            0|            0|  0.00%|        while prefix[i] != prefix[idx]:
   445|         0|            0|            0|  0.00%|            if idx == 0:
   446|         0|            0|            0|  0.00%|                table[i] = 0
   447|         0|            0|            0|  0.00%|                break
   448|         0|            0|            0|  0.00%|            idx = table[idx - 1]
   449|         0|            0|            0|  0.00%|        else:
   450|         0|            0|            0|  0.00%|            table[i] = idx + 1
   451|         0|            0|            0|  0.00%|    return table
   452|         0|            0|            0|  0.00%|
   453|         2|  1.35899e-05|  6.79493e-06|  0.00%|def _get_iscased(flags):
   454|         2|  1.14441e-05|  5.72205e-06|  0.00%|    if not flags & SRE_FLAG_IGNORECASE:
   455|         2|  9.29832e-06|  4.64916e-06|  0.00%|        return None
   456|         0|            0|            0|  0.00%|    elif flags & SRE_FLAG_UNICODE:
   457|         0|            0|            0|  0.00%|        return _sre.unicode_iscased
   458|         0|            0|            0|  0.00%|    else:
   459|         0|            0|            0|  0.00%|        return _sre.ascii_iscased
   460|         0|            0|            0|  0.00%|
   461|         1|  1.38283e-05|  1.38283e-05|  0.00%|def _get_literal_prefix(pattern, flags):
   462|         0|            0|            0|  0.00%|    # look for literal prefix
   463|         1|  8.58307e-06|  8.58307e-06|  0.00%|    prefix = []
   464|         1|   6.1512e-05|   6.1512e-05|  0.00%|    prefixappend = prefix.append
   465|         1|  8.82149e-06|  8.82149e-06|  0.00%|    prefix_skip = None
   466|         1|  2.52724e-05|  2.52724e-05|  0.00%|    iscased = _get_iscased(flags)
(call)|         1|  2.02656e-05|  2.02656e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:453 _get_iscased
   467|         1|  8.10623e-06|  8.10623e-06|  0.00%|    for op, av in pattern.data:
   468|         1|  7.62939e-06|  7.62939e-06|  0.00%|        if op is LITERAL:
   469|         0|            0|            0|  0.00%|            if iscased and iscased(av):
   470|         0|            0|            0|  0.00%|                break
   471|         0|            0|            0|  0.00%|            prefixappend(av)
   472|         1|  1.52588e-05|  1.52588e-05|  0.00%|        elif op is SUBPATTERN:
   473|         0|            0|            0|  0.00%|            group, add_flags, del_flags, p = av
   474|         0|            0|            0|  0.00%|            flags1 = _combine_flags(flags, add_flags, del_flags)
   475|         0|            0|            0|  0.00%|            if flags1 & SRE_FLAG_IGNORECASE and flags1 & SRE_FLAG_LOCALE:
   476|         0|            0|            0|  0.00%|                break
   477|         0|            0|            0|  0.00%|            prefix1, prefix_skip1, got_all = _get_literal_prefix(p, flags1)
   478|         0|            0|            0|  0.00%|            if prefix_skip is None:
   479|         0|            0|            0|  0.00%|                if group is not None:
   480|         0|            0|            0|  0.00%|                    prefix_skip = len(prefix)
   481|         0|            0|            0|  0.00%|                elif prefix_skip1 is not None:
   482|         0|            0|            0|  0.00%|                    prefix_skip = len(prefix) + prefix_skip1
   483|         0|            0|            0|  0.00%|            prefix.extend(prefix1)
   484|         0|            0|            0|  0.00%|            if not got_all:
   485|         0|            0|            0|  0.00%|                break
   486|         0|            0|            0|  0.00%|        else:
   487|         1|  7.62939e-06|  7.62939e-06|  0.00%|            break
   488|         0|            0|            0|  0.00%|    else:
   489|         0|            0|            0|  0.00%|        return prefix, prefix_skip, True
   490|         1|  6.91414e-06|  6.91414e-06|  0.00%|    return prefix, prefix_skip, False
   491|         0|            0|            0|  0.00%|
   492|         1|  2.02656e-05|  2.02656e-05|  0.00%|def _get_charset_prefix(pattern, flags):
   493|         0|            0|            0|  0.00%|    while True:
   494|         1|  8.58307e-06|  8.58307e-06|  0.00%|        if not pattern.data:
   495|         0|            0|            0|  0.00%|            return None
   496|         1|  7.15256e-06|  7.15256e-06|  0.00%|        op, av = pattern.data[0]
   497|         1|   6.4373e-06|   6.4373e-06|  0.00%|        if op is not SUBPATTERN:
   498|         1|   6.4373e-06|   6.4373e-06|  0.00%|            break
   499|         0|            0|            0|  0.00%|        group, add_flags, del_flags, pattern = av
   500|         0|            0|            0|  0.00%|        flags = _combine_flags(flags, add_flags, del_flags)
   501|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:
   502|         0|            0|            0|  0.00%|            return None
   503|         0|            0|            0|  0.00%|
   504|         1|  2.38419e-05|  2.38419e-05|  0.00%|    iscased = _get_iscased(flags)
(call)|         1|  1.40667e-05|  1.40667e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:453 _get_iscased
   505|         1|  7.39098e-06|  7.39098e-06|  0.00%|    if op is LITERAL:
   506|         0|            0|            0|  0.00%|        if iscased and iscased(av):
   507|         0|            0|            0|  0.00%|            return None
   508|         0|            0|            0|  0.00%|        return [(op, av)]
   509|         1|  6.67572e-06|  6.67572e-06|  0.00%|    elif op is BRANCH:
   510|         1|   6.4373e-06|   6.4373e-06|  0.00%|        charset = []
   511|         1|   6.4373e-06|   6.4373e-06|  0.00%|        charsetappend = charset.append
   512|         1|   6.4373e-06|   6.4373e-06|  0.00%|        for p in av[1]:
   513|         1|  2.55108e-05|  2.55108e-05|  0.00%|            if not p:
(call)|         1|  1.88351e-05|  1.88351e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:160 __len__
   514|         0|            0|            0|  0.00%|                return None
   515|         1|  2.43187e-05|  2.43187e-05|  0.00%|            op, av = p[0]
(call)|         1|  1.57356e-05|  1.57356e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:164 __getitem__
   516|         1|  7.86781e-06|  7.86781e-06|  0.00%|            if op is LITERAL and not (iscased and iscased(av)):
   517|         0|            0|            0|  0.00%|                charsetappend((op, av))
   518|         0|            0|            0|  0.00%|            else:
   519|         1|   6.4373e-06|   6.4373e-06|  0.00%|                return None
   520|         0|            0|            0|  0.00%|        return charset
   521|         0|            0|            0|  0.00%|    elif op is IN:
   522|         0|            0|            0|  0.00%|        charset = av
   523|         0|            0|            0|  0.00%|        if iscased:
   524|         0|            0|            0|  0.00%|            for op, av in charset:
   525|         0|            0|            0|  0.00%|                if op is LITERAL:
   526|         0|            0|            0|  0.00%|                    if iscased(av):
   527|         0|            0|            0|  0.00%|                        return None
   528|         0|            0|            0|  0.00%|                elif op is RANGE:
   529|         0|            0|            0|  0.00%|                    if av[1] > 0xffff:
   530|         0|            0|            0|  0.00%|                        return None
   531|         0|            0|            0|  0.00%|                    if any(map(iscased, range(av[0], av[1]+1))):
   532|         0|            0|            0|  0.00%|                        return None
   533|         0|            0|            0|  0.00%|        return charset
   534|         0|            0|            0|  0.00%|    return None
   535|         0|            0|            0|  0.00%|
   536|         2|  1.57356e-05|  7.86781e-06|  0.00%|def _compile_info(code, pattern, flags):
   537|         0|            0|            0|  0.00%|    # internal: compile an info block.  in the current version,
   538|         0|            0|            0|  0.00%|    # this contains min/max pattern width, and an optional literal
   539|         0|            0|            0|  0.00%|    # prefix or a character map
   540|         2|  3.48091e-05|  1.74046e-05|  0.00%|    lo, hi = pattern.getwidth()
(call)|         2|  0.000836372|  0.000418186|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:174 getwidth
   541|         2|  1.38283e-05|  6.91414e-06|  0.00%|    if hi > MAXCODE:
   542|         0|            0|            0|  0.00%|        hi = MAXCODE
   543|         2|  1.21593e-05|  6.07967e-06|  0.00%|    if lo == 0:
   544|         1|  8.82149e-06|  8.82149e-06|  0.00%|        code.extend([INFO, 4, 0, lo, hi])
   545|         1|  9.29832e-06|  9.29832e-06|  0.00%|        return
   546|         0|            0|            0|  0.00%|    # look for a literal prefix
   547|         1|  6.91414e-06|  6.91414e-06|  0.00%|    prefix = []
   548|         1|  6.67572e-06|  6.67572e-06|  0.00%|    prefix_skip = 0
   549|         1|  6.67572e-06|  6.67572e-06|  0.00%|    charset = [] # not used
   550|         1|  6.91414e-06|  6.91414e-06|  0.00%|    if not (flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE):
   551|         0|            0|            0|  0.00%|        # look for literal prefix
   552|         1|  2.86102e-05|  2.86102e-05|  0.00%|        prefix, prefix_skip, got_all = _get_literal_prefix(pattern, flags)
(call)|         1|  0.000183821|  0.000183821|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:461 _get_literal_prefix
   553|         0|            0|            0|  0.00%|        # if no prefix, look for charset prefix
   554|         1|  7.15256e-06|  7.15256e-06|  0.00%|        if not prefix:
   555|         1|   2.0504e-05|   2.0504e-05|  0.00%|            charset = _get_charset_prefix(pattern, flags)
(call)|         1|  0.000218868|  0.000218868|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:492 _get_charset_prefix
   556|         0|            0|            0|  0.00%|##     if prefix:
   557|         0|            0|            0|  0.00%|##         print("*** PREFIX", prefix, prefix_skip)
   558|         0|            0|            0|  0.00%|##     if charset:
   559|         0|            0|            0|  0.00%|##         print("*** CHARSET", charset)
   560|         0|            0|            0|  0.00%|    # add an info block
   561|         1|  6.91414e-06|  6.91414e-06|  0.00%|    emit = code.append
   562|         1|  9.05991e-06|  9.05991e-06|  0.00%|    emit(INFO)
   563|         1|  1.07288e-05|  1.07288e-05|  0.00%|    skip = len(code); emit(0)
   564|         0|            0|            0|  0.00%|    # literal flag
   565|         1|  6.67572e-06|  6.67572e-06|  0.00%|    mask = 0
   566|         1|  5.72205e-06|  5.72205e-06|  0.00%|    if prefix:
   567|         0|            0|            0|  0.00%|        mask = SRE_INFO_PREFIX
   568|         0|            0|            0|  0.00%|        if prefix_skip is None and got_all:
   569|         0|            0|            0|  0.00%|            mask = mask | SRE_INFO_LITERAL
   570|         1|  6.19888e-06|  6.19888e-06|  0.00%|    elif charset:
   571|         0|            0|            0|  0.00%|        mask = mask | SRE_INFO_CHARSET
   572|         1|  7.62939e-06|  7.62939e-06|  0.00%|    emit(mask)
   573|         0|            0|            0|  0.00%|    # pattern length
   574|         1|  1.35899e-05|  1.35899e-05|  0.00%|    if lo < MAXCODE:
   575|         1|  8.58307e-06|  8.58307e-06|  0.00%|        emit(lo)
   576|         0|            0|            0|  0.00%|    else:
   577|         0|            0|            0|  0.00%|        emit(MAXCODE)
   578|         0|            0|            0|  0.00%|        prefix = prefix[:MAXCODE]
   579|         1|  1.07288e-05|  1.07288e-05|  0.00%|    emit(min(hi, MAXCODE))
   580|         0|            0|            0|  0.00%|    # add literal prefix
   581|         1|   6.4373e-06|   6.4373e-06|  0.00%|    if prefix:
   582|         0|            0|            0|  0.00%|        emit(len(prefix)) # length
   583|         0|            0|            0|  0.00%|        if prefix_skip is None:
   584|         0|            0|            0|  0.00%|            prefix_skip =  len(prefix)
   585|         0|            0|            0|  0.00%|        emit(prefix_skip) # skip
   586|         0|            0|            0|  0.00%|        code.extend(prefix)
   587|         0|            0|            0|  0.00%|        # generate overlap table
   588|         0|            0|            0|  0.00%|        code.extend(_generate_overlap_table(prefix))
   589|         1|  5.96046e-06|  5.96046e-06|  0.00%|    elif charset:
   590|         0|            0|            0|  0.00%|        charset, hascased = _optimize_charset(charset)
   591|         0|            0|            0|  0.00%|        assert not hascased
   592|         0|            0|            0|  0.00%|        _compile_charset(charset, flags, code)
   593|         1|  8.34465e-06|  8.34465e-06|  0.00%|    code[skip] = len(code) - skip
   594|         0|            0|            0|  0.00%|
   595|         4|  2.83718e-05|  7.09295e-06|  0.00%|def isstring(obj):
   596|         4|  3.48091e-05|  8.70228e-06|  0.00%|    return isinstance(obj, (str, bytes))
   597|         0|            0|            0|  0.00%|
   598|         2|  1.14441e-05|  5.72205e-06|  0.00%|def _code(p, flags):
   599|         0|            0|            0|  0.00%|
   600|         2|  1.88351e-05|  9.41753e-06|  0.00%|    flags = p.state.flags | flags
   601|         2|  9.77516e-06|  4.88758e-06|  0.00%|    code = []
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|    # compile info block
   604|         2|  5.36442e-05|  2.68221e-05|  0.00%|    _compile_info(code, p, flags)
(call)|         2|   0.00152373|  0.000761867|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:536 _compile_info
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    # compile the pattern
   607|         2|   4.3869e-05|  2.19345e-05|  0.00%|    _compile(code, p.data, flags)
(call)|         2|     0.110753|    0.0553763|  0.08%|# /opt/conda/lib/python3.8/sre_compile.py:71 _compile
   608|         0|            0|            0|  0.00%|
   609|         2|  2.57492e-05|  1.28746e-05|  0.00%|    code.append(SUCCESS)
   610|         0|            0|            0|  0.00%|
   611|         2|   1.0252e-05|    5.126e-06|  0.00%|    return code
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|def _hex_code(code):
   614|         0|            0|            0|  0.00%|    return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|def dis(code):
   617|         0|            0|            0|  0.00%|    import sys
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    labels = set()
   620|         0|            0|            0|  0.00%|    level = 0
   621|         0|            0|            0|  0.00%|    offset_width = len(str(len(code) - 1))
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    def dis_(start, end):
   624|         0|            0|            0|  0.00%|        def print_(*args, to=None):
   625|         0|            0|            0|  0.00%|            if to is not None:
   626|         0|            0|            0|  0.00%|                labels.add(to)
   627|         0|            0|            0|  0.00%|                args += ('(to %d)' % (to,),)
   628|         0|            0|            0|  0.00%|            print('%*d%s ' % (offset_width, start, ':' if start in labels else '.'),
   629|         0|            0|            0|  0.00%|                  end='  '*(level-1))
   630|         0|            0|            0|  0.00%|            print(*args)
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|        def print_2(*args):
   633|         0|            0|            0|  0.00%|            print(end=' '*(offset_width + 2*level))
   634|         0|            0|            0|  0.00%|            print(*args)
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|        nonlocal level
   637|         0|            0|            0|  0.00%|        level += 1
   638|         0|            0|            0|  0.00%|        i = start
   639|         0|            0|            0|  0.00%|        while i < end:
   640|         0|            0|            0|  0.00%|            start = i
   641|         0|            0|            0|  0.00%|            op = code[i]
   642|         0|            0|            0|  0.00%|            i += 1
   643|         0|            0|            0|  0.00%|            op = OPCODES[op]
   644|         0|            0|            0|  0.00%|            if op in (SUCCESS, FAILURE, ANY, ANY_ALL,
   645|         0|            0|            0|  0.00%|                      MAX_UNTIL, MIN_UNTIL, NEGATE):
   646|         0|            0|            0|  0.00%|                print_(op)
   647|         0|            0|            0|  0.00%|            elif op in (LITERAL, NOT_LITERAL,
   648|         0|            0|            0|  0.00%|                        LITERAL_IGNORE, NOT_LITERAL_IGNORE,
   649|         0|            0|            0|  0.00%|                        LITERAL_UNI_IGNORE, NOT_LITERAL_UNI_IGNORE,
   650|         0|            0|            0|  0.00%|                        LITERAL_LOC_IGNORE, NOT_LITERAL_LOC_IGNORE):
   651|         0|            0|            0|  0.00%|                arg = code[i]
   652|         0|            0|            0|  0.00%|                i += 1
   653|         0|            0|            0|  0.00%|                print_(op, '%#02x (%r)' % (arg, chr(arg)))
   654|         0|            0|            0|  0.00%|            elif op is AT:
   655|         0|            0|            0|  0.00%|                arg = code[i]
   656|         0|            0|            0|  0.00%|                i += 1
   657|         0|            0|            0|  0.00%|                arg = str(ATCODES[arg])
   658|         0|            0|            0|  0.00%|                assert arg[:3] == 'AT_'
   659|         0|            0|            0|  0.00%|                print_(op, arg[3:])
   660|         0|            0|            0|  0.00%|            elif op is CATEGORY:
   661|         0|            0|            0|  0.00%|                arg = code[i]
   662|         0|            0|            0|  0.00%|                i += 1
   663|         0|            0|            0|  0.00%|                arg = str(CHCODES[arg])
   664|         0|            0|            0|  0.00%|                assert arg[:9] == 'CATEGORY_'
   665|         0|            0|            0|  0.00%|                print_(op, arg[9:])
   666|         0|            0|            0|  0.00%|            elif op in (IN, IN_IGNORE, IN_UNI_IGNORE, IN_LOC_IGNORE):
   667|         0|            0|            0|  0.00%|                skip = code[i]
   668|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   669|         0|            0|            0|  0.00%|                dis_(i+1, i+skip)
   670|         0|            0|            0|  0.00%|                i += skip
   671|         0|            0|            0|  0.00%|            elif op in (RANGE, RANGE_UNI_IGNORE):
   672|         0|            0|            0|  0.00%|                lo, hi = code[i: i+2]
   673|         0|            0|            0|  0.00%|                i += 2
   674|         0|            0|            0|  0.00%|                print_(op, '%#02x %#02x (%r-%r)' % (lo, hi, chr(lo), chr(hi)))
   675|         0|            0|            0|  0.00%|            elif op is CHARSET:
   676|         0|            0|            0|  0.00%|                print_(op, _hex_code(code[i: i + 256//_CODEBITS]))
   677|         0|            0|            0|  0.00%|                i += 256//_CODEBITS
   678|         0|            0|            0|  0.00%|            elif op is BIGCHARSET:
   679|         0|            0|            0|  0.00%|                arg = code[i]
   680|         0|            0|            0|  0.00%|                i += 1
   681|         0|            0|            0|  0.00%|                mapping = list(b''.join(x.to_bytes(_sre.CODESIZE, sys.byteorder)
   682|         0|            0|            0|  0.00%|                                        for x in code[i: i + 256//_sre.CODESIZE]))
   683|         0|            0|            0|  0.00%|                print_(op, arg, mapping)
   684|         0|            0|            0|  0.00%|                i += 256//_sre.CODESIZE
   685|         0|            0|            0|  0.00%|                level += 1
   686|         0|            0|            0|  0.00%|                for j in range(arg):
   687|         0|            0|            0|  0.00%|                    print_2(_hex_code(code[i: i + 256//_CODEBITS]))
   688|         0|            0|            0|  0.00%|                    i += 256//_CODEBITS
   689|         0|            0|            0|  0.00%|                level -= 1
   690|         0|            0|            0|  0.00%|            elif op in (MARK, GROUPREF, GROUPREF_IGNORE, GROUPREF_UNI_IGNORE,
   691|         0|            0|            0|  0.00%|                        GROUPREF_LOC_IGNORE):
   692|         0|            0|            0|  0.00%|                arg = code[i]
   693|         0|            0|            0|  0.00%|                i += 1
   694|         0|            0|            0|  0.00%|                print_(op, arg)
   695|         0|            0|            0|  0.00%|            elif op is JUMP:
   696|         0|            0|            0|  0.00%|                skip = code[i]
   697|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   698|         0|            0|            0|  0.00%|                i += 1
   699|         0|            0|            0|  0.00%|            elif op is BRANCH:
   700|         0|            0|            0|  0.00%|                skip = code[i]
   701|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   702|         0|            0|            0|  0.00%|                while skip:
   703|         0|            0|            0|  0.00%|                    dis_(i+1, i+skip)
   704|         0|            0|            0|  0.00%|                    i += skip
   705|         0|            0|            0|  0.00%|                    start = i
   706|         0|            0|            0|  0.00%|                    skip = code[i]
   707|         0|            0|            0|  0.00%|                    if skip:
   708|         0|            0|            0|  0.00%|                        print_('branch', skip, to=i+skip)
   709|         0|            0|            0|  0.00%|                    else:
   710|         0|            0|            0|  0.00%|                        print_(FAILURE)
   711|         0|            0|            0|  0.00%|                i += 1
   712|         0|            0|            0|  0.00%|            elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE):
   713|         0|            0|            0|  0.00%|                skip, min, max = code[i: i+3]
   714|         0|            0|            0|  0.00%|                if max == MAXREPEAT:
   715|         0|            0|            0|  0.00%|                    max = 'MAXREPEAT'
   716|         0|            0|            0|  0.00%|                print_(op, skip, min, max, to=i+skip)
   717|         0|            0|            0|  0.00%|                dis_(i+3, i+skip)
   718|         0|            0|            0|  0.00%|                i += skip
   719|         0|            0|            0|  0.00%|            elif op is GROUPREF_EXISTS:
   720|         0|            0|            0|  0.00%|                arg, skip = code[i: i+2]
   721|         0|            0|            0|  0.00%|                print_(op, arg, skip, to=i+skip)
   722|         0|            0|            0|  0.00%|                i += 2
   723|         0|            0|            0|  0.00%|            elif op in (ASSERT, ASSERT_NOT):
   724|         0|            0|            0|  0.00%|                skip, arg = code[i: i+2]
   725|         0|            0|            0|  0.00%|                print_(op, skip, arg, to=i+skip)
   726|         0|            0|            0|  0.00%|                dis_(i+2, i+skip)
   727|         0|            0|            0|  0.00%|                i += skip
   728|         0|            0|            0|  0.00%|            elif op is INFO:
   729|         0|            0|            0|  0.00%|                skip, flags, min, max = code[i: i+4]
   730|         0|            0|            0|  0.00%|                if max == MAXREPEAT:
   731|         0|            0|            0|  0.00%|                    max = 'MAXREPEAT'
   732|         0|            0|            0|  0.00%|                print_(op, skip, bin(flags), min, max, to=i+skip)
   733|         0|            0|            0|  0.00%|                start = i+4
   734|         0|            0|            0|  0.00%|                if flags & SRE_INFO_PREFIX:
   735|         0|            0|            0|  0.00%|                    prefix_len, prefix_skip = code[i+4: i+6]
   736|         0|            0|            0|  0.00%|                    print_2('  prefix_skip', prefix_skip)
   737|         0|            0|            0|  0.00%|                    start = i + 6
   738|         0|            0|            0|  0.00%|                    prefix = code[start: start+prefix_len]
   739|         0|            0|            0|  0.00%|                    print_2('  prefix',
   740|         0|            0|            0|  0.00%|                            '[%s]' % ', '.join('%#02x' % x for x in prefix),
   741|         0|            0|            0|  0.00%|                            '(%r)' % ''.join(map(chr, prefix)))
   742|         0|            0|            0|  0.00%|                    start += prefix_len
   743|         0|            0|            0|  0.00%|                    print_2('  overlap', code[start: start+prefix_len])
   744|         0|            0|            0|  0.00%|                    start += prefix_len
   745|         0|            0|            0|  0.00%|                if flags & SRE_INFO_CHARSET:
   746|         0|            0|            0|  0.00%|                    level += 1
   747|         0|            0|            0|  0.00%|                    print_2('in')
   748|         0|            0|            0|  0.00%|                    dis_(start, i+skip)
   749|         0|            0|            0|  0.00%|                    level -= 1
   750|         0|            0|            0|  0.00%|                i += skip
   751|         0|            0|            0|  0.00%|            else:
   752|         0|            0|            0|  0.00%|                raise ValueError(op)
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|        level -= 1
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|    dis_(0, len(code))
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|
   759|         2|  1.74046e-05|  8.70228e-06|  0.00%|def compile(p, flags=0):
   760|         0|            0|            0|  0.00%|    # internal: convert pattern list to internal format
   761|         0|            0|            0|  0.00%|
   762|         2|  2.98023e-05|  1.49012e-05|  0.00%|    if isstring(p):
(call)|         2|  2.16961e-05|   1.0848e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:595 isstring
   763|         2|  1.14441e-05|  5.72205e-06|  0.00%|        pattern = p
   764|         2|  4.41074e-05|  2.20537e-05|  0.00%|        p = sre_parse.parse(p, flags)
(call)|         2|     0.276807|     0.138404|  0.20%|# /opt/conda/lib/python3.8/sre_parse.py:937 parse
   765|         0|            0|            0|  0.00%|    else:
   766|         0|            0|            0|  0.00%|        pattern = None
   767|         0|            0|            0|  0.00%|
   768|         2|  3.43323e-05|  1.71661e-05|  0.00%|    code = _code(p, flags)
(call)|         2|      0.11245|    0.0562249|  0.08%|# /opt/conda/lib/python3.8/sre_compile.py:598 _code
   769|         0|            0|            0|  0.00%|
   770|         2|  1.23978e-05|  6.19888e-06|  0.00%|    if flags & SRE_FLAG_DEBUG:
   771|         0|            0|            0|  0.00%|        print()
   772|         0|            0|            0|  0.00%|        dis(code)
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    # map in either direction
   775|         2|  1.12057e-05|  5.60284e-06|  0.00%|    groupindex = p.state.groupdict
   776|         2|   3.0756e-05|   1.5378e-05|  0.00%|    indexgroup = [None] * p.state.groups
(call)|         2|  2.24113e-05|  1.12057e-05|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:81 groups
   777|         2|   1.7643e-05|  8.82149e-06|  0.00%|    for k, i in groupindex.items():
   778|         0|            0|            0|  0.00%|        indexgroup[i] = k
   779|         0|            0|            0|  0.00%|
   780|         4|  5.79357e-05|  1.44839e-05|  0.00%|    return _sre.compile(
   781|         2|  1.19209e-05|  5.96046e-06|  0.00%|        pattern, flags | p.state.flags, code,
   782|         2|  2.76566e-05|  1.38283e-05|  0.00%|        p.state.groups-1,
(call)|         2|  1.97887e-05|  9.89437e-06|  0.00%|# /opt/conda/lib/python3.8/sre_parse.py:81 groups
   783|         2|  1.26362e-05|  6.31809e-06|  0.00%|        groupindex, tuple(indexgroup)
   784|         0|            0|            0|  0.00%|        )
File: /opt/conda/lib/python3.8/tokenize.py
File duration: 0.0909226s (0.07%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Tokenization help for Python programs.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|tokenize(readline) is a generator that breaks a stream of bytes into
     4|         0|            0|            0|  0.00%|Python tokens.  It decodes the bytes according to PEP-0263 for
     5|         0|            0|            0|  0.00%|determining source file encoding.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|It accepts a readline-like method which is called repeatedly to get the
     8|         0|            0|            0|  0.00%|next line of input (or b"" for EOF).  It generates 5-tuples with these
     9|         0|            0|            0|  0.00%|members:
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|    the token type (see token.py)
    12|         0|            0|            0|  0.00%|    the token (a string)
    13|         0|            0|            0|  0.00%|    the starting (row, column) indices of the token (a 2-tuple of ints)
    14|         0|            0|            0|  0.00%|    the ending (row, column) indices of the token (a 2-tuple of ints)
    15|         0|            0|            0|  0.00%|    the original line (string)
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|It is designed to match the working of the Python tokenizer exactly, except
    18|         0|            0|            0|  0.00%|that it produces COMMENT tokens for comments and gives type OP for all
    19|         0|            0|            0|  0.00%|operators.  Additionally, all token lists start with an ENCODING token
    20|         0|            0|            0|  0.00%|which tells you which encoding was used to decode the bytes stream.
    21|         0|            0|            0|  0.00%|"""
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|__author__ = 'Ka-Ping Yee <ping@lfw.org>'
    24|         0|            0|            0|  0.00%|__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '
    25|         0|            0|            0|  0.00%|               'Skip Montanaro, Raymond Hettinger, Trent Nelson, '
    26|         0|            0|            0|  0.00%|               'Michael Foord')
    27|         0|            0|            0|  0.00%|from builtins import open as _builtin_open
    28|         0|            0|            0|  0.00%|from codecs import lookup, BOM_UTF8
    29|         0|            0|            0|  0.00%|import collections
    30|         0|            0|            0|  0.00%|from io import TextIOWrapper
    31|         0|            0|            0|  0.00%|import itertools as _itertools
    32|         0|            0|            0|  0.00%|import re
    33|         0|            0|            0|  0.00%|import sys
    34|         0|            0|            0|  0.00%|from token import *
    35|         0|            0|            0|  0.00%|from token import EXACT_TOKEN_TYPES
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|cookie_re = re.compile(r'^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)', re.ASCII)
    38|         0|            0|            0|  0.00%|blank_re = re.compile(br'^[ \t\f]*(?:[#\r\n]|$)', re.ASCII)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|import token
    41|         0|            0|            0|  0.00%|__all__ = token.__all__ + ["tokenize", "generate_tokens", "detect_encoding",
    42|         0|            0|            0|  0.00%|                           "untokenize", "TokenInfo"]
    43|         0|            0|            0|  0.00%|del token
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|class TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):
    46|         0|            0|            0|  0.00%|    def __repr__(self):
    47|         0|            0|            0|  0.00%|        annotated_type = '%d (%s)' % (self.type, tok_name[self.type])
    48|         0|            0|            0|  0.00%|        return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %
    49|         0|            0|            0|  0.00%|                self._replace(type=annotated_type))
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    @property
    52|         0|            0|            0|  0.00%|    def exact_type(self):
    53|         0|            0|            0|  0.00%|        if self.type == OP and self.string in EXACT_TOKEN_TYPES:
    54|         0|            0|            0|  0.00%|            return EXACT_TOKEN_TYPES[self.string]
    55|         0|            0|            0|  0.00%|        else:
    56|         0|            0|            0|  0.00%|            return self.type
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|def group(*choices): return '(' + '|'.join(choices) + ')'
    59|         0|            0|            0|  0.00%|def any(*choices): return group(*choices) + '*'
    60|         0|            0|            0|  0.00%|def maybe(*choices): return group(*choices) + '?'
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|# Note: we use unicode matching for names ("\w") but ascii matching for
    63|         0|            0|            0|  0.00%|# number literals.
    64|         0|            0|            0|  0.00%|Whitespace = r'[ \f\t]*'
    65|         0|            0|            0|  0.00%|Comment = r'#[^\r\n]*'
    66|         0|            0|            0|  0.00%|Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
    67|         0|            0|            0|  0.00%|Name = r'\w+'
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|Hexnumber = r'0[xX](?:_?[0-9a-fA-F])+'
    70|         0|            0|            0|  0.00%|Binnumber = r'0[bB](?:_?[01])+'
    71|         0|            0|            0|  0.00%|Octnumber = r'0[oO](?:_?[0-7])+'
    72|         0|            0|            0|  0.00%|Decnumber = r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'
    73|         0|            0|            0|  0.00%|Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)
    74|         0|            0|            0|  0.00%|Exponent = r'[eE][-+]?[0-9](?:_?[0-9])*'
    75|         0|            0|            0|  0.00%|Pointfloat = group(r'[0-9](?:_?[0-9])*\.(?:[0-9](?:_?[0-9])*)?',
    76|         0|            0|            0|  0.00%|                   r'\.[0-9](?:_?[0-9])*') + maybe(Exponent)
    77|         0|            0|            0|  0.00%|Expfloat = r'[0-9](?:_?[0-9])*' + Exponent
    78|         0|            0|            0|  0.00%|Floatnumber = group(Pointfloat, Expfloat)
    79|         0|            0|            0|  0.00%|Imagnumber = group(r'[0-9](?:_?[0-9])*[jJ]', Floatnumber + r'[jJ]')
    80|         0|            0|            0|  0.00%|Number = group(Imagnumber, Floatnumber, Intnumber)
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|# Return the empty string, plus all of the valid string prefixes.
    83|         0|            0|            0|  0.00%|def _all_string_prefixes():
    84|         0|            0|            0|  0.00%|    # The valid string prefixes. Only contain the lower case versions,
    85|         0|            0|            0|  0.00%|    #  and don't contain any permutations (include 'fr', but not
    86|         0|            0|            0|  0.00%|    #  'rf'). The various permutations will be generated.
    87|         0|            0|            0|  0.00%|    _valid_string_prefixes = ['b', 'r', 'u', 'f', 'br', 'fr']
    88|         0|            0|            0|  0.00%|    # if we add binary f-strings, add: ['fb', 'fbr']
    89|         0|            0|            0|  0.00%|    result = {''}
    90|         0|            0|            0|  0.00%|    for prefix in _valid_string_prefixes:
    91|         0|            0|            0|  0.00%|        for t in _itertools.permutations(prefix):
    92|         0|            0|            0|  0.00%|            # create a list with upper and lower versions of each
    93|         0|            0|            0|  0.00%|            #  character
    94|         0|            0|            0|  0.00%|            for u in _itertools.product(*[(c, c.upper()) for c in t]):
    95|         0|            0|            0|  0.00%|                result.add(''.join(u))
    96|         0|            0|            0|  0.00%|    return result
    97|         0|            0|            0|  0.00%|
    98|       369|   0.00165987|  4.49829e-06|  0.00%|def _compile(expr):
    99|       369|   0.00433517|  1.17484e-05|  0.00%|    return re.compile(expr, re.UNICODE)
(call)|       369|     0.388362|   0.00105247|  0.28%|# /opt/conda/lib/python3.8/re.py:250 compile
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|# Note that since _all_string_prefixes includes the empty string,
   102|         0|            0|            0|  0.00%|#  StringPrefix can be the empty string (making it optional).
   103|         0|            0|            0|  0.00%|StringPrefix = group(*_all_string_prefixes())
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|# Tail end of ' string.
   106|         0|            0|            0|  0.00%|Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
   107|         0|            0|            0|  0.00%|# Tail end of " string.
   108|         0|            0|            0|  0.00%|Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
   109|         0|            0|            0|  0.00%|# Tail end of ''' string.
   110|         0|            0|            0|  0.00%|Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
   111|         0|            0|            0|  0.00%|# Tail end of """ string.
   112|         0|            0|            0|  0.00%|Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
   113|         0|            0|            0|  0.00%|Triple = group(StringPrefix + "'''", StringPrefix + '"""')
   114|         0|            0|            0|  0.00%|# Single-line ' or " string.
   115|         0|            0|            0|  0.00%|String = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
   116|         0|            0|            0|  0.00%|               StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*"')
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|# Sorting in reverse order puts the long operators before their prefixes.
   119|         0|            0|            0|  0.00%|# Otherwise if = came before ==, == would get recognized as two instances
   120|         0|            0|            0|  0.00%|# of =.
   121|         0|            0|            0|  0.00%|Special = group(*map(re.escape, sorted(EXACT_TOKEN_TYPES, reverse=True)))
   122|         0|            0|            0|  0.00%|Funny = group(r'\r?\n', Special)
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|PlainToken = group(Number, Funny, String, Name)
   125|         0|            0|            0|  0.00%|Token = Ignore + PlainToken
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|# First (or only) line of ' or " string.
   128|         0|            0|            0|  0.00%|ContStr = group(StringPrefix + r"'[^\n'\\]*(?:\\.[^\n'\\]*)*" +
   129|         0|            0|            0|  0.00%|                group("'", r'\\\r?\n'),
   130|         0|            0|            0|  0.00%|                StringPrefix + r'"[^\n"\\]*(?:\\.[^\n"\\]*)*' +
   131|         0|            0|            0|  0.00%|                group('"', r'\\\r?\n'))
   132|         0|            0|            0|  0.00%|PseudoExtras = group(r'\\\r?\n|\Z', Comment, Triple)
   133|         0|            0|            0|  0.00%|PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|# For a given string prefix plus quotes, endpats maps it to a regex
   136|         0|            0|            0|  0.00%|#  to match the remainder of that string. _prefix can be empty, for
   137|         0|            0|            0|  0.00%|#  a normal single or triple quoted string (with no prefix).
   138|         0|            0|            0|  0.00%|endpats = {}
   139|         0|            0|            0|  0.00%|for _prefix in _all_string_prefixes():
   140|         0|            0|            0|  0.00%|    endpats[_prefix + "'"] = Single
   141|         0|            0|            0|  0.00%|    endpats[_prefix + '"'] = Double
   142|         0|            0|            0|  0.00%|    endpats[_prefix + "'''"] = Single3
   143|         0|            0|            0|  0.00%|    endpats[_prefix + '"""'] = Double3
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|# A set of all of the single and triple quoted string prefixes,
   146|         0|            0|            0|  0.00%|#  including the opening quotes.
   147|         0|            0|            0|  0.00%|single_quoted = set()
   148|         0|            0|            0|  0.00%|triple_quoted = set()
   149|         0|            0|            0|  0.00%|for t in _all_string_prefixes():
   150|         0|            0|            0|  0.00%|    for u in (t + '"', t + "'"):
   151|         0|            0|            0|  0.00%|        single_quoted.add(u)
   152|         0|            0|            0|  0.00%|    for u in (t + '"""', t + "'''"):
   153|         0|            0|            0|  0.00%|        triple_quoted.add(u)
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|tabsize = 8
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|class TokenError(Exception): pass
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|class StopTokenizing(Exception): pass
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|class Untokenizer:
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    def __init__(self):
   165|         0|            0|            0|  0.00%|        self.tokens = []
   166|         0|            0|            0|  0.00%|        self.prev_row = 1
   167|         0|            0|            0|  0.00%|        self.prev_col = 0
   168|         0|            0|            0|  0.00%|        self.encoding = None
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    def add_whitespace(self, start):
   171|         0|            0|            0|  0.00%|        row, col = start
   172|         0|            0|            0|  0.00%|        if row < self.prev_row or row == self.prev_row and col < self.prev_col:
   173|         0|            0|            0|  0.00%|            raise ValueError("start ({},{}) precedes previous end ({},{})"
   174|         0|            0|            0|  0.00%|                             .format(row, col, self.prev_row, self.prev_col))
   175|         0|            0|            0|  0.00%|        row_offset = row - self.prev_row
   176|         0|            0|            0|  0.00%|        if row_offset:
   177|         0|            0|            0|  0.00%|            self.tokens.append("\\\n" * row_offset)
   178|         0|            0|            0|  0.00%|            self.prev_col = 0
   179|         0|            0|            0|  0.00%|        col_offset = col - self.prev_col
   180|         0|            0|            0|  0.00%|        if col_offset:
   181|         0|            0|            0|  0.00%|            self.tokens.append(" " * col_offset)
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    def untokenize(self, iterable):
   184|         0|            0|            0|  0.00%|        it = iter(iterable)
   185|         0|            0|            0|  0.00%|        indents = []
   186|         0|            0|            0|  0.00%|        startline = False
   187|         0|            0|            0|  0.00%|        for t in it:
   188|         0|            0|            0|  0.00%|            if len(t) == 2:
   189|         0|            0|            0|  0.00%|                self.compat(t, it)
   190|         0|            0|            0|  0.00%|                break
   191|         0|            0|            0|  0.00%|            tok_type, token, start, end, line = t
   192|         0|            0|            0|  0.00%|            if tok_type == ENCODING:
   193|         0|            0|            0|  0.00%|                self.encoding = token
   194|         0|            0|            0|  0.00%|                continue
   195|         0|            0|            0|  0.00%|            if tok_type == ENDMARKER:
   196|         0|            0|            0|  0.00%|                break
   197|         0|            0|            0|  0.00%|            if tok_type == INDENT:
   198|         0|            0|            0|  0.00%|                indents.append(token)
   199|         0|            0|            0|  0.00%|                continue
   200|         0|            0|            0|  0.00%|            elif tok_type == DEDENT:
   201|         0|            0|            0|  0.00%|                indents.pop()
   202|         0|            0|            0|  0.00%|                self.prev_row, self.prev_col = end
   203|         0|            0|            0|  0.00%|                continue
   204|         0|            0|            0|  0.00%|            elif tok_type in (NEWLINE, NL):
   205|         0|            0|            0|  0.00%|                startline = True
   206|         0|            0|            0|  0.00%|            elif startline and indents:
   207|         0|            0|            0|  0.00%|                indent = indents[-1]
   208|         0|            0|            0|  0.00%|                if start[1] >= len(indent):
   209|         0|            0|            0|  0.00%|                    self.tokens.append(indent)
   210|         0|            0|            0|  0.00%|                    self.prev_col = len(indent)
   211|         0|            0|            0|  0.00%|                startline = False
   212|         0|            0|            0|  0.00%|            self.add_whitespace(start)
   213|         0|            0|            0|  0.00%|            self.tokens.append(token)
   214|         0|            0|            0|  0.00%|            self.prev_row, self.prev_col = end
   215|         0|            0|            0|  0.00%|            if tok_type in (NEWLINE, NL):
   216|         0|            0|            0|  0.00%|                self.prev_row += 1
   217|         0|            0|            0|  0.00%|                self.prev_col = 0
   218|         0|            0|            0|  0.00%|        return "".join(self.tokens)
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    def compat(self, token, iterable):
   221|         0|            0|            0|  0.00%|        indents = []
   222|         0|            0|            0|  0.00%|        toks_append = self.tokens.append
   223|         0|            0|            0|  0.00%|        startline = token[0] in (NEWLINE, NL)
   224|         0|            0|            0|  0.00%|        prevstring = False
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        for tok in _itertools.chain([token], iterable):
   227|         0|            0|            0|  0.00%|            toknum, tokval = tok[:2]
   228|         0|            0|            0|  0.00%|            if toknum == ENCODING:
   229|         0|            0|            0|  0.00%|                self.encoding = tokval
   230|         0|            0|            0|  0.00%|                continue
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|            if toknum in (NAME, NUMBER):
   233|         0|            0|            0|  0.00%|                tokval += ' '
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|            # Insert a space between two consecutive strings
   236|         0|            0|            0|  0.00%|            if toknum == STRING:
   237|         0|            0|            0|  0.00%|                if prevstring:
   238|         0|            0|            0|  0.00%|                    tokval = ' ' + tokval
   239|         0|            0|            0|  0.00%|                prevstring = True
   240|         0|            0|            0|  0.00%|            else:
   241|         0|            0|            0|  0.00%|                prevstring = False
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|            if toknum == INDENT:
   244|         0|            0|            0|  0.00%|                indents.append(tokval)
   245|         0|            0|            0|  0.00%|                continue
   246|         0|            0|            0|  0.00%|            elif toknum == DEDENT:
   247|         0|            0|            0|  0.00%|                indents.pop()
   248|         0|            0|            0|  0.00%|                continue
   249|         0|            0|            0|  0.00%|            elif toknum in (NEWLINE, NL):
   250|         0|            0|            0|  0.00%|                startline = True
   251|         0|            0|            0|  0.00%|            elif startline and indents:
   252|         0|            0|            0|  0.00%|                toks_append(indents[-1])
   253|         0|            0|            0|  0.00%|                startline = False
   254|         0|            0|            0|  0.00%|            toks_append(tokval)
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|def untokenize(iterable):
   258|         0|            0|            0|  0.00%|    """Transform tokens back into Python source code.
   259|         0|            0|            0|  0.00%|    It returns a bytes object, encoded using the ENCODING
   260|         0|            0|            0|  0.00%|    token, which is the first token sequence output by tokenize.
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    Each element returned by the iterable must be a token sequence
   263|         0|            0|            0|  0.00%|    with at least two elements, a token number and token value.  If
   264|         0|            0|            0|  0.00%|    only two tokens are passed, the resulting output is poor.
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    Round-trip invariant for full input:
   267|         0|            0|            0|  0.00%|        Untokenized source will match input source exactly
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|    Round-trip invariant for limited input:
   270|         0|            0|            0|  0.00%|        # Output bytes will tokenize back to the input
   271|         0|            0|            0|  0.00%|        t1 = [tok[:2] for tok in tokenize(f.readline)]
   272|         0|            0|            0|  0.00%|        newcode = untokenize(t1)
   273|         0|            0|            0|  0.00%|        readline = BytesIO(newcode).readline
   274|         0|            0|            0|  0.00%|        t2 = [tok[:2] for tok in tokenize(readline)]
   275|         0|            0|            0|  0.00%|        assert t1 == t2
   276|         0|            0|            0|  0.00%|    """
   277|         0|            0|            0|  0.00%|    ut = Untokenizer()
   278|         0|            0|            0|  0.00%|    out = ut.untokenize(iterable)
   279|         0|            0|            0|  0.00%|    if ut.encoding is not None:
   280|         0|            0|            0|  0.00%|        out = out.encode(ut.encoding)
   281|         0|            0|            0|  0.00%|    return out
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|def _get_normal_name(orig_enc):
   285|         0|            0|            0|  0.00%|    """Imitates get_normal_name in tokenizer.c."""
   286|         0|            0|            0|  0.00%|    # Only care about the first 12 characters.
   287|         0|            0|            0|  0.00%|    enc = orig_enc[:12].lower().replace("_", "-")
   288|         0|            0|            0|  0.00%|    if enc == "utf-8" or enc.startswith("utf-8-"):
   289|         0|            0|            0|  0.00%|        return "utf-8"
   290|         0|            0|            0|  0.00%|    if enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
   291|         0|            0|            0|  0.00%|       enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
   292|         0|            0|            0|  0.00%|        return "iso-8859-1"
   293|         0|            0|            0|  0.00%|    return orig_enc
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|def detect_encoding(readline):
   296|         0|            0|            0|  0.00%|    """
   297|         0|            0|            0|  0.00%|    The detect_encoding() function is used to detect the encoding that should
   298|         0|            0|            0|  0.00%|    be used to decode a Python source file.  It requires one argument, readline,
   299|         0|            0|            0|  0.00%|    in the same way as the tokenize() generator.
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    It will call readline a maximum of twice, and return the encoding used
   302|         0|            0|            0|  0.00%|    (as a string) and a list of any lines (left as bytes) it has read in.
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    It detects the encoding from the presence of a utf-8 bom or an encoding
   305|         0|            0|            0|  0.00%|    cookie as specified in pep-0263.  If both a bom and a cookie are present,
   306|         0|            0|            0|  0.00%|    but disagree, a SyntaxError will be raised.  If the encoding cookie is an
   307|         0|            0|            0|  0.00%|    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
   308|         0|            0|            0|  0.00%|    'utf-8-sig' is returned.
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    If no encoding is specified, then the default of 'utf-8' will be returned.
   311|         0|            0|            0|  0.00%|    """
   312|         0|            0|            0|  0.00%|    try:
   313|         0|            0|            0|  0.00%|        filename = readline.__self__.name
   314|         0|            0|            0|  0.00%|    except AttributeError:
   315|         0|            0|            0|  0.00%|        filename = None
   316|         0|            0|            0|  0.00%|    bom_found = False
   317|         0|            0|            0|  0.00%|    encoding = None
   318|         0|            0|            0|  0.00%|    default = 'utf-8'
   319|         0|            0|            0|  0.00%|    def read_or_stop():
   320|         0|            0|            0|  0.00%|        try:
   321|         0|            0|            0|  0.00%|            return readline()
   322|         0|            0|            0|  0.00%|        except StopIteration:
   323|         0|            0|            0|  0.00%|            return b''
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    def find_cookie(line):
   326|         0|            0|            0|  0.00%|        try:
   327|         0|            0|            0|  0.00%|            # Decode as UTF-8. Either the line is an encoding declaration,
   328|         0|            0|            0|  0.00%|            # in which case it should be pure ASCII, or it must be UTF-8
   329|         0|            0|            0|  0.00%|            # per default encoding.
   330|         0|            0|            0|  0.00%|            line_string = line.decode('utf-8')
   331|         0|            0|            0|  0.00%|        except UnicodeDecodeError:
   332|         0|            0|            0|  0.00%|            msg = "invalid or missing encoding declaration"
   333|         0|            0|            0|  0.00%|            if filename is not None:
   334|         0|            0|            0|  0.00%|                msg = '{} for {!r}'.format(msg, filename)
   335|         0|            0|            0|  0.00%|            raise SyntaxError(msg)
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|        match = cookie_re.match(line_string)
   338|         0|            0|            0|  0.00%|        if not match:
   339|         0|            0|            0|  0.00%|            return None
   340|         0|            0|            0|  0.00%|        encoding = _get_normal_name(match.group(1))
   341|         0|            0|            0|  0.00%|        try:
   342|         0|            0|            0|  0.00%|            codec = lookup(encoding)
   343|         0|            0|            0|  0.00%|        except LookupError:
   344|         0|            0|            0|  0.00%|            # This behaviour mimics the Python interpreter
   345|         0|            0|            0|  0.00%|            if filename is None:
   346|         0|            0|            0|  0.00%|                msg = "unknown encoding: " + encoding
   347|         0|            0|            0|  0.00%|            else:
   348|         0|            0|            0|  0.00%|                msg = "unknown encoding for {!r}: {}".format(filename,
   349|         0|            0|            0|  0.00%|                        encoding)
   350|         0|            0|            0|  0.00%|            raise SyntaxError(msg)
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|        if bom_found:
   353|         0|            0|            0|  0.00%|            if encoding != 'utf-8':
   354|         0|            0|            0|  0.00%|                # This behaviour mimics the Python interpreter
   355|         0|            0|            0|  0.00%|                if filename is None:
   356|         0|            0|            0|  0.00%|                    msg = 'encoding problem: utf-8'
   357|         0|            0|            0|  0.00%|                else:
   358|         0|            0|            0|  0.00%|                    msg = 'encoding problem for {!r}: utf-8'.format(filename)
   359|         0|            0|            0|  0.00%|                raise SyntaxError(msg)
   360|         0|            0|            0|  0.00%|            encoding += '-sig'
   361|         0|            0|            0|  0.00%|        return encoding
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    first = read_or_stop()
   364|         0|            0|            0|  0.00%|    if first.startswith(BOM_UTF8):
   365|         0|            0|            0|  0.00%|        bom_found = True
   366|         0|            0|            0|  0.00%|        first = first[3:]
   367|         0|            0|            0|  0.00%|        default = 'utf-8-sig'
   368|         0|            0|            0|  0.00%|    if not first:
   369|         0|            0|            0|  0.00%|        return default, []
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|    encoding = find_cookie(first)
   372|         0|            0|            0|  0.00%|    if encoding:
   373|         0|            0|            0|  0.00%|        return encoding, [first]
   374|         0|            0|            0|  0.00%|    if not blank_re.match(first):
   375|         0|            0|            0|  0.00%|        return default, [first]
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    second = read_or_stop()
   378|         0|            0|            0|  0.00%|    if not second:
   379|         0|            0|            0|  0.00%|        return default, [first]
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    encoding = find_cookie(second)
   382|         0|            0|            0|  0.00%|    if encoding:
   383|         0|            0|            0|  0.00%|        return encoding, [first, second]
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    return default, [first, second]
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|def open(filename):
   389|         0|            0|            0|  0.00%|    """Open a file in read only mode using the encoding detected by
   390|         0|            0|            0|  0.00%|    detect_encoding().
   391|         0|            0|            0|  0.00%|    """
   392|         0|            0|            0|  0.00%|    buffer = _builtin_open(filename, 'rb')
   393|         0|            0|            0|  0.00%|    try:
   394|         0|            0|            0|  0.00%|        encoding, lines = detect_encoding(buffer.readline)
   395|         0|            0|            0|  0.00%|        buffer.seek(0)
   396|         0|            0|            0|  0.00%|        text = TextIOWrapper(buffer, encoding, line_buffering=True)
   397|         0|            0|            0|  0.00%|        text.mode = 'r'
   398|         0|            0|            0|  0.00%|        return text
   399|         0|            0|            0|  0.00%|    except:
   400|         0|            0|            0|  0.00%|        buffer.close()
   401|         0|            0|            0|  0.00%|        raise
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|def tokenize(readline):
   405|         0|            0|            0|  0.00%|    """
   406|         0|            0|            0|  0.00%|    The tokenize() generator requires one argument, readline, which
   407|         0|            0|            0|  0.00%|    must be a callable object which provides the same interface as the
   408|         0|            0|            0|  0.00%|    readline() method of built-in file objects.  Each call to the function
   409|         0|            0|            0|  0.00%|    should return one line of input as bytes.  Alternatively, readline
   410|         0|            0|            0|  0.00%|    can be a callable function terminating with StopIteration:
   411|         0|            0|            0|  0.00%|        readline = open(myfile, 'rb').__next__  # Example of alternate readline
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    The generator produces 5-tuples with these members: the token type; the
   414|         0|            0|            0|  0.00%|    token string; a 2-tuple (srow, scol) of ints specifying the row and
   415|         0|            0|            0|  0.00%|    column where the token begins in the source; a 2-tuple (erow, ecol) of
   416|         0|            0|            0|  0.00%|    ints specifying the row and column where the token ends in the source;
   417|         0|            0|            0|  0.00%|    and the line on which the token was found.  The line passed is the
   418|         0|            0|            0|  0.00%|    physical line.
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    The first token sequence will always be an ENCODING token
   421|         0|            0|            0|  0.00%|    which tells you which encoding was used to decode the bytes stream.
   422|         0|            0|            0|  0.00%|    """
   423|         0|            0|            0|  0.00%|    encoding, consumed = detect_encoding(readline)
   424|         0|            0|            0|  0.00%|    empty = _itertools.repeat(b"")
   425|         0|            0|            0|  0.00%|    rl_gen = _itertools.chain(consumed, iter(readline, b""), empty)
   426|         0|            0|            0|  0.00%|    return _tokenize(rl_gen.__next__, encoding)
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|
   429|         1|  1.93119e-05|  1.93119e-05|  0.00%|def _tokenize(readline, encoding):
   430|         1|  1.90735e-05|  1.90735e-05|  0.00%|    lnum = parenlev = continued = 0
   431|         1|   1.0252e-05|   1.0252e-05|  0.00%|    numchars = '0123456789'
   432|         1|  9.29832e-06|  9.29832e-06|  0.00%|    contstr, needcont = '', 0
   433|         1|  9.53674e-06|  9.53674e-06|  0.00%|    contline = None
   434|         1|  9.29832e-06|  9.29832e-06|  0.00%|    indents = [0]
   435|         0|            0|            0|  0.00%|
   436|         1|  8.82149e-06|  8.82149e-06|  0.00%|    if encoding is not None:
   437|         0|            0|            0|  0.00%|        if encoding == "utf-8-sig":
   438|         0|            0|            0|  0.00%|            # BOM will already have been stripped.
   439|         0|            0|            0|  0.00%|            encoding = "utf-8"
   440|         0|            0|            0|  0.00%|        yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')
   441|         1|  1.64509e-05|  1.64509e-05|  0.00%|    last_line = b''
   442|         1|  9.29832e-06|  9.29832e-06|  0.00%|    line = b''
   443|         0|            0|            0|  0.00%|    while True:                                # loop over lines in stream
   444|        97|  0.000528336|  5.44676e-06|  0.00%|        try:
   445|         0|            0|            0|  0.00%|            # We capture the value of the line variable here because
   446|         0|            0|            0|  0.00%|            # readline uses the empty string '' to signal end of input,
   447|         0|            0|            0|  0.00%|            # hence `line` itself will always be overwritten at the end
   448|         0|            0|            0|  0.00%|            # of this loop.
   449|        97|  0.000525951|  5.42218e-06|  0.00%|            last_line = line
   450|        97|  0.000552893|  5.69992e-06|  0.00%|            line = readline()
   451|         0|            0|            0|  0.00%|        except StopIteration:
   452|         0|            0|            0|  0.00%|            line = b''
   453|         0|            0|            0|  0.00%|
   454|        97|  0.000542402|  5.59178e-06|  0.00%|        if encoding is not None:
   455|         0|            0|            0|  0.00%|            line = line.decode(encoding)
   456|        97|  0.000516891|  5.32878e-06|  0.00%|        lnum += 1
   457|        97|  0.000732183|  7.54828e-06|  0.00%|        pos, max = 0, len(line)
   458|         0|            0|            0|  0.00%|
   459|        97|  0.000574827|  5.92605e-06|  0.00%|        if contstr:                            # continued string
   460|         0|            0|            0|  0.00%|            if not line:
   461|         0|            0|            0|  0.00%|                raise TokenError("EOF in multi-line string", strstart)
   462|         0|            0|            0|  0.00%|            endmatch = endprog.match(line)
   463|         0|            0|            0|  0.00%|            if endmatch:
   464|         0|            0|            0|  0.00%|                pos = end = endmatch.end(0)
   465|         0|            0|            0|  0.00%|                yield TokenInfo(STRING, contstr + line[:end],
   466|         0|            0|            0|  0.00%|                       strstart, (lnum, end), contline + line)
   467|         0|            0|            0|  0.00%|                contstr, needcont = '', 0
   468|         0|            0|            0|  0.00%|                contline = None
   469|         0|            0|            0|  0.00%|            elif needcont and line[-2:] != '\\\n' and line[-3:] != '\\\r\n':
   470|         0|            0|            0|  0.00%|                yield TokenInfo(ERRORTOKEN, contstr + line,
   471|         0|            0|            0|  0.00%|                           strstart, (lnum, len(line)), contline)
   472|         0|            0|            0|  0.00%|                contstr = ''
   473|         0|            0|            0|  0.00%|                contline = None
   474|         0|            0|            0|  0.00%|                continue
   475|         0|            0|            0|  0.00%|            else:
   476|         0|            0|            0|  0.00%|                contstr = contstr + line
   477|         0|            0|            0|  0.00%|                contline = contline + line
   478|         0|            0|            0|  0.00%|                continue
   479|         0|            0|            0|  0.00%|
   480|        97|  0.000542164|  5.58932e-06|  0.00%|        elif parenlev == 0 and not continued:  # new statement
   481|        95|  0.000511885|  5.38826e-06|  0.00%|            if not line: break
   482|        95|  0.000521898|  5.49367e-06|  0.00%|            column = 0
   483|       715|   0.00388122|  5.42827e-06|  0.00%|            while pos < max:                   # measure leading whitespace
   484|       715|   0.00396276|  5.54231e-06|  0.00%|                if line[pos] == ' ':
   485|       620|   0.00337958|  5.45094e-06|  0.00%|                    column += 1
   486|        95|  0.000536919|  5.65178e-06|  0.00%|                elif line[pos] == '\t':
   487|         0|            0|            0|  0.00%|                    column = (column//tabsize + 1)*tabsize
   488|        95|   0.00053072|  5.58652e-06|  0.00%|                elif line[pos] == '\f':
   489|         0|            0|            0|  0.00%|                    column = 0
   490|         0|            0|            0|  0.00%|                else:
   491|         0|            0|            0|  0.00%|                    break
   492|       620|   0.00337672|  5.44633e-06|  0.00%|                pos += 1
   493|        95|  0.000516176|  5.43343e-06|  0.00%|            if pos == max:
   494|         0|            0|            0|  0.00%|                break
   495|         0|            0|            0|  0.00%|
   496|        95|  0.000559807|   5.8927e-06|  0.00%|            if line[pos] in '#\r\n':           # skip comments or blank lines
   497|        52|  0.000291586|  5.60742e-06|  0.00%|                if line[pos] == '#':
   498|        35|  0.000301361|  8.61032e-06|  0.00%|                    comment_token = line[pos:].rstrip('\r\n')
   499|       105|  0.000996113|  9.48679e-06|  0.00%|                    yield TokenInfo(COMMENT, comment_token,
(call)|        35|  0.000398397|  1.13828e-05|  0.00%|# <string>:1 __new__
   500|        35|  0.000271082|   7.7452e-06|  0.00%|                           (lnum, pos), (lnum, pos + len(comment_token)), line)
   501|        35|  0.000277519|  7.92912e-06|  0.00%|                    pos += len(comment_token)
   502|         0|            0|            0|  0.00%|
   503|       156|   0.00147581|  9.46033e-06|  0.00%|                yield TokenInfo(NL, line[pos:],
(call)|        52|  0.000586748|  1.12836e-05|  0.00%|# <string>:1 __new__
   504|        52|   0.00039959|  7.68441e-06|  0.00%|                           (lnum, pos), (lnum, len(line)), line)
   505|        52|  0.000294209|  5.65786e-06|  0.00%|                continue
   506|         0|            0|            0|  0.00%|
   507|        43|  0.000250578|  5.82739e-06|  0.00%|            if column > indents[-1]:           # count indents or dedents
   508|        10|   7.9155e-05|   7.9155e-06|  0.00%|                indents.append(column)
   509|        20|  0.000236273|  1.18136e-05|  0.00%|                yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
(call)|        10|  0.000116825|  1.16825e-05|  0.00%|# <string>:1 __new__
   510|        52|  0.000299454|  5.75873e-06|  0.00%|            while column < indents[-1]:
   511|        10|  6.96182e-05|  6.96182e-06|  0.00%|                if column not in indents:
   512|         0|            0|            0|  0.00%|                    raise IndentationError(
   513|         0|            0|            0|  0.00%|                        "unindent does not match any outer indentation level",
   514|         0|            0|            0|  0.00%|                        ("<tokenize>", lnum, pos, line))
   515|        10|  6.60419e-05|  6.60419e-06|  0.00%|                indents = indents[:-1]
   516|         0|            0|            0|  0.00%|
   517|        20|  0.000247717|  1.23858e-05|  0.00%|                yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)
(call)|        10|  0.000117302|  1.17302e-05|  0.00%|# <string>:1 __new__
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|        else:                                  # continued statement
   520|         2|  1.09673e-05|  5.48363e-06|  0.00%|            if not line:
   521|         0|            0|            0|  0.00%|                raise TokenError("EOF in multi-line statement", (lnum, 0))
   522|         2|  1.38283e-05|  6.91414e-06|  0.00%|            continued = 0
   523|         0|            0|            0|  0.00%|
   524|       413|   0.00241685|  5.85193e-06|  0.00%|        while pos < max:
   525|       369|   0.00730681|  1.98017e-05|  0.01%|            pseudomatch = _compile(PseudoToken).match(line, pos)
(call)|       369|     0.394357|   0.00106872|  0.29%|# /opt/conda/lib/python3.8/tokenize.py:98 _compile
   526|       369|   0.00235224|  6.37463e-06|  0.00%|            if pseudomatch:                                # scan for tokens
   527|       369|   0.00292468|  7.92596e-06|  0.00%|                start, end = pseudomatch.span(1)
   528|       369|   0.00223351|  6.05286e-06|  0.00%|                spos, epos, pos = (lnum, start), (lnum, end), end
   529|       369|   0.00209689|  5.68263e-06|  0.00%|                if start == end:
   530|         0|            0|            0|  0.00%|                    continue
   531|       369|   0.00229788|  6.22731e-06|  0.00%|                token, initial = line[start:end], line[start]
   532|         0|            0|            0|  0.00%|
   533|       753|   0.00430346|  5.71508e-06|  0.00%|                if (initial in numchars or                 # ordinary number
   534|       384|   0.00219345|  5.71211e-06|  0.00%|                    (initial == '.' and token != '.' and token != '...')):
   535|        22|  0.000254154|  1.15525e-05|  0.00%|                    yield TokenInfo(NUMBER, token, spos, epos, line)
(call)|        11|  0.000140905|  1.28096e-05|  0.00%|# <string>:1 __new__
   536|       358|   0.00200391|  5.59751e-06|  0.00%|                elif initial in '\r\n':
   537|        44|  0.000246525|  5.60284e-06|  0.00%|                    if parenlev > 0:
   538|         4|  4.91142e-05|  1.22786e-05|  0.00%|                        yield TokenInfo(NL, token, spos, epos, line)
(call)|         2|  2.31266e-05|  1.15633e-05|  0.00%|# <string>:1 __new__
   539|         0|            0|            0|  0.00%|                    else:
   540|        84|  0.000952482|  1.13391e-05|  0.00%|                        yield TokenInfo(NEWLINE, token, spos, epos, line)
(call)|        42|  0.000487804|  1.16144e-05|  0.00%|# <string>:1 __new__
   541|         0|            0|            0|  0.00%|
   542|       314|   0.00176668|  5.62637e-06|  0.00%|                elif initial == '#':
   543|         2|  1.64509e-05|  8.22544e-06|  0.00%|                    assert not token.endswith("\n")
   544|         4|  5.19753e-05|  1.29938e-05|  0.00%|                    yield TokenInfo(COMMENT, token, spos, epos, line)
(call)|         2|  2.38419e-05|  1.19209e-05|  0.00%|# <string>:1 __new__
   545|         0|            0|            0|  0.00%|
   546|       312|     0.001858|  5.95512e-06|  0.00%|                elif token in triple_quoted:
   547|         0|            0|            0|  0.00%|                    endprog = _compile(endpats[token])
   548|         0|            0|            0|  0.00%|                    endmatch = endprog.match(line, pos)
   549|         0|            0|            0|  0.00%|                    if endmatch:                           # all on one line
   550|         0|            0|            0|  0.00%|                        pos = endmatch.end(0)
   551|         0|            0|            0|  0.00%|                        token = line[start:pos]
   552|         0|            0|            0|  0.00%|                        yield TokenInfo(STRING, token, spos, (lnum, pos), line)
   553|         0|            0|            0|  0.00%|                    else:
   554|         0|            0|            0|  0.00%|                        strstart = (lnum, start)           # multiple lines
   555|         0|            0|            0|  0.00%|                        contstr = line[start:]
   556|         0|            0|            0|  0.00%|                        contline = line
   557|         0|            0|            0|  0.00%|                        break
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|                # Check up to the first 3 chars of the token to see if
   560|         0|            0|            0|  0.00%|                #  they're in the single_quoted set. If so, they start
   561|         0|            0|            0|  0.00%|                #  a string.
   562|         0|            0|            0|  0.00%|                # We're using the first 3, because we're looking for
   563|         0|            0|            0|  0.00%|                #  "rb'" (for example) at the start of the token. If
   564|         0|            0|            0|  0.00%|                #  we switch to longer prefixes, this needs to be
   565|         0|            0|            0|  0.00%|                #  adjusted.
   566|         0|            0|            0|  0.00%|                # Note that initial == token[:1].
   567|         0|            0|            0|  0.00%|                # Also note that single quote checking must come after
   568|         0|            0|            0|  0.00%|                #  triple quote checking (above).
   569|       912|   0.00519943|  5.70113e-06|  0.00%|                elif (initial in single_quoted or
   570|       300|   0.00185466|  6.18219e-06|  0.00%|                      token[:2] in single_quoted or
   571|       300|   0.00179791|  5.99305e-06|  0.00%|                      token[:3] in single_quoted):
   572|        12|  7.27177e-05|  6.05981e-06|  0.00%|                    if token[-1] == '\n':                  # continued string
   573|         0|            0|            0|  0.00%|                        strstart = (lnum, start)
   574|         0|            0|            0|  0.00%|                        # Again, using the first 3 chars of the
   575|         0|            0|            0|  0.00%|                        #  token. This is looking for the matching end
   576|         0|            0|            0|  0.00%|                        #  regex for the correct type of quote
   577|         0|            0|            0|  0.00%|                        #  character. So it's really looking for
   578|         0|            0|            0|  0.00%|                        #  endpats["'"] or endpats['"'], by trying to
   579|         0|            0|            0|  0.00%|                        #  skip string prefix characters, if any.
   580|         0|            0|            0|  0.00%|                        endprog = _compile(endpats.get(initial) or
   581|         0|            0|            0|  0.00%|                                           endpats.get(token[1]) or
   582|         0|            0|            0|  0.00%|                                           endpats.get(token[2]))
   583|         0|            0|            0|  0.00%|                        contstr, needcont = line[start:], 1
   584|         0|            0|            0|  0.00%|                        contline = line
   585|         0|            0|            0|  0.00%|                        break
   586|         0|            0|            0|  0.00%|                    else:                                  # ordinary string
   587|        24|  0.000282526|  1.17719e-05|  0.00%|                        yield TokenInfo(STRING, token, spos, epos, line)
(call)|        12|  0.000140667|  1.17222e-05|  0.00%|# <string>:1 __new__
   588|         0|            0|            0|  0.00%|
   589|       300|    0.0023365|  7.78834e-06|  0.00%|                elif initial.isidentifier():               # ordinary name
   590|       272|   0.00316906|   1.1651e-05|  0.00%|                    yield TokenInfo(NAME, token, spos, epos, line)
(call)|       136|   0.00160313|  1.17877e-05|  0.00%|# <string>:1 __new__
   591|       164|  0.000960588|  5.85725e-06|  0.00%|                elif initial == '\\':                      # continued stmt
   592|         0|            0|            0|  0.00%|                    continued = 1
   593|         0|            0|            0|  0.00%|                else:
   594|       164|  0.000940084|  5.73222e-06|  0.00%|                    if initial in '([{':
   595|        40|   0.00022912|  5.72801e-06|  0.00%|                        parenlev += 1
   596|       124|  0.000722647|   5.8278e-06|  0.00%|                    elif initial in ')]}':
   597|        40|  0.000232935|  5.82337e-06|  0.00%|                        parenlev -= 1
   598|       328|   0.00379229|  1.15618e-05|  0.00%|                    yield TokenInfo(OP, token, spos, epos, line)
(call)|       164|   0.00195098|  1.18962e-05|  0.00%|# <string>:1 __new__
   599|         0|            0|            0|  0.00%|            else:
   600|         0|            0|            0|  0.00%|                yield TokenInfo(ERRORTOKEN, line[pos],
   601|         0|            0|            0|  0.00%|                           (lnum, pos), (lnum, pos+1), line)
   602|         0|            0|            0|  0.00%|                pos += 1
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|    # Add an implicit NEWLINE if the input doesn't end in one
   605|         0|            0|            0|  0.00%|    if last_line and last_line[-1] not in '\r\n':
   606|         0|            0|            0|  0.00%|        yield TokenInfo(NEWLINE, '', (lnum - 1, len(last_line)), (lnum - 1, len(last_line) + 1), '')
   607|         0|            0|            0|  0.00%|    for indent in indents[1:]:                 # pop remaining indent levels
   608|         0|            0|            0|  0.00%|        yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')
   609|         0|            0|            0|  0.00%|    yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|
   612|         1|  1.33514e-05|  1.33514e-05|  0.00%|def generate_tokens(readline):
   613|         0|            0|            0|  0.00%|    """Tokenize a source reading Python code as unicode strings.
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    This has the same API as tokenize(), except that it expects the *readline*
   616|         0|            0|            0|  0.00%|    callable to return str objects instead of bytes.
   617|         0|            0|            0|  0.00%|    """
   618|         1|   1.3113e-05|   1.3113e-05|  0.00%|    return _tokenize(readline, None)
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|def main():
   621|         0|            0|            0|  0.00%|    import argparse
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    # Helper error handling routines
   624|         0|            0|            0|  0.00%|    def perror(message):
   625|         0|            0|            0|  0.00%|        sys.stderr.write(message)
   626|         0|            0|            0|  0.00%|        sys.stderr.write('\n')
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    def error(message, filename=None, location=None):
   629|         0|            0|            0|  0.00%|        if location:
   630|         0|            0|            0|  0.00%|            args = (filename,) + location + (message,)
   631|         0|            0|            0|  0.00%|            perror("%s:%d:%d: error: %s" % args)
   632|         0|            0|            0|  0.00%|        elif filename:
   633|         0|            0|            0|  0.00%|            perror("%s: error: %s" % (filename, message))
   634|         0|            0|            0|  0.00%|        else:
   635|         0|            0|            0|  0.00%|            perror("error: %s" % message)
   636|         0|            0|            0|  0.00%|        sys.exit(1)
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|    # Parse the arguments and options
   639|         0|            0|            0|  0.00%|    parser = argparse.ArgumentParser(prog='python -m tokenize')
   640|         0|            0|            0|  0.00%|    parser.add_argument(dest='filename', nargs='?',
   641|         0|            0|            0|  0.00%|                        metavar='filename.py',
   642|         0|            0|            0|  0.00%|                        help='the file to tokenize; defaults to stdin')
   643|         0|            0|            0|  0.00%|    parser.add_argument('-e', '--exact', dest='exact', action='store_true',
   644|         0|            0|            0|  0.00%|                        help='display token names using the exact type')
   645|         0|            0|            0|  0.00%|    args = parser.parse_args()
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    try:
   648|         0|            0|            0|  0.00%|        # Tokenize the input
   649|         0|            0|            0|  0.00%|        if args.filename:
   650|         0|            0|            0|  0.00%|            filename = args.filename
   651|         0|            0|            0|  0.00%|            with _builtin_open(filename, 'rb') as f:
   652|         0|            0|            0|  0.00%|                tokens = list(tokenize(f.readline))
   653|         0|            0|            0|  0.00%|        else:
   654|         0|            0|            0|  0.00%|            filename = "<stdin>"
   655|         0|            0|            0|  0.00%|            tokens = _tokenize(sys.stdin.readline, None)
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|        # Output the tokenization
   658|         0|            0|            0|  0.00%|        for token in tokens:
   659|         0|            0|            0|  0.00%|            token_type = token.type
   660|         0|            0|            0|  0.00%|            if args.exact:
   661|         0|            0|            0|  0.00%|                token_type = token.exact_type
   662|         0|            0|            0|  0.00%|            token_range = "%d,%d-%d,%d:" % (token.start + token.end)
   663|         0|            0|            0|  0.00%|            print("%-20s%-15s%-15r" %
   664|         0|            0|            0|  0.00%|                  (token_range, tok_name[token_type], token.string))
   665|         0|            0|            0|  0.00%|    except IndentationError as err:
   666|         0|            0|            0|  0.00%|        line, column = err.args[1][1:3]
   667|         0|            0|            0|  0.00%|        error(err.args[0], filename, (line, column))
   668|         0|            0|            0|  0.00%|    except TokenError as err:
   669|         0|            0|            0|  0.00%|        line, column = err.args[1]
   670|         0|            0|            0|  0.00%|        error(err.args[0], filename, (line, column))
   671|         0|            0|            0|  0.00%|    except SyntaxError as err:
   672|         0|            0|            0|  0.00%|        error(err, filename)
   673|         0|            0|            0|  0.00%|    except OSError as err:
   674|         0|            0|            0|  0.00%|        error(err)
   675|         0|            0|            0|  0.00%|    except KeyboardInterrupt:
   676|         0|            0|            0|  0.00%|        print("interrupted\n")
   677|         0|            0|            0|  0.00%|    except Exception as err:
   678|         0|            0|            0|  0.00%|        perror("unexpected error: %s" % err)
   679|         0|            0|            0|  0.00%|        raise
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|if __name__ == "__main__":
   682|         0|            0|            0|  0.00%|    main()
File: /opt/conda/lib/python3.8/genericpath.py
File duration: 0.052532s (0.04%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Path operations common to more than one OS
     3|         0|            0|            0|  0.00%|Do not use directly.  The OS specific modules import the appropriate
     4|         0|            0|            0|  0.00%|functions from this module themselves.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|import os
     7|         0|            0|            0|  0.00%|import stat
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|__all__ = ['commonprefix', 'exists', 'getatime', 'getctime', 'getmtime',
    10|         0|            0|            0|  0.00%|           'getsize', 'isdir', 'isfile', 'samefile', 'sameopenfile',
    11|         0|            0|            0|  0.00%|           'samestat']
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|# Does a path exist?
    15|         0|            0|            0|  0.00%|# This is false for dangling symbolic links on systems that support them.
    16|      1497|   0.00675917|  4.51514e-06|  0.00%|def exists(path):
    17|         0|            0|            0|  0.00%|    """Test whether a path exists.  Returns False for broken symbolic links"""
    18|      1497|   0.00565505|  3.77759e-06|  0.00%|    try:
    19|      1497|    0.0331595|  2.21506e-05|  0.02%|        os.stat(path)
    20|         0|            0|            0|  0.00%|    except (OSError, ValueError):
    21|         0|            0|            0|  0.00%|        return False
    22|      1497|   0.00695825|  4.64813e-06|  0.01%|    return True
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# This follows symbolic links, so both islink() and isdir() can be true
    26|         0|            0|            0|  0.00%|# for the same path on systems that support symlinks
    27|         0|            0|            0|  0.00%|def isfile(path):
    28|         0|            0|            0|  0.00%|    """Test whether a path is a regular file"""
    29|         0|            0|            0|  0.00%|    try:
    30|         0|            0|            0|  0.00%|        st = os.stat(path)
    31|         0|            0|            0|  0.00%|    except (OSError, ValueError):
    32|         0|            0|            0|  0.00%|        return False
    33|         0|            0|            0|  0.00%|    return stat.S_ISREG(st.st_mode)
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|# Is a path a directory?
    37|         0|            0|            0|  0.00%|# This follows symbolic links, so both islink() and isdir()
    38|         0|            0|            0|  0.00%|# can be true for the same path on systems that support symlinks
    39|         0|            0|            0|  0.00%|def isdir(s):
    40|         0|            0|            0|  0.00%|    """Return true if the pathname refers to an existing directory."""
    41|         0|            0|            0|  0.00%|    try:
    42|         0|            0|            0|  0.00%|        st = os.stat(s)
    43|         0|            0|            0|  0.00%|    except (OSError, ValueError):
    44|         0|            0|            0|  0.00%|        return False
    45|         0|            0|            0|  0.00%|    return stat.S_ISDIR(st.st_mode)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|def getsize(filename):
    49|         0|            0|            0|  0.00%|    """Return the size of a file, reported by os.stat()."""
    50|         0|            0|            0|  0.00%|    return os.stat(filename).st_size
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|def getmtime(filename):
    54|         0|            0|            0|  0.00%|    """Return the last modification time of a file, reported by os.stat()."""
    55|         0|            0|            0|  0.00%|    return os.stat(filename).st_mtime
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|def getatime(filename):
    59|         0|            0|            0|  0.00%|    """Return the last access time of a file, reported by os.stat()."""
    60|         0|            0|            0|  0.00%|    return os.stat(filename).st_atime
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|def getctime(filename):
    64|         0|            0|            0|  0.00%|    """Return the metadata change time of a file, reported by os.stat()."""
    65|         0|            0|            0|  0.00%|    return os.stat(filename).st_ctime
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|# Return the longest prefix of all list elements.
    69|         0|            0|            0|  0.00%|def commonprefix(m):
    70|         0|            0|            0|  0.00%|    "Given a list of pathnames, returns the longest common leading component"
    71|         0|            0|            0|  0.00%|    if not m: return ''
    72|         0|            0|            0|  0.00%|    # Some people pass in a list of pathname parts to operate in an OS-agnostic
    73|         0|            0|            0|  0.00%|    # fashion; don't try to translate in that case as that's an abuse of the
    74|         0|            0|            0|  0.00%|    # API and they are already doing what they need to be OS-agnostic and so
    75|         0|            0|            0|  0.00%|    # they most likely won't be using an os.PathLike object in the sublists.
    76|         0|            0|            0|  0.00%|    if not isinstance(m[0], (list, tuple)):
    77|         0|            0|            0|  0.00%|        m = tuple(map(os.fspath, m))
    78|         0|            0|            0|  0.00%|    s1 = min(m)
    79|         0|            0|            0|  0.00%|    s2 = max(m)
    80|         0|            0|            0|  0.00%|    for i, c in enumerate(s1):
    81|         0|            0|            0|  0.00%|        if c != s2[i]:
    82|         0|            0|            0|  0.00%|            return s1[:i]
    83|         0|            0|            0|  0.00%|    return s1
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|# Are two stat buffers (obtained from stat, fstat or lstat)
    86|         0|            0|            0|  0.00%|# describing the same file?
    87|         0|            0|            0|  0.00%|def samestat(s1, s2):
    88|         0|            0|            0|  0.00%|    """Test whether two stat buffers reference the same file"""
    89|         0|            0|            0|  0.00%|    return (s1.st_ino == s2.st_ino and
    90|         0|            0|            0|  0.00%|            s1.st_dev == s2.st_dev)
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|# Are two filenames really pointing to the same file?
    94|         0|            0|            0|  0.00%|def samefile(f1, f2):
    95|         0|            0|            0|  0.00%|    """Test whether two pathnames reference the same actual file or directory
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|    This is determined by the device number and i-node number and
    98|         0|            0|            0|  0.00%|    raises an exception if an os.stat() call on either pathname fails.
    99|         0|            0|            0|  0.00%|    """
   100|         0|            0|            0|  0.00%|    s1 = os.stat(f1)
   101|         0|            0|            0|  0.00%|    s2 = os.stat(f2)
   102|         0|            0|            0|  0.00%|    return samestat(s1, s2)
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|# Are two open files really referencing the same file?
   106|         0|            0|            0|  0.00%|# (Not necessarily the same file descriptor!)
   107|         0|            0|            0|  0.00%|def sameopenfile(fp1, fp2):
   108|         0|            0|            0|  0.00%|    """Test whether two open file objects reference the same file"""
   109|         0|            0|            0|  0.00%|    s1 = os.fstat(fp1)
   110|         0|            0|            0|  0.00%|    s2 = os.fstat(fp2)
   111|         0|            0|            0|  0.00%|    return samestat(s1, s2)
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|# Split a path in root and extension.
   115|         0|            0|            0|  0.00%|# The extension is everything starting at the last dot in the last
   116|         0|            0|            0|  0.00%|# pathname component; the root is everything before that.
   117|         0|            0|            0|  0.00%|# It is always true that root + ext == p.
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|# Generic implementation of splitext, to be parametrized with
   120|         0|            0|            0|  0.00%|# the separators
   121|         0|            0|            0|  0.00%|def _splitext(p, sep, altsep, extsep):
   122|         0|            0|            0|  0.00%|    """Split the extension from a pathname.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    Extension is everything from the last dot to the end, ignoring
   125|         0|            0|            0|  0.00%|    leading dots.  Returns "(root, ext)"; ext may be empty."""
   126|         0|            0|            0|  0.00%|    # NOTE: This code must work for text and bytes strings.
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    sepIndex = p.rfind(sep)
   129|         0|            0|            0|  0.00%|    if altsep:
   130|         0|            0|            0|  0.00%|        altsepIndex = p.rfind(altsep)
   131|         0|            0|            0|  0.00%|        sepIndex = max(sepIndex, altsepIndex)
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    dotIndex = p.rfind(extsep)
   134|         0|            0|            0|  0.00%|    if dotIndex > sepIndex:
   135|         0|            0|            0|  0.00%|        # skip all leading dots
   136|         0|            0|            0|  0.00%|        filenameIndex = sepIndex + 1
   137|         0|            0|            0|  0.00%|        while filenameIndex < dotIndex:
   138|         0|            0|            0|  0.00%|            if p[filenameIndex:filenameIndex+1] != extsep:
   139|         0|            0|            0|  0.00%|                return p[:dotIndex], p[dotIndex:]
   140|         0|            0|            0|  0.00%|            filenameIndex += 1
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|    return p, p[:0]
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|def _check_arg_types(funcname, *args):
   145|         0|            0|            0|  0.00%|    hasstr = hasbytes = False
   146|         0|            0|            0|  0.00%|    for s in args:
   147|         0|            0|            0|  0.00%|        if isinstance(s, str):
   148|         0|            0|            0|  0.00%|            hasstr = True
   149|         0|            0|            0|  0.00%|        elif isinstance(s, bytes):
   150|         0|            0|            0|  0.00%|            hasbytes = True
   151|         0|            0|            0|  0.00%|        else:
   152|         0|            0|            0|  0.00%|            raise TypeError(f'{funcname}() argument must be str, bytes, or '
   153|         0|            0|            0|  0.00%|                            f'os.PathLike object, not {s.__class__.__name__!r}') from None
   154|         0|            0|            0|  0.00%|    if hasstr and hasbytes:
   155|         0|            0|            0|  0.00%|        raise TypeError("Can't mix strings and bytes in path components") from None
File: /opt/conda/lib/python3.8/site-packages/torch/package/package_importer.py
File duration: 0.0481782s (0.03%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import builtins
     2|         0|            0|            0|  0.00%|from contextlib import contextmanager
     3|         0|            0|            0|  0.00%|import importlib
     4|         0|            0|            0|  0.00%|import inspect
     5|         0|            0|            0|  0.00%|import io
     6|         0|            0|            0|  0.00%|import linecache
     7|         0|            0|            0|  0.00%|import os.path
     8|         0|            0|            0|  0.00%|import types
     9|         0|            0|            0|  0.00%|from pathlib import Path
    10|         0|            0|            0|  0.00%|from typing import Any, BinaryIO, Callable, Dict, List, Optional, Union
    11|         0|            0|            0|  0.00%|from weakref import WeakValueDictionary
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|import torch
    14|         0|            0|            0|  0.00%|from torch.serialization import _get_restore_location, _maybe_decode_ascii
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|from .file_structure_representation import Directory, _create_directory_from_file_list
    17|         0|            0|            0|  0.00%|from .glob_group import GlobPattern
    18|         0|            0|            0|  0.00%|from ._importlib import (
    19|         0|            0|            0|  0.00%|    _calc___package__,
    20|         0|            0|            0|  0.00%|    _normalize_line_endings,
    21|         0|            0|            0|  0.00%|    _normalize_path,
    22|         0|            0|            0|  0.00%|    _resolve_name,
    23|         0|            0|            0|  0.00%|    _sanity_check,
    24|         0|            0|            0|  0.00%|)
    25|         0|            0|            0|  0.00%|from ._mangling import PackageMangler, demangle
    26|         0|            0|            0|  0.00%|from ._mock_zipreader import MockZipReader
    27|         0|            0|            0|  0.00%|from ._package_unpickler import PackageUnpickler
    28|         0|            0|            0|  0.00%|from .importer import Importer
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|class PackageImporter(Importer):
    32|         0|            0|            0|  0.00%|    """Importers allow you to load code written to packages by :class:`PackageExporter`.
    33|         0|            0|            0|  0.00%|    Code is loaded in a hermetic way, using files from the package
    34|         0|            0|            0|  0.00%|    rather than the normal python import system. This allows
    35|         0|            0|            0|  0.00%|    for the packaging of PyTorch model code and data so that it can be run
    36|         0|            0|            0|  0.00%|    on a server or used in the future for transfer learning.
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|    The importer for packages ensures that code in the module can only be loaded from
    39|         0|            0|            0|  0.00%|    within the package, except for modules explicitly listed as external during export.
    40|         0|            0|            0|  0.00%|    The file ``extern_modules`` in the zip archive lists all the modules that a package externally depends on.
    41|         0|            0|            0|  0.00%|    This prevents "implicit" dependencies where the package runs locally because it is importing
    42|         0|            0|            0|  0.00%|    a locally-installed package, but then fails when the package is copied to another machine.
    43|         0|            0|            0|  0.00%|    """
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|    """The dictionary of already loaded modules from this package, equivalent to ``sys.modules`` but
    46|         0|            0|            0|  0.00%|    local to this importer.
    47|         0|            0|            0|  0.00%|    """
    48|         0|            0|            0|  0.00%|    modules: Dict[str, types.ModuleType]
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    def __init__(
    51|         0|            0|            0|  0.00%|        self,
    52|         0|            0|            0|  0.00%|        file_or_buffer: Union[str, torch._C.PyTorchFileReader, Path, BinaryIO],
    53|         0|            0|            0|  0.00%|        module_allowed: Callable[[str], bool] = lambda module_name: True,
    54|         0|            0|            0|  0.00%|    ):
    55|         0|            0|            0|  0.00%|        """Open ``file_or_buffer`` for importing. This checks that the imported package only requires modules
    56|         0|            0|            0|  0.00%|        allowed by ``module_allowed``
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|        Args:
    59|         0|            0|            0|  0.00%|            file_or_buffer: a file-like object (has to implement :meth:`read`, :meth:`readline`, :meth:`tell`, and :meth:`seek`),
    60|         0|            0|            0|  0.00%|                a string, or an ``os.PathLike`` object containing a filename.
    61|         0|            0|            0|  0.00%|            module_allowed (Callable[[str], bool], optional): A method to determine if a externally provided module
    62|         0|            0|            0|  0.00%|                should be allowed. Can be used to ensure packages loaded do not depend on modules that the server
    63|         0|            0|            0|  0.00%|                does not support. Defaults to allowing anything.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|        Raises:
    66|         0|            0|            0|  0.00%|            ImportError: If the package will use a disallowed module.
    67|         0|            0|            0|  0.00%|        """
    68|         0|            0|            0|  0.00%|        self.zip_reader: Any
    69|         0|            0|            0|  0.00%|        if isinstance(file_or_buffer, torch._C.PyTorchFileReader):
    70|         0|            0|            0|  0.00%|            self.filename = "<pytorch_file_reader>"
    71|         0|            0|            0|  0.00%|            self.zip_reader = file_or_buffer
    72|         0|            0|            0|  0.00%|        elif isinstance(file_or_buffer, (Path, str)):
    73|         0|            0|            0|  0.00%|            self.filename = str(file_or_buffer)
    74|         0|            0|            0|  0.00%|            if not os.path.isdir(self.filename):
    75|         0|            0|            0|  0.00%|                self.zip_reader = torch._C.PyTorchFileReader(self.filename)
    76|         0|            0|            0|  0.00%|            else:
    77|         0|            0|            0|  0.00%|                self.zip_reader = MockZipReader(self.filename)
    78|         0|            0|            0|  0.00%|        else:
    79|         0|            0|            0|  0.00%|            self.filename = "<binary>"
    80|         0|            0|            0|  0.00%|            self.zip_reader = torch._C.PyTorchFileReader(file_or_buffer)
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|        self.root = _PackageNode(None)
    83|         0|            0|            0|  0.00%|        self.modules = {}
    84|         0|            0|            0|  0.00%|        self.extern_modules = self._read_extern()
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|        for extern_module in self.extern_modules:
    87|         0|            0|            0|  0.00%|            if not module_allowed(extern_module):
    88|         0|            0|            0|  0.00%|                raise ImportError(
    89|         0|            0|            0|  0.00%|                    f"package '{file_or_buffer}' needs the external module '{extern_module}' "
    90|         0|            0|            0|  0.00%|                    f"but that module has been disallowed"
    91|         0|            0|            0|  0.00%|                )
    92|         0|            0|            0|  0.00%|            self._add_extern(extern_module)
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|        for fname in self.zip_reader.get_all_records():
    95|         0|            0|            0|  0.00%|            self._add_file(fname)
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|        self.patched_builtins = builtins.__dict__.copy()
    98|         0|            0|            0|  0.00%|        self.patched_builtins["__import__"] = self.__import__
    99|         0|            0|            0|  0.00%|        # Allow packaged modules to reference their PackageImporter
   100|         0|            0|            0|  0.00%|        self.modules["torch_package_importer"] = self  # type: ignore[assignment]
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|        self._mangler = PackageMangler()
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|        # used for reduce deserializaiton
   105|         0|            0|            0|  0.00%|        self.storage_context: Any = None
   106|         0|            0|            0|  0.00%|        self.last_map_location = None
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|        # used for torch.serialization._load
   109|         0|            0|            0|  0.00%|        self.Unpickler = lambda *args, **kwargs: PackageUnpickler(self, *args, **kwargs)
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    def import_module(self, name: str, package=None):
   112|         0|            0|            0|  0.00%|        """Load a module from the package if it hasn't already been loaded, and then return
   113|         0|            0|            0|  0.00%|        the module. Modules are loaded locally
   114|         0|            0|            0|  0.00%|        to the importer and will appear in ``self.modules`` rather than ``sys.modules``.
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|        Args:
   117|         0|            0|            0|  0.00%|            name (str): Fully qualified name of the module to load.
   118|         0|            0|            0|  0.00%|            package ([type], optional): Unused, but present to match the signature of importlib.import_module. Defaults to ``None``.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        Returns:
   121|         0|            0|            0|  0.00%|            types.ModuleType: The (possibly already) loaded module.
   122|         0|            0|            0|  0.00%|        """
   123|         0|            0|            0|  0.00%|        return self._gcd_import(name)
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    def load_binary(self, package: str, resource: str) -> bytes:
   126|         0|            0|            0|  0.00%|        """Load raw bytes.
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|        Args:
   129|         0|            0|            0|  0.00%|            package (str): The name of module package (e.g. ``"my_package.my_subpackage"``).
   130|         0|            0|            0|  0.00%|            resource (str): The unique name for the resource.
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|        Returns:
   133|         0|            0|            0|  0.00%|            bytes: The loaded data.
   134|         0|            0|            0|  0.00%|        """
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|        path = self._zipfile_path(package, resource)
   137|         0|            0|            0|  0.00%|        return self.zip_reader.get_record(path)
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    def load_text(
   140|         0|            0|            0|  0.00%|        self,
   141|         0|            0|            0|  0.00%|        package: str,
   142|         0|            0|            0|  0.00%|        resource: str,
   143|         0|            0|            0|  0.00%|        encoding: str = "utf-8",
   144|         0|            0|            0|  0.00%|        errors: str = "strict",
   145|         0|            0|            0|  0.00%|    ) -> str:
   146|         0|            0|            0|  0.00%|        """Load a string.
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|        Args:
   149|         0|            0|            0|  0.00%|            package (str): The name of module package (e.g. ``"my_package.my_subpackage"``).
   150|         0|            0|            0|  0.00%|            resource (str): The unique name for the resource.
   151|         0|            0|            0|  0.00%|            encoding (str, optional): Passed to ``decode``. Defaults to ``'utf-8'``.
   152|         0|            0|            0|  0.00%|            errors (str, optional): Passed to ``decode``. Defaults to ``'strict'``.
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|        Returns:
   155|         0|            0|            0|  0.00%|            str: The loaded text.
   156|         0|            0|            0|  0.00%|        """
   157|         0|            0|            0|  0.00%|        data = self.load_binary(package, resource)
   158|         0|            0|            0|  0.00%|        return data.decode(encoding, errors)
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    def load_pickle(self, package: str, resource: str, map_location=None) -> Any:
   161|         0|            0|            0|  0.00%|        """Unpickles the resource from the package, loading any modules that are needed to construct the objects
   162|         0|            0|            0|  0.00%|        using :meth:`import_module`.
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|        Args:
   165|         0|            0|            0|  0.00%|            package (str): The name of module package (e.g. ``"my_package.my_subpackage"``).
   166|         0|            0|            0|  0.00%|            resource (str): The unique name for the resource.
   167|         0|            0|            0|  0.00%|            map_location: Passed to `torch.load` to determine how tensors are mapped to devices. Defaults to ``None``.
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|        Returns:
   170|         0|            0|            0|  0.00%|            Any: The unpickled object.
   171|         0|            0|            0|  0.00%|        """
   172|         0|            0|            0|  0.00%|        pickle_file = self._zipfile_path(package, resource)
   173|         0|            0|            0|  0.00%|        restore_location = _get_restore_location(map_location)
   174|         0|            0|            0|  0.00%|        loaded_storages = {}
   175|         0|            0|            0|  0.00%|        loaded_reduces = {}
   176|         0|            0|            0|  0.00%|        storage_context = torch._C.StorageContext()
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|        def load_tensor(data_type, size, key, location, restore_location):
   179|         0|            0|            0|  0.00%|            name = f"{key}.storage"
   180|         0|            0|            0|  0.00%|            dtype = data_type(0).dtype
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|            if storage_context.has_storage(name):
   183|         0|            0|            0|  0.00%|                storage = storage_context.get_storage(name, dtype).storage()
   184|         0|            0|            0|  0.00%|            else:
   185|         0|            0|            0|  0.00%|                tensor = self.zip_reader.get_storage_from_record(
   186|         0|            0|            0|  0.00%|                    ".data/" + name, size, dtype
   187|         0|            0|            0|  0.00%|                )
   188|         0|            0|            0|  0.00%|                if isinstance(self.zip_reader, torch._C.PyTorchFileReader):
   189|         0|            0|            0|  0.00%|                    storage_context.add_storage(name, tensor)
   190|         0|            0|            0|  0.00%|                storage = tensor.storage()
   191|         0|            0|            0|  0.00%|            loaded_storages[key] = restore_location(storage, location)
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|        def persistent_load(saved_id):
   194|         0|            0|            0|  0.00%|            assert isinstance(saved_id, tuple)
   195|         0|            0|            0|  0.00%|            typename = _maybe_decode_ascii(saved_id[0])
   196|         0|            0|            0|  0.00%|            data = saved_id[1:]
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|            if typename == "storage":
   199|         0|            0|            0|  0.00%|                data_type, key, location, size = data
   200|         0|            0|            0|  0.00%|                if key not in loaded_storages:
   201|         0|            0|            0|  0.00%|                    load_tensor(
   202|         0|            0|            0|  0.00%|                        data_type,
   203|         0|            0|            0|  0.00%|                        size,
   204|         0|            0|            0|  0.00%|                        key,
   205|         0|            0|            0|  0.00%|                        _maybe_decode_ascii(location),
   206|         0|            0|            0|  0.00%|                        restore_location,
   207|         0|            0|            0|  0.00%|                    )
   208|         0|            0|            0|  0.00%|                storage = loaded_storages[key]
   209|         0|            0|            0|  0.00%|                return storage
   210|         0|            0|            0|  0.00%|            elif typename == "reduce_package":
   211|         0|            0|            0|  0.00%|                reduce_id, func, args = data
   212|         0|            0|            0|  0.00%|                if reduce_id not in loaded_reduces:
   213|         0|            0|            0|  0.00%|                    loaded_reduces[reduce_id] = func(self, *args)
   214|         0|            0|            0|  0.00%|                return loaded_reduces[reduce_id]
   215|         0|            0|            0|  0.00%|            else:
   216|         0|            0|            0|  0.00%|                f"Unknown typename for persistent_load, expected 'storage' or 'reduce_package' but got '{typename}'"
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|        # Load the data (which may in turn use `persistent_load` to load tensors)
   219|         0|            0|            0|  0.00%|        data_file = io.BytesIO(self.zip_reader.get_record(pickle_file))
   220|         0|            0|            0|  0.00%|        unpickler = self.Unpickler(data_file)
   221|         0|            0|            0|  0.00%|        unpickler.persistent_load = persistent_load
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|        @contextmanager
   224|         0|            0|            0|  0.00%|        def set_deserialization_context():
   225|         0|            0|            0|  0.00%|            # to let reduce_package access deserializaiton context
   226|         0|            0|            0|  0.00%|            self.storage_context = storage_context
   227|         0|            0|            0|  0.00%|            self.last_map_location = map_location
   228|         0|            0|            0|  0.00%|            try:
   229|         0|            0|            0|  0.00%|                yield
   230|         0|            0|            0|  0.00%|            finally:
   231|         0|            0|            0|  0.00%|                self.storage_context = None
   232|         0|            0|            0|  0.00%|                self.last_map_location = None
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|        with set_deserialization_context():
   235|         0|            0|            0|  0.00%|            result = unpickler.load()
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|        # TODO from zdevito:
   238|         0|            0|            0|  0.00%|        #   This stateful weird function will need to be removed in our efforts
   239|         0|            0|            0|  0.00%|        #   to unify the format. It has a race condition if multiple python
   240|         0|            0|            0|  0.00%|        #   threads try to read independent files
   241|         0|            0|            0|  0.00%|        torch._utils._validate_loaded_sparse_tensors()
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|        return result
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|    def id(self):
   246|         0|            0|            0|  0.00%|        """
   247|         0|            0|            0|  0.00%|        Returns internal identifier that torch.package uses to distinguish :class:`PackageImporter` instances.
   248|         0|            0|            0|  0.00%|        Looks like::
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|            <torch_package_0>
   251|         0|            0|            0|  0.00%|        """
   252|         0|            0|            0|  0.00%|        return self._mangler.parent_name()
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    def file_structure(
   255|         0|            0|            0|  0.00%|        self, *, include: "GlobPattern" = "**", exclude: "GlobPattern" = ()
   256|         0|            0|            0|  0.00%|    ) -> Directory:
   257|         0|            0|            0|  0.00%|        """Returns a file structure representation of package's zipfile.
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|        Args:
   260|         0|            0|            0|  0.00%|            include (Union[List[str], str]): An optional string e.g. ``"my_package.my_subpackage"``, or optional list of strings
   261|         0|            0|            0|  0.00%|                for the names of the files to be inluded in the zipfile representation. This can also be
   262|         0|            0|            0|  0.00%|                a glob-style pattern, as described in :meth:`PackageExporter.mock`
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|            exclude (Union[List[str], str]): An optional pattern that excludes files whose name match the pattern.
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|        Returns:
   267|         0|            0|            0|  0.00%|            :class:`Directory`
   268|         0|            0|            0|  0.00%|        """
   269|         0|            0|            0|  0.00%|        return _create_directory_from_file_list(
   270|         0|            0|            0|  0.00%|            self.filename, self.zip_reader.get_all_records(), include, exclude
   271|         0|            0|            0|  0.00%|        )
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    def _read_extern(self):
   274|         0|            0|            0|  0.00%|        return (
   275|         0|            0|            0|  0.00%|            self.zip_reader.get_record(".data/extern_modules")
   276|         0|            0|            0|  0.00%|            .decode("utf-8")
   277|         0|            0|            0|  0.00%|            .splitlines(keepends=False)
   278|         0|            0|            0|  0.00%|        )
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|    def _make_module(
   281|         0|            0|            0|  0.00%|        self, name: str, filename: Optional[str], is_package: bool, parent: str
   282|         0|            0|            0|  0.00%|    ):
   283|         0|            0|            0|  0.00%|        mangled_filename = self._mangler.mangle(filename) if filename else None
   284|         0|            0|            0|  0.00%|        spec = importlib.machinery.ModuleSpec(name, self, is_package=is_package)  # type: ignore[arg-type]
   285|         0|            0|            0|  0.00%|        module = importlib.util.module_from_spec(spec)
   286|         0|            0|            0|  0.00%|        self.modules[name] = module
   287|         0|            0|            0|  0.00%|        module.__name__ = self._mangler.mangle(name)
   288|         0|            0|            0|  0.00%|        ns = module.__dict__
   289|         0|            0|            0|  0.00%|        ns["__spec__"] = spec
   290|         0|            0|            0|  0.00%|        ns["__loader__"] = self
   291|         0|            0|            0|  0.00%|        ns["__file__"] = mangled_filename
   292|         0|            0|            0|  0.00%|        ns["__cached__"] = None
   293|         0|            0|            0|  0.00%|        ns["__builtins__"] = self.patched_builtins
   294|         0|            0|            0|  0.00%|        ns["__torch_package__"] = True
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|        # Add this module to our private global registry. It should be unique due to mangling.
   297|         0|            0|            0|  0.00%|        assert module.__name__ not in _package_imported_modules
   298|         0|            0|            0|  0.00%|        _package_imported_modules[module.__name__] = module
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|        # pre-emptively install on the parent to prevent IMPORT_FROM from trying to
   301|         0|            0|            0|  0.00%|        # access sys.modules
   302|         0|            0|            0|  0.00%|        self._install_on_parent(parent, name, module)
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|        if filename is not None:
   305|         0|            0|            0|  0.00%|            assert mangled_filename is not None
   306|         0|            0|            0|  0.00%|            # pre-emptively install the source in `linecache` so that stack traces,
   307|         0|            0|            0|  0.00%|            # `inspect`, etc. work.
   308|         0|            0|            0|  0.00%|            assert filename not in linecache.cache  # type: ignore[attr-defined]
   309|         0|            0|            0|  0.00%|            linecache.lazycache(mangled_filename, ns)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|            code = self._compile_source(filename, mangled_filename)
   312|         0|            0|            0|  0.00%|            exec(code, ns)
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|        return module
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    def _load_module(self, name: str, parent: str):
   317|         0|            0|            0|  0.00%|        cur: _PathNode = self.root
   318|         0|            0|            0|  0.00%|        for atom in name.split("."):
   319|         0|            0|            0|  0.00%|            if not isinstance(cur, _PackageNode) or atom not in cur.children:
   320|         0|            0|            0|  0.00%|                raise ModuleNotFoundError(
   321|         0|            0|            0|  0.00%|                    f'No module named "{name}" in self-contained archive "{self.filename}"'
   322|         0|            0|            0|  0.00%|                    f" and the module is also not in the list of allowed external modules: {self.extern_modules}",
   323|         0|            0|            0|  0.00%|                    name=name,
   324|         0|            0|            0|  0.00%|                )
   325|         0|            0|            0|  0.00%|            cur = cur.children[atom]
   326|         0|            0|            0|  0.00%|            if isinstance(cur, _ExternNode):
   327|         0|            0|            0|  0.00%|                module = self.modules[name] = importlib.import_module(name)
   328|         0|            0|            0|  0.00%|                return module
   329|         0|            0|            0|  0.00%|        return self._make_module(name, cur.source_file, isinstance(cur, _PackageNode), parent)  # type: ignore[attr-defined]
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def _compile_source(self, fullpath: str, mangled_filename: str):
   332|         0|            0|            0|  0.00%|        source = self.zip_reader.get_record(fullpath)
   333|         0|            0|            0|  0.00%|        source = _normalize_line_endings(source)
   334|         0|            0|            0|  0.00%|        return compile(source, mangled_filename, "exec", dont_inherit=True)
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|    # note: named `get_source` so that linecache can find the source
   337|         0|            0|            0|  0.00%|    # when this is the __loader__ of a module.
   338|         0|            0|            0|  0.00%|    def get_source(self, module_name) -> str:
   339|         0|            0|            0|  0.00%|        # linecache calls `get_source` with the `module.__name__` as the argument, so we must demangle it here.
   340|         0|            0|            0|  0.00%|        module = self.import_module(demangle(module_name))
   341|         0|            0|            0|  0.00%|        return self.zip_reader.get_record(demangle(module.__file__)).decode("utf-8")
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    # note: named `get_resource_reader` so that importlib.resources can find it.
   344|         0|            0|            0|  0.00%|    # This is otherwise considered an internal method.
   345|         0|            0|            0|  0.00%|    def get_resource_reader(self, fullname):
   346|         0|            0|            0|  0.00%|        try:
   347|         0|            0|            0|  0.00%|            package = self._get_package(fullname)
   348|         0|            0|            0|  0.00%|        except ImportError:
   349|         0|            0|            0|  0.00%|            return None
   350|         0|            0|            0|  0.00%|        if package.__loader__ is not self:
   351|         0|            0|            0|  0.00%|            return None
   352|         0|            0|            0|  0.00%|        return _PackageResourceReader(self, fullname)
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    def _install_on_parent(self, parent: str, name: str, module: types.ModuleType):
   355|         0|            0|            0|  0.00%|        if not parent:
   356|         0|            0|            0|  0.00%|            return
   357|         0|            0|            0|  0.00%|        # Set the module as an attribute on its parent.
   358|         0|            0|            0|  0.00%|        parent_module = self.modules[parent]
   359|         0|            0|            0|  0.00%|        if parent_module.__loader__ is self:  # type: ignore[union-attr]
   360|         0|            0|            0|  0.00%|            setattr(parent_module, name.rpartition(".")[2], module)
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    # note: copied from cpython's import code, with call to create module replaced with _make_module
   363|         0|            0|            0|  0.00%|    def _do_find_and_load(self, name):
   364|         0|            0|            0|  0.00%|        path = None
   365|         0|            0|            0|  0.00%|        parent = name.rpartition(".")[0]
   366|         0|            0|            0|  0.00%|        if parent:
   367|         0|            0|            0|  0.00%|            if parent not in self.modules:
   368|         0|            0|            0|  0.00%|                self._gcd_import(parent)
   369|         0|            0|            0|  0.00%|            # Crazy side-effects!
   370|         0|            0|            0|  0.00%|            if name in self.modules:
   371|         0|            0|            0|  0.00%|                return self.modules[name]
   372|         0|            0|            0|  0.00%|            parent_module = self.modules[parent]
   373|         0|            0|            0|  0.00%|            try:
   374|         0|            0|            0|  0.00%|                path = parent_module.__path__  # type: ignore[attr-defined]
   375|         0|            0|            0|  0.00%|            except AttributeError:
   376|         0|            0|            0|  0.00%|                msg = (_ERR_MSG + "; {!r} is not a package").format(name, parent)
   377|         0|            0|            0|  0.00%|                raise ModuleNotFoundError(msg, name=name) from None
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|        module = self._load_module(name, parent)
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|        self._install_on_parent(parent, name, module)
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|        return module
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    # note: copied from cpython's import code
   386|         0|            0|            0|  0.00%|    def _find_and_load(self, name):
   387|         0|            0|            0|  0.00%|        module = self.modules.get(name, _NEEDS_LOADING)
   388|         0|            0|            0|  0.00%|        if module is _NEEDS_LOADING:
   389|         0|            0|            0|  0.00%|            return self._do_find_and_load(name)
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|        if module is None:
   392|         0|            0|            0|  0.00%|            message = "import of {} halted; " "None in sys.modules".format(name)
   393|         0|            0|            0|  0.00%|            raise ModuleNotFoundError(message, name=name)
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|        return module
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|    def _gcd_import(self, name, package=None, level=0):
   398|         0|            0|            0|  0.00%|        """Import and return the module based on its name, the package the call is
   399|         0|            0|            0|  0.00%|        being made from, and the level adjustment.
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|        This function represents the greatest common denominator of functionality
   402|         0|            0|            0|  0.00%|        between import_module and __import__. This includes setting __package__ if
   403|         0|            0|            0|  0.00%|        the loader did not.
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|        """
   406|         0|            0|            0|  0.00%|        _sanity_check(name, package, level)
   407|         0|            0|            0|  0.00%|        if level > 0:
   408|         0|            0|            0|  0.00%|            name = _resolve_name(name, package, level)
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|        return self._find_and_load(name)
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    # note: copied from cpython's import code
   413|         0|            0|            0|  0.00%|    def _handle_fromlist(self, module, fromlist, *, recursive=False):
   414|         0|            0|            0|  0.00%|        """Figure out what __import__ should return.
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|        The import_ parameter is a callable which takes the name of module to
   417|         0|            0|            0|  0.00%|        import. It is required to decouple the function from assuming importlib's
   418|         0|            0|            0|  0.00%|        import implementation is desired.
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|        """
   421|         0|            0|            0|  0.00%|        module_name = demangle(module.__name__)
   422|         0|            0|            0|  0.00%|        # The hell that is fromlist ...
   423|         0|            0|            0|  0.00%|        # If a package was imported, try to import stuff from fromlist.
   424|         0|            0|            0|  0.00%|        if hasattr(module, "__path__"):
   425|         0|            0|            0|  0.00%|            for x in fromlist:
   426|         0|            0|            0|  0.00%|                if not isinstance(x, str):
   427|         0|            0|            0|  0.00%|                    if recursive:
   428|         0|            0|            0|  0.00%|                        where = module_name + ".__all__"
   429|         0|            0|            0|  0.00%|                    else:
   430|         0|            0|            0|  0.00%|                        where = "``from list''"
   431|         0|            0|            0|  0.00%|                    raise TypeError(
   432|         0|            0|            0|  0.00%|                        f"Item in {where} must be str, " f"not {type(x).__name__}"
   433|         0|            0|            0|  0.00%|                    )
   434|         0|            0|            0|  0.00%|                elif x == "*":
   435|         0|            0|            0|  0.00%|                    if not recursive and hasattr(module, "__all__"):
   436|         0|            0|            0|  0.00%|                        self._handle_fromlist(module, module.__all__, recursive=True)
   437|         0|            0|            0|  0.00%|                elif not hasattr(module, x):
   438|         0|            0|            0|  0.00%|                    from_name = "{}.{}".format(module_name, x)
   439|         0|            0|            0|  0.00%|                    try:
   440|         0|            0|            0|  0.00%|                        self._gcd_import(from_name)
   441|         0|            0|            0|  0.00%|                    except ModuleNotFoundError as exc:
   442|         0|            0|            0|  0.00%|                        # Backwards-compatibility dictates we ignore failed
   443|         0|            0|            0|  0.00%|                        # imports triggered by fromlist for modules that don't
   444|         0|            0|            0|  0.00%|                        # exist.
   445|         0|            0|            0|  0.00%|                        if (
   446|         0|            0|            0|  0.00%|                            exc.name == from_name
   447|         0|            0|            0|  0.00%|                            and self.modules.get(from_name, _NEEDS_LOADING) is not None
   448|         0|            0|            0|  0.00%|                        ):
   449|         0|            0|            0|  0.00%|                            continue
   450|         0|            0|            0|  0.00%|                        raise
   451|         0|            0|            0|  0.00%|        return module
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    def __import__(self, name, globals=None, locals=None, fromlist=(), level=0):
   454|         0|            0|            0|  0.00%|        if level == 0:
   455|         0|            0|            0|  0.00%|            module = self._gcd_import(name)
   456|         0|            0|            0|  0.00%|        else:
   457|         0|            0|            0|  0.00%|            globals_ = globals if globals is not None else {}
   458|         0|            0|            0|  0.00%|            package = _calc___package__(globals_)
   459|         0|            0|            0|  0.00%|            module = self._gcd_import(name, package, level)
   460|         0|            0|            0|  0.00%|        if not fromlist:
   461|         0|            0|            0|  0.00%|            # Return up to the first dot in 'name'. This is complicated by the fact
   462|         0|            0|            0|  0.00%|            # that 'name' may be relative.
   463|         0|            0|            0|  0.00%|            if level == 0:
   464|         0|            0|            0|  0.00%|                return self._gcd_import(name.partition(".")[0])
   465|         0|            0|            0|  0.00%|            elif not name:
   466|         0|            0|            0|  0.00%|                return module
   467|         0|            0|            0|  0.00%|            else:
   468|         0|            0|            0|  0.00%|                # Figure out where to slice the module's name up to the first dot
   469|         0|            0|            0|  0.00%|                # in 'name'.
   470|         0|            0|            0|  0.00%|                cut_off = len(name) - len(name.partition(".")[0])
   471|         0|            0|            0|  0.00%|                # Slice end needs to be positive to alleviate need to special-case
   472|         0|            0|            0|  0.00%|                # when ``'.' not in name``.
   473|         0|            0|            0|  0.00%|                module_name = demangle(module.__name__)
   474|         0|            0|            0|  0.00%|                return self.modules[module_name[: len(module_name) - cut_off]]
   475|         0|            0|            0|  0.00%|        else:
   476|         0|            0|            0|  0.00%|            return self._handle_fromlist(module, fromlist)
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|    def _get_package(self, package):
   479|         0|            0|            0|  0.00%|        """Take a package name or module object and return the module.
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        If a name, the module is imported.  If the passed or imported module
   482|         0|            0|            0|  0.00%|        object is not a package, raise an exception.
   483|         0|            0|            0|  0.00%|        """
   484|         0|            0|            0|  0.00%|        if hasattr(package, "__spec__"):
   485|         0|            0|            0|  0.00%|            if package.__spec__.submodule_search_locations is None:
   486|         0|            0|            0|  0.00%|                raise TypeError("{!r} is not a package".format(package.__spec__.name))
   487|         0|            0|            0|  0.00%|            else:
   488|         0|            0|            0|  0.00%|                return package
   489|         0|            0|            0|  0.00%|        else:
   490|         0|            0|            0|  0.00%|            module = self.import_module(package)
   491|         0|            0|            0|  0.00%|            if module.__spec__.submodule_search_locations is None:
   492|         0|            0|            0|  0.00%|                raise TypeError("{!r} is not a package".format(package))
   493|         0|            0|            0|  0.00%|            else:
   494|         0|            0|            0|  0.00%|                return module
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    def _zipfile_path(self, package, resource=None):
   497|         0|            0|            0|  0.00%|        package = self._get_package(package)
   498|         0|            0|            0|  0.00%|        assert package.__loader__ is self
   499|         0|            0|            0|  0.00%|        name = demangle(package.__name__)
   500|         0|            0|            0|  0.00%|        if resource is not None:
   501|         0|            0|            0|  0.00%|            resource = _normalize_path(resource)
   502|         0|            0|            0|  0.00%|            return f"{name.replace('.', '/')}/{resource}"
   503|         0|            0|            0|  0.00%|        else:
   504|         0|            0|            0|  0.00%|            return f"{name.replace('.', '/')}"
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    def _get_or_create_package(
   507|         0|            0|            0|  0.00%|        self, atoms: List[str]
   508|         0|            0|            0|  0.00%|    ) -> "Union[_PackageNode, _ExternNode]":
   509|         0|            0|            0|  0.00%|        cur = self.root
   510|         0|            0|            0|  0.00%|        for i, atom in enumerate(atoms):
   511|         0|            0|            0|  0.00%|            node = cur.children.get(atom, None)
   512|         0|            0|            0|  0.00%|            if node is None:
   513|         0|            0|            0|  0.00%|                node = cur.children[atom] = _PackageNode(None)
   514|         0|            0|            0|  0.00%|            if isinstance(node, _ExternNode):
   515|         0|            0|            0|  0.00%|                return node
   516|         0|            0|            0|  0.00%|            if isinstance(node, _ModuleNode):
   517|         0|            0|            0|  0.00%|                name = ".".join(atoms[:i])
   518|         0|            0|            0|  0.00%|                raise ImportError(
   519|         0|            0|            0|  0.00%|                    f"inconsistent module structure. module {name} is not a package, but has submodules"
   520|         0|            0|            0|  0.00%|                )
   521|         0|            0|            0|  0.00%|            assert isinstance(node, _PackageNode)
   522|         0|            0|            0|  0.00%|            cur = node
   523|         0|            0|            0|  0.00%|        return cur
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|    def _add_file(self, filename: str):
   526|         0|            0|            0|  0.00%|        """Assembles a Python module out of the given file. Will ignore files in the .data directory.
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|        Args:
   529|         0|            0|            0|  0.00%|            filename (str): the name of the file inside of the package archive to be added
   530|         0|            0|            0|  0.00%|        """
   531|         0|            0|            0|  0.00%|        *prefix, last = filename.split("/")
   532|         0|            0|            0|  0.00%|        if len(prefix) > 1 and prefix[0] == ".data":
   533|         0|            0|            0|  0.00%|            return
   534|         0|            0|            0|  0.00%|        package = self._get_or_create_package(prefix)
   535|         0|            0|            0|  0.00%|        if isinstance(package, _ExternNode):
   536|         0|            0|            0|  0.00%|            raise ImportError(
   537|         0|            0|            0|  0.00%|                f"inconsistent module structure. package contains a module file {filename}"
   538|         0|            0|            0|  0.00%|                f" that is a subpackage of a module marked external."
   539|         0|            0|            0|  0.00%|            )
   540|         0|            0|            0|  0.00%|        if last == "__init__.py":
   541|         0|            0|            0|  0.00%|            package.source_file = filename
   542|         0|            0|            0|  0.00%|        elif last.endswith(".py"):
   543|         0|            0|            0|  0.00%|            package_name = last[: -len(".py")]
   544|         0|            0|            0|  0.00%|            package.children[package_name] = _ModuleNode(filename)
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|    def _add_extern(self, extern_name: str):
   547|         0|            0|            0|  0.00%|        *prefix, last = extern_name.split(".")
   548|         0|            0|            0|  0.00%|        package = self._get_or_create_package(prefix)
   549|         0|            0|            0|  0.00%|        if isinstance(package, _ExternNode):
   550|         0|            0|            0|  0.00%|            return  # the shorter extern covers this extern case
   551|         0|            0|            0|  0.00%|        package.children[last] = _ExternNode()
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|_NEEDS_LOADING = object()
   555|         0|            0|            0|  0.00%|_ERR_MSG_PREFIX = "No module named "
   556|         0|            0|            0|  0.00%|_ERR_MSG = _ERR_MSG_PREFIX + "{!r}"
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|class _PathNode:
   560|         0|            0|            0|  0.00%|    pass
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|class _PackageNode(_PathNode):
   564|         0|            0|            0|  0.00%|    def __init__(self, source_file: Optional[str]):
   565|         0|            0|            0|  0.00%|        self.source_file = source_file
   566|         0|            0|            0|  0.00%|        self.children: Dict[str, _PathNode] = {}
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|class _ModuleNode(_PathNode):
   570|         0|            0|            0|  0.00%|    __slots__ = ["source_file"]
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def __init__(self, source_file: str):
   573|         0|            0|            0|  0.00%|        self.source_file = source_file
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|class _ExternNode(_PathNode):
   577|         0|            0|            0|  0.00%|    pass
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|# A private global registry of all modules that have been package-imported.
   581|         0|            0|            0|  0.00%|_package_imported_modules: WeakValueDictionary = WeakValueDictionary()
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|# `inspect` by default only looks in `sys.modules` to find source files for classes.
   584|         0|            0|            0|  0.00%|# Patch it to check our private registry of package-imported modules as well.
   585|         0|            0|            0|  0.00%|_orig_getfile = inspect.getfile
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|
   588|      1706|   0.00729251|  4.27462e-06|  0.01%|def patched_getfile(object):
   589|      1706|     0.020268|  1.18804e-05|  0.01%|    if inspect.isclass(object):
(call)|      1706|    0.0169022|  9.90751e-06|  0.01%|# /opt/conda/lib/python3.8/inspect.py:72 isclass
   590|         0|            0|            0|  0.00%|        if object.__module__ in _package_imported_modules:
   591|         0|            0|            0|  0.00%|            return _package_imported_modules[object.__module__].__file__
   592|      1706|    0.0206177|  1.20854e-05|  0.01%|    return _orig_getfile(object)
(call)|      1706|    0.0620751|  3.63864e-05|  0.05%|# /opt/conda/lib/python3.8/inspect.py:654 getfile
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|inspect.getfile = patched_getfile
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|class _PackageResourceReader:
   599|         0|            0|            0|  0.00%|    """Private class used to support PackageImporter.get_resource_reader().
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|    Confirms to the importlib.abc.ResourceReader interface. Allowed to access
   602|         0|            0|            0|  0.00%|    the innards of PackageImporter.
   603|         0|            0|            0|  0.00%|    """
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|    def __init__(self, importer, fullname):
   606|         0|            0|            0|  0.00%|        self.importer = importer
   607|         0|            0|            0|  0.00%|        self.fullname = fullname
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    def open_resource(self, resource):
   610|         0|            0|            0|  0.00%|        from io import BytesIO
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|        return BytesIO(self.importer.load_binary(self.fullname, resource))
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|    def resource_path(self, resource):
   615|         0|            0|            0|  0.00%|        # The contract for resource_path is that it either returns a concrete
   616|         0|            0|            0|  0.00%|        # file system path or raises FileNotFoundError.
   617|         0|            0|            0|  0.00%|        raise FileNotFoundError
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    def is_resource(self, name):
   620|         0|            0|            0|  0.00%|        path = self.importer._zipfile_path(self.fullname, name)
   621|         0|            0|            0|  0.00%|        return self.importer.zip_reader.has_record(path)
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    def contents(self):
   624|         0|            0|            0|  0.00%|        from pathlib import Path
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|        filename = self.fullname.replace(".", "/")
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|        fullname_path = Path(self.importer._zipfile_path(self.fullname))
   629|         0|            0|            0|  0.00%|        files = self.importer.zip_reader.get_all_records()
   630|         0|            0|            0|  0.00%|        subdirs_seen = set()
   631|         0|            0|            0|  0.00%|        for filename in files:
   632|         0|            0|            0|  0.00%|            try:
   633|         0|            0|            0|  0.00%|                relative = Path(filename).relative_to(fullname_path)
   634|         0|            0|            0|  0.00%|            except ValueError:
   635|         0|            0|            0|  0.00%|                continue
   636|         0|            0|            0|  0.00%|            # If the path of the file (which is relative to the top of the zip
   637|         0|            0|            0|  0.00%|            # namespace), relative to the package given when the resource
   638|         0|            0|            0|  0.00%|            # reader was created, has a parent, then it's a name in a
   639|         0|            0|            0|  0.00%|            # subdirectory and thus we skip it.
   640|         0|            0|            0|  0.00%|            parent_name = relative.parent.name
   641|         0|            0|            0|  0.00%|            if len(parent_name) == 0:
   642|         0|            0|            0|  0.00%|                yield relative.name
   643|         0|            0|            0|  0.00%|            elif parent_name not in subdirs_seen:
   644|         0|            0|            0|  0.00%|                subdirs_seen.add(parent_name)
   645|         0|            0|            0|  0.00%|                yield parent_name
File: /opt/conda/lib/python3.8/re.py
File duration: 0.017592s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Secret Labs' Regular Expression Engine
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# re-compatible interface for the sre matching engine
     5|         0|            0|            0|  0.00%|#
     6|         0|            0|            0|  0.00%|# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# This version of the SRE library can be redistributed under CNRI's
     9|         0|            0|            0|  0.00%|# Python 1.6 license.  For any other use, please contact Secret Labs
    10|         0|            0|            0|  0.00%|# AB (info@pythonware.com).
    11|         0|            0|            0|  0.00%|#
    12|         0|            0|            0|  0.00%|# Portions of this engine have been developed in cooperation with
    13|         0|            0|            0|  0.00%|# CNRI.  Hewlett-Packard provided funding for 1.6 integration and
    14|         0|            0|            0|  0.00%|# other compatibility work.
    15|         0|            0|            0|  0.00%|#
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|r"""Support for regular expressions (RE).
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|This module provides regular expression matching operations similar to
    20|         0|            0|            0|  0.00%|those found in Perl.  It supports both 8-bit and Unicode strings; both
    21|         0|            0|            0|  0.00%|the pattern and the strings being processed can contain null bytes and
    22|         0|            0|            0|  0.00%|characters outside the US ASCII range.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|Regular expressions can contain both special and ordinary characters.
    25|         0|            0|            0|  0.00%|Most ordinary characters, like "A", "a", or "0", are the simplest
    26|         0|            0|            0|  0.00%|regular expressions; they simply match themselves.  You can
    27|         0|            0|            0|  0.00%|concatenate ordinary characters, so last matches the string 'last'.
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|The special characters are:
    30|         0|            0|            0|  0.00%|    "."      Matches any character except a newline.
    31|         0|            0|            0|  0.00%|    "^"      Matches the start of the string.
    32|         0|            0|            0|  0.00%|    "$"      Matches the end of the string or just before the newline at
    33|         0|            0|            0|  0.00%|             the end of the string.
    34|         0|            0|            0|  0.00%|    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
    35|         0|            0|            0|  0.00%|             Greedy means that it will match as many repetitions as possible.
    36|         0|            0|            0|  0.00%|    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    37|         0|            0|            0|  0.00%|    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    38|         0|            0|            0|  0.00%|    *?,+?,?? Non-greedy versions of the previous three special characters.
    39|         0|            0|            0|  0.00%|    {m,n}    Matches from m to n repetitions of the preceding RE.
    40|         0|            0|            0|  0.00%|    {m,n}?   Non-greedy version of the above.
    41|         0|            0|            0|  0.00%|    "\\"     Either escapes special characters or signals a special sequence.
    42|         0|            0|            0|  0.00%|    []       Indicates a set of characters.
    43|         0|            0|            0|  0.00%|             A "^" as the first character indicates a complementing set.
    44|         0|            0|            0|  0.00%|    "|"      A|B, creates an RE that will match either A or B.
    45|         0|            0|            0|  0.00%|    (...)    Matches the RE inside the parentheses.
    46|         0|            0|            0|  0.00%|             The contents can be retrieved or matched later in the string.
    47|         0|            0|            0|  0.00%|    (?aiLmsux) The letters set the corresponding flags defined below.
    48|         0|            0|            0|  0.00%|    (?:...)  Non-grouping version of regular parentheses.
    49|         0|            0|            0|  0.00%|    (?P<name>...) The substring matched by the group is accessible by name.
    50|         0|            0|            0|  0.00%|    (?P=name)     Matches the text matched earlier by the group named name.
    51|         0|            0|            0|  0.00%|    (?#...)  A comment; ignored.
    52|         0|            0|            0|  0.00%|    (?=...)  Matches if ... matches next, but doesn't consume the string.
    53|         0|            0|            0|  0.00%|    (?!...)  Matches if ... doesn't match next.
    54|         0|            0|            0|  0.00%|    (?<=...) Matches if preceded by ... (must be fixed length).
    55|         0|            0|            0|  0.00%|    (?<!...) Matches if not preceded by ... (must be fixed length).
    56|         0|            0|            0|  0.00%|    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
    57|         0|            0|            0|  0.00%|                       the (optional) no pattern otherwise.
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|The special sequences consist of "\\" and a character from the list
    60|         0|            0|            0|  0.00%|below.  If the ordinary character is not on the list, then the
    61|         0|            0|            0|  0.00%|resulting RE will match the second character.
    62|         0|            0|            0|  0.00%|    \number  Matches the contents of the group of the same number.
    63|         0|            0|            0|  0.00%|    \A       Matches only at the start of the string.
    64|         0|            0|            0|  0.00%|    \Z       Matches only at the end of the string.
    65|         0|            0|            0|  0.00%|    \b       Matches the empty string, but only at the start or end of a word.
    66|         0|            0|            0|  0.00%|    \B       Matches the empty string, but not at the start or end of a word.
    67|         0|            0|            0|  0.00%|    \d       Matches any decimal digit; equivalent to the set [0-9] in
    68|         0|            0|            0|  0.00%|             bytes patterns or string patterns with the ASCII flag.
    69|         0|            0|            0|  0.00%|             In string patterns without the ASCII flag, it will match the whole
    70|         0|            0|            0|  0.00%|             range of Unicode digits.
    71|         0|            0|            0|  0.00%|    \D       Matches any non-digit character; equivalent to [^\d].
    72|         0|            0|            0|  0.00%|    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in
    73|         0|            0|            0|  0.00%|             bytes patterns or string patterns with the ASCII flag.
    74|         0|            0|            0|  0.00%|             In string patterns without the ASCII flag, it will match the whole
    75|         0|            0|            0|  0.00%|             range of Unicode whitespace characters.
    76|         0|            0|            0|  0.00%|    \S       Matches any non-whitespace character; equivalent to [^\s].
    77|         0|            0|            0|  0.00%|    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]
    78|         0|            0|            0|  0.00%|             in bytes patterns or string patterns with the ASCII flag.
    79|         0|            0|            0|  0.00%|             In string patterns without the ASCII flag, it will match the
    80|         0|            0|            0|  0.00%|             range of Unicode alphanumeric characters (letters plus digits
    81|         0|            0|            0|  0.00%|             plus underscore).
    82|         0|            0|            0|  0.00%|             With LOCALE, it will match the set [0-9_] plus characters defined
    83|         0|            0|            0|  0.00%|             as letters for the current locale.
    84|         0|            0|            0|  0.00%|    \W       Matches the complement of \w.
    85|         0|            0|            0|  0.00%|    \\       Matches a literal backslash.
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|This module exports the following functions:
    88|         0|            0|            0|  0.00%|    match     Match a regular expression pattern to the beginning of a string.
    89|         0|            0|            0|  0.00%|    fullmatch Match a regular expression pattern to all of a string.
    90|         0|            0|            0|  0.00%|    search    Search a string for the presence of a pattern.
    91|         0|            0|            0|  0.00%|    sub       Substitute occurrences of a pattern found in a string.
    92|         0|            0|            0|  0.00%|    subn      Same as sub, but also return the number of substitutions made.
    93|         0|            0|            0|  0.00%|    split     Split a string by the occurrences of a pattern.
    94|         0|            0|            0|  0.00%|    findall   Find all occurrences of a pattern in a string.
    95|         0|            0|            0|  0.00%|    finditer  Return an iterator yielding a Match object for each match.
    96|         0|            0|            0|  0.00%|    compile   Compile a pattern into a Pattern object.
    97|         0|            0|            0|  0.00%|    purge     Clear the regular expression cache.
    98|         0|            0|            0|  0.00%|    escape    Backslash all non-alphanumerics in a string.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|Each function other than purge and escape can take an optional 'flags' argument
   101|         0|            0|            0|  0.00%|consisting of one or more of the following module constants, joined by "|".
   102|         0|            0|            0|  0.00%|A, L, and U are mutually exclusive.
   103|         0|            0|            0|  0.00%|    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D
   104|         0|            0|            0|  0.00%|                   match the corresponding ASCII character categories
   105|         0|            0|            0|  0.00%|                   (rather than the whole Unicode categories, which is the
   106|         0|            0|            0|  0.00%|                   default).
   107|         0|            0|            0|  0.00%|                   For bytes patterns, this flag is the only available
   108|         0|            0|            0|  0.00%|                   behaviour and needn't be specified.
   109|         0|            0|            0|  0.00%|    I  IGNORECASE  Perform case-insensitive matching.
   110|         0|            0|            0|  0.00%|    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
   111|         0|            0|            0|  0.00%|    M  MULTILINE   "^" matches the beginning of lines (after a newline)
   112|         0|            0|            0|  0.00%|                   as well as the string.
   113|         0|            0|            0|  0.00%|                   "$" matches the end of lines (before a newline) as well
   114|         0|            0|            0|  0.00%|                   as the end of the string.
   115|         0|            0|            0|  0.00%|    S  DOTALL      "." matches any character at all, including the newline.
   116|         0|            0|            0|  0.00%|    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
   117|         0|            0|            0|  0.00%|    U  UNICODE     For compatibility only. Ignored for string patterns (it
   118|         0|            0|            0|  0.00%|                   is the default), and forbidden for bytes patterns.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|This module also defines an exception 'error'.
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|"""
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|import enum
   125|         0|            0|            0|  0.00%|import sre_compile
   126|         0|            0|            0|  0.00%|import sre_parse
   127|         0|            0|            0|  0.00%|import functools
   128|         0|            0|            0|  0.00%|try:
   129|         0|            0|            0|  0.00%|    import _locale
   130|         0|            0|            0|  0.00%|except ImportError:
   131|         0|            0|            0|  0.00%|    _locale = None
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|# public symbols
   135|         0|            0|            0|  0.00%|__all__ = [
   136|         0|            0|            0|  0.00%|    "match", "fullmatch", "search", "sub", "subn", "split",
   137|         0|            0|            0|  0.00%|    "findall", "finditer", "compile", "purge", "template", "escape",
   138|         0|            0|            0|  0.00%|    "error", "Pattern", "Match", "A", "I", "L", "M", "S", "X", "U",
   139|         0|            0|            0|  0.00%|    "ASCII", "IGNORECASE", "LOCALE", "MULTILINE", "DOTALL", "VERBOSE",
   140|         0|            0|            0|  0.00%|    "UNICODE",
   141|         0|            0|            0|  0.00%|]
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|__version__ = "2.2.1"
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|class RegexFlag(enum.IntFlag):
   146|         0|            0|            0|  0.00%|    ASCII = A = sre_compile.SRE_FLAG_ASCII # assume ascii "locale"
   147|         0|            0|            0|  0.00%|    IGNORECASE = I = sre_compile.SRE_FLAG_IGNORECASE # ignore case
   148|         0|            0|            0|  0.00%|    LOCALE = L = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale
   149|         0|            0|            0|  0.00%|    UNICODE = U = sre_compile.SRE_FLAG_UNICODE # assume unicode "locale"
   150|         0|            0|            0|  0.00%|    MULTILINE = M = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline
   151|         0|            0|            0|  0.00%|    DOTALL = S = sre_compile.SRE_FLAG_DOTALL # make dot match newline
   152|         0|            0|            0|  0.00%|    VERBOSE = X = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments
   153|         0|            0|            0|  0.00%|    # sre extensions (experimental, don't rely on these)
   154|         0|            0|            0|  0.00%|    TEMPLATE = T = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking
   155|         0|            0|            0|  0.00%|    DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    def __repr__(self):
   158|         0|            0|            0|  0.00%|        if self._name_ is not None:
   159|         0|            0|            0|  0.00%|            return f're.{self._name_}'
   160|         0|            0|            0|  0.00%|        value = self._value_
   161|         0|            0|            0|  0.00%|        members = []
   162|         0|            0|            0|  0.00%|        negative = value < 0
   163|         0|            0|            0|  0.00%|        if negative:
   164|         0|            0|            0|  0.00%|            value = ~value
   165|         0|            0|            0|  0.00%|        for m in self.__class__:
   166|         0|            0|            0|  0.00%|            if value & m._value_:
   167|         0|            0|            0|  0.00%|                value &= ~m._value_
   168|         0|            0|            0|  0.00%|                members.append(f're.{m._name_}')
   169|         0|            0|            0|  0.00%|        if value:
   170|         0|            0|            0|  0.00%|            members.append(hex(value))
   171|         0|            0|            0|  0.00%|        res = '|'.join(members)
   172|         0|            0|            0|  0.00%|        if negative:
   173|         0|            0|            0|  0.00%|            if len(members) > 1:
   174|         0|            0|            0|  0.00%|                res = f'~({res})'
   175|         0|            0|            0|  0.00%|            else:
   176|         0|            0|            0|  0.00%|                res = f'~{res}'
   177|         0|            0|            0|  0.00%|        return res
   178|         0|            0|            0|  0.00%|    __str__ = object.__str__
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|globals().update(RegexFlag.__members__)
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|# sre exception
   183|         0|            0|            0|  0.00%|error = sre_compile.error
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|# --------------------------------------------------------------------
   186|         0|            0|            0|  0.00%|# public interface
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|def match(pattern, string, flags=0):
   189|         0|            0|            0|  0.00%|    """Try to apply the pattern at the start of the string, returning
   190|         0|            0|            0|  0.00%|    a Match object, or None if no match was found."""
   191|         0|            0|            0|  0.00%|    return _compile(pattern, flags).match(string)
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|def fullmatch(pattern, string, flags=0):
   194|         0|            0|            0|  0.00%|    """Try to apply the pattern to all of the string, returning
   195|         0|            0|            0|  0.00%|    a Match object, or None if no match was found."""
   196|         0|            0|            0|  0.00%|    return _compile(pattern, flags).fullmatch(string)
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|def search(pattern, string, flags=0):
   199|         0|            0|            0|  0.00%|    """Scan through string looking for a match to the pattern, returning
   200|         0|            0|            0|  0.00%|    a Match object, or None if no match was found."""
   201|         0|            0|            0|  0.00%|    return _compile(pattern, flags).search(string)
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|def sub(pattern, repl, string, count=0, flags=0):
   204|         0|            0|            0|  0.00%|    """Return the string obtained by replacing the leftmost
   205|         0|            0|            0|  0.00%|    non-overlapping occurrences of the pattern in string by the
   206|         0|            0|            0|  0.00%|    replacement repl.  repl can be either a string or a callable;
   207|         0|            0|            0|  0.00%|    if a string, backslash escapes in it are processed.  If it is
   208|         0|            0|            0|  0.00%|    a callable, it's passed the Match object and must return
   209|         0|            0|            0|  0.00%|    a replacement string to be used."""
   210|         0|            0|            0|  0.00%|    return _compile(pattern, flags).sub(repl, string, count)
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|def subn(pattern, repl, string, count=0, flags=0):
   213|         0|            0|            0|  0.00%|    """Return a 2-tuple containing (new_string, number).
   214|         0|            0|            0|  0.00%|    new_string is the string obtained by replacing the leftmost
   215|         0|            0|            0|  0.00%|    non-overlapping occurrences of the pattern in the source
   216|         0|            0|            0|  0.00%|    string by the replacement repl.  number is the number of
   217|         0|            0|            0|  0.00%|    substitutions that were made. repl can be either a string or a
   218|         0|            0|            0|  0.00%|    callable; if a string, backslash escapes in it are processed.
   219|         0|            0|            0|  0.00%|    If it is a callable, it's passed the Match object and must
   220|         0|            0|            0|  0.00%|    return a replacement string to be used."""
   221|         0|            0|            0|  0.00%|    return _compile(pattern, flags).subn(repl, string, count)
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|def split(pattern, string, maxsplit=0, flags=0):
   224|         0|            0|            0|  0.00%|    """Split the source string by the occurrences of the pattern,
   225|         0|            0|            0|  0.00%|    returning a list containing the resulting substrings.  If
   226|         0|            0|            0|  0.00%|    capturing parentheses are used in pattern, then the text of all
   227|         0|            0|            0|  0.00%|    groups in the pattern are also returned as part of the resulting
   228|         0|            0|            0|  0.00%|    list.  If maxsplit is nonzero, at most maxsplit splits occur,
   229|         0|            0|            0|  0.00%|    and the remainder of the string is returned as the final element
   230|         0|            0|            0|  0.00%|    of the list."""
   231|         0|            0|            0|  0.00%|    return _compile(pattern, flags).split(string, maxsplit)
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|def findall(pattern, string, flags=0):
   234|         0|            0|            0|  0.00%|    """Return a list of all non-overlapping matches in the string.
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    If one or more capturing groups are present in the pattern, return
   237|         0|            0|            0|  0.00%|    a list of groups; this will be a list of tuples if the pattern
   238|         0|            0|            0|  0.00%|    has more than one group.
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    Empty matches are included in the result."""
   241|         0|            0|            0|  0.00%|    return _compile(pattern, flags).findall(string)
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|def finditer(pattern, string, flags=0):
   244|         0|            0|            0|  0.00%|    """Return an iterator over all non-overlapping matches in the
   245|         0|            0|            0|  0.00%|    string.  For each match, the iterator returns a Match object.
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    Empty matches are included in the result."""
   248|         0|            0|            0|  0.00%|    return _compile(pattern, flags).finditer(string)
   249|         0|            0|            0|  0.00%|
   250|       370|   0.00145054|  3.92037e-06|  0.00%|def compile(pattern, flags=0):
   251|         0|            0|            0|  0.00%|    "Compile a regular expression pattern, returning a Pattern object."
   252|       370|    0.0043807|  1.18397e-05|  0.00%|    return _compile(pattern, flags)
(call)|       370|     0.413189|   0.00111673|  0.30%|# /opt/conda/lib/python3.8/re.py:289 _compile
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|def purge():
   255|         0|            0|            0|  0.00%|    "Clear the regular expression caches"
   256|         0|            0|            0|  0.00%|    _cache.clear()
   257|         0|            0|            0|  0.00%|    _compile_repl.cache_clear()
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|def template(pattern, flags=0):
   260|         0|            0|            0|  0.00%|    "Compile a template pattern, returning a Pattern object"
   261|         0|            0|            0|  0.00%|    return _compile(pattern, flags|T)
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|# SPECIAL_CHARS
   264|         0|            0|            0|  0.00%|# closing ')', '}' and ']'
   265|         0|            0|            0|  0.00%|# '-' (a range in character set)
   266|         0|            0|            0|  0.00%|# '&', '~', (extended character set operations)
   267|         0|            0|            0|  0.00%|# '#' (comment) and WHITESPACE (ignored) in verbose mode
   268|         0|            0|            0|  0.00%|_special_chars_map = {i: '\\' + chr(i) for i in b'()[]{}?*+-|^$\\.&~# \t\n\r\v\f'}
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|def escape(pattern):
   271|         0|            0|            0|  0.00%|    """
   272|         0|            0|            0|  0.00%|    Escape special characters in a string.
   273|         0|            0|            0|  0.00%|    """
   274|         0|            0|            0|  0.00%|    if isinstance(pattern, str):
   275|         0|            0|            0|  0.00%|        return pattern.translate(_special_chars_map)
   276|         0|            0|            0|  0.00%|    else:
   277|         0|            0|            0|  0.00%|        pattern = str(pattern, 'latin1')
   278|         0|            0|            0|  0.00%|        return pattern.translate(_special_chars_map).encode('latin1')
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|Pattern = type(sre_compile.compile('', 0))
   281|         0|            0|            0|  0.00%|Match = type(sre_compile.compile('', 0).match(''))
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|# --------------------------------------------------------------------
   284|         0|            0|            0|  0.00%|# internals
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|_cache = {}  # ordered!
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|_MAXCACHE = 512
   289|       370|   0.00155091|  4.19166e-06|  0.00%|def _compile(pattern, flags):
   290|         0|            0|            0|  0.00%|    # internal: compile pattern
   291|       370|   0.00221825|  5.99526e-06|  0.00%|    if isinstance(flags, RegexFlag):
   292|       369|   0.00455642|   1.2348e-05|  0.00%|        flags = flags.value
(call)|       369|    0.0114369|  3.09944e-05|  0.01%|# /opt/conda/lib/python3.8/types.py:171 __get__
   293|       370|   0.00148845|  4.02283e-06|  0.00%|    try:
   294|       370|   0.00167084|  4.51578e-06|  0.00%|        return _cache[type(pattern), pattern, flags]
   295|         2|  1.12057e-05|  5.60284e-06|  0.00%|    except KeyError:
   296|         2|  1.07288e-05|  5.36442e-06|  0.00%|        pass
   297|         2|  1.35899e-05|  6.79493e-06|  0.00%|    if isinstance(pattern, Pattern):
   298|         0|            0|            0|  0.00%|        if flags:
   299|         0|            0|            0|  0.00%|            raise ValueError(
   300|         0|            0|            0|  0.00%|                "cannot process flags argument with a compiled pattern")
   301|         0|            0|            0|  0.00%|        return pattern
   302|         2|  4.72069e-05|  2.36034e-05|  0.00%|    if not sre_compile.isstring(pattern):
(call)|         2|  4.14848e-05|  2.07424e-05|  0.00%|# /opt/conda/lib/python3.8/sre_compile.py:595 isstring
   303|         0|            0|            0|  0.00%|        raise TypeError("first argument must be string or compiled pattern")
   304|         2|  9.70364e-05|  4.85182e-05|  0.00%|    p = sre_compile.compile(pattern, flags)
(call)|         2|      0.38964|      0.19482|  0.28%|# /opt/conda/lib/python3.8/sre_compile.py:759 compile
   305|         2|  4.98295e-05|  2.49147e-05|  0.00%|    if not (flags & DEBUG):
(call)|         2|  0.000309706|  0.000154853|  0.00%|# /opt/conda/lib/python3.8/enum.py:933 __and__
   306|         2|  1.52588e-05|  7.62939e-06|  0.00%|        if len(_cache) >= _MAXCACHE:
   307|         0|            0|            0|  0.00%|            # Drop the oldest item
   308|         0|            0|            0|  0.00%|            try:
   309|         0|            0|            0|  0.00%|                del _cache[next(iter(_cache))]
   310|         0|            0|            0|  0.00%|            except (StopIteration, RuntimeError, KeyError):
   311|         0|            0|            0|  0.00%|                pass
   312|         2|  2.00272e-05|  1.00136e-05|  0.00%|        _cache[type(pattern), pattern, flags] = p
   313|         2|  1.09673e-05|  5.48363e-06|  0.00%|    return p
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|@functools.lru_cache(_MAXCACHE)
   316|         0|            0|            0|  0.00%|def _compile_repl(repl, pattern):
   317|         0|            0|            0|  0.00%|    # internal: compile replacement pattern
   318|         0|            0|            0|  0.00%|    return sre_parse.parse_template(repl, pattern)
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|def _expand(pattern, match, template):
   321|         0|            0|            0|  0.00%|    # internal: Match.expand implementation hook
   322|         0|            0|            0|  0.00%|    template = sre_parse.parse_template(template, pattern)
   323|         0|            0|            0|  0.00%|    return sre_parse.expand_template(template, match)
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|def _subx(pattern, template):
   326|         0|            0|            0|  0.00%|    # internal: Pattern.sub/subn implementation helper
   327|         0|            0|            0|  0.00%|    template = _compile_repl(template, pattern)
   328|         0|            0|            0|  0.00%|    if not template[0] and len(template[1]) == 1:
   329|         0|            0|            0|  0.00%|        # literal replacement
   330|         0|            0|            0|  0.00%|        return template[1][0]
   331|         0|            0|            0|  0.00%|    def filter(match, template=template):
   332|         0|            0|            0|  0.00%|        return sre_parse.expand_template(template, match)
   333|         0|            0|            0|  0.00%|    return filter
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|# register myself for pickling
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|import copyreg
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|def _pickle(p):
   340|         0|            0|            0|  0.00%|    return _compile, (p.pattern, p.flags)
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|copyreg.pickle(Pattern, _pickle, _compile)
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|# --------------------------------------------------------------------
   345|         0|            0|            0|  0.00%|# experimental stuff (see python-dev discussions for details)
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|class Scanner:
   348|         0|            0|            0|  0.00%|    def __init__(self, lexicon, flags=0):
   349|         0|            0|            0|  0.00%|        from sre_constants import BRANCH, SUBPATTERN
   350|         0|            0|            0|  0.00%|        if isinstance(flags, RegexFlag):
   351|         0|            0|            0|  0.00%|            flags = flags.value
   352|         0|            0|            0|  0.00%|        self.lexicon = lexicon
   353|         0|            0|            0|  0.00%|        # combine phrases into a compound pattern
   354|         0|            0|            0|  0.00%|        p = []
   355|         0|            0|            0|  0.00%|        s = sre_parse.State()
   356|         0|            0|            0|  0.00%|        s.flags = flags
   357|         0|            0|            0|  0.00%|        for phrase, action in lexicon:
   358|         0|            0|            0|  0.00%|            gid = s.opengroup()
   359|         0|            0|            0|  0.00%|            p.append(sre_parse.SubPattern(s, [
   360|         0|            0|            0|  0.00%|                (SUBPATTERN, (gid, 0, 0, sre_parse.parse(phrase, flags))),
   361|         0|            0|            0|  0.00%|                ]))
   362|         0|            0|            0|  0.00%|            s.closegroup(gid, p[-1])
   363|         0|            0|            0|  0.00%|        p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])
   364|         0|            0|            0|  0.00%|        self.scanner = sre_compile.compile(p)
   365|         0|            0|            0|  0.00%|    def scan(self, string):
   366|         0|            0|            0|  0.00%|        result = []
   367|         0|            0|            0|  0.00%|        append = result.append
   368|         0|            0|            0|  0.00%|        match = self.scanner.scanner(string).match
   369|         0|            0|            0|  0.00%|        i = 0
   370|         0|            0|            0|  0.00%|        while True:
   371|         0|            0|            0|  0.00%|            m = match()
   372|         0|            0|            0|  0.00%|            if not m:
   373|         0|            0|            0|  0.00%|                break
   374|         0|            0|            0|  0.00%|            j = m.end()
   375|         0|            0|            0|  0.00%|            if i == j:
   376|         0|            0|            0|  0.00%|                break
   377|         0|            0|            0|  0.00%|            action = self.lexicon[m.lastindex-1][1]
   378|         0|            0|            0|  0.00%|            if callable(action):
   379|         0|            0|            0|  0.00%|                self.match = m
   380|         0|            0|            0|  0.00%|                action = action(self, m.group())
   381|         0|            0|            0|  0.00%|            if action is not None:
   382|         0|            0|            0|  0.00%|                append(action)
   383|         0|            0|            0|  0.00%|            i = j
   384|         0|            0|            0|  0.00%|        return result, string[i:]
File: /opt/conda/lib/python3.8/types.py
File duration: 0.00860572s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Define names for built-in types that aren't directly accessible as a builtin.
     3|         0|            0|            0|  0.00%|"""
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|# Iterators in Python aren't a matter of type but of protocol.  A large
     7|         0|            0|            0|  0.00%|# and changing number of builtin types implement *some* flavor of
     8|         0|            0|            0|  0.00%|# iterator.  Don't check the type!  Use hasattr to check for both
     9|         0|            0|            0|  0.00%|# "__iter__" and "__next__" attributes instead.
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|def _f(): pass
    12|         0|            0|            0|  0.00%|FunctionType = type(_f)
    13|         0|            0|            0|  0.00%|LambdaType = type(lambda: None)         # Same as FunctionType
    14|         0|            0|            0|  0.00%|CodeType = type(_f.__code__)
    15|         0|            0|            0|  0.00%|MappingProxyType = type(type.__dict__)
    16|         0|            0|            0|  0.00%|SimpleNamespace = type(sys.implementation)
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|def _cell_factory():
    19|         0|            0|            0|  0.00%|    a = 1
    20|         0|            0|            0|  0.00%|    def f():
    21|         0|            0|            0|  0.00%|        nonlocal a
    22|         0|            0|            0|  0.00%|    return f.__closure__[0]
    23|         0|            0|            0|  0.00%|CellType = type(_cell_factory())
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|def _g():
    26|         0|            0|            0|  0.00%|    yield 1
    27|         0|            0|            0|  0.00%|GeneratorType = type(_g())
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|async def _c(): pass
    30|         0|            0|            0|  0.00%|_c = _c()
    31|         0|            0|            0|  0.00%|CoroutineType = type(_c)
    32|         0|            0|            0|  0.00%|_c.close()  # Prevent ResourceWarning
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|async def _ag():
    35|         0|            0|            0|  0.00%|    yield
    36|         0|            0|            0|  0.00%|_ag = _ag()
    37|         0|            0|            0|  0.00%|AsyncGeneratorType = type(_ag)
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|class _C:
    40|         0|            0|            0|  0.00%|    def _m(self): pass
    41|         0|            0|            0|  0.00%|MethodType = type(_C()._m)
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|BuiltinFunctionType = type(len)
    44|         0|            0|            0|  0.00%|BuiltinMethodType = type([].append)     # Same as BuiltinFunctionType
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|WrapperDescriptorType = type(object.__init__)
    47|         0|            0|            0|  0.00%|MethodWrapperType = type(object().__str__)
    48|         0|            0|            0|  0.00%|MethodDescriptorType = type(str.join)
    49|         0|            0|            0|  0.00%|ClassMethodDescriptorType = type(dict.__dict__['fromkeys'])
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|ModuleType = type(sys)
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|try:
    54|         0|            0|            0|  0.00%|    raise TypeError
    55|         0|            0|            0|  0.00%|except TypeError:
    56|         0|            0|            0|  0.00%|    tb = sys.exc_info()[2]
    57|         0|            0|            0|  0.00%|    TracebackType = type(tb)
    58|         0|            0|            0|  0.00%|    FrameType = type(tb.tb_frame)
    59|         0|            0|            0|  0.00%|    tb = None; del tb
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|# For Jython, the following two types are identical
    62|         0|            0|            0|  0.00%|GetSetDescriptorType = type(FunctionType.__code__)
    63|         0|            0|            0|  0.00%|MemberDescriptorType = type(FunctionType.__globals__)
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|del sys, _f, _g, _C, _c, _ag  # Not for export
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|# Provide a PEP 3115 compliant mechanism for class creation
    69|         0|            0|            0|  0.00%|def new_class(name, bases=(), kwds=None, exec_body=None):
    70|         0|            0|            0|  0.00%|    """Create a class object dynamically using the appropriate metaclass."""
    71|         0|            0|            0|  0.00%|    resolved_bases = resolve_bases(bases)
    72|         0|            0|            0|  0.00%|    meta, ns, kwds = prepare_class(name, resolved_bases, kwds)
    73|         0|            0|            0|  0.00%|    if exec_body is not None:
    74|         0|            0|            0|  0.00%|        exec_body(ns)
    75|         0|            0|            0|  0.00%|    if resolved_bases is not bases:
    76|         0|            0|            0|  0.00%|        ns['__orig_bases__'] = bases
    77|         0|            0|            0|  0.00%|    return meta(name, resolved_bases, ns, **kwds)
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|def resolve_bases(bases):
    80|         0|            0|            0|  0.00%|    """Resolve MRO entries dynamically as specified by PEP 560."""
    81|         0|            0|            0|  0.00%|    new_bases = list(bases)
    82|         0|            0|            0|  0.00%|    updated = False
    83|         0|            0|            0|  0.00%|    shift = 0
    84|         0|            0|            0|  0.00%|    for i, base in enumerate(bases):
    85|         0|            0|            0|  0.00%|        if isinstance(base, type):
    86|         0|            0|            0|  0.00%|            continue
    87|         0|            0|            0|  0.00%|        if not hasattr(base, "__mro_entries__"):
    88|         0|            0|            0|  0.00%|            continue
    89|         0|            0|            0|  0.00%|        new_base = base.__mro_entries__(bases)
    90|         0|            0|            0|  0.00%|        updated = True
    91|         0|            0|            0|  0.00%|        if not isinstance(new_base, tuple):
    92|         0|            0|            0|  0.00%|            raise TypeError("__mro_entries__ must return a tuple")
    93|         0|            0|            0|  0.00%|        else:
    94|         0|            0|            0|  0.00%|            new_bases[i+shift:i+shift+1] = new_base
    95|         0|            0|            0|  0.00%|            shift += len(new_base) - 1
    96|         0|            0|            0|  0.00%|    if not updated:
    97|         0|            0|            0|  0.00%|        return bases
    98|         0|            0|            0|  0.00%|    return tuple(new_bases)
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|def prepare_class(name, bases=(), kwds=None):
   101|         0|            0|            0|  0.00%|    """Call the __prepare__ method of the appropriate metaclass.
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    Returns (metaclass, namespace, kwds) as a 3-tuple
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|    *metaclass* is the appropriate metaclass
   106|         0|            0|            0|  0.00%|    *namespace* is the prepared class namespace
   107|         0|            0|            0|  0.00%|    *kwds* is an updated copy of the passed in kwds argument with any
   108|         0|            0|            0|  0.00%|    'metaclass' entry removed. If no kwds argument is passed in, this will
   109|         0|            0|            0|  0.00%|    be an empty dict.
   110|         0|            0|            0|  0.00%|    """
   111|         0|            0|            0|  0.00%|    if kwds is None:
   112|         0|            0|            0|  0.00%|        kwds = {}
   113|         0|            0|            0|  0.00%|    else:
   114|         0|            0|            0|  0.00%|        kwds = dict(kwds) # Don't alter the provided mapping
   115|         0|            0|            0|  0.00%|    if 'metaclass' in kwds:
   116|         0|            0|            0|  0.00%|        meta = kwds.pop('metaclass')
   117|         0|            0|            0|  0.00%|    else:
   118|         0|            0|            0|  0.00%|        if bases:
   119|         0|            0|            0|  0.00%|            meta = type(bases[0])
   120|         0|            0|            0|  0.00%|        else:
   121|         0|            0|            0|  0.00%|            meta = type
   122|         0|            0|            0|  0.00%|    if isinstance(meta, type):
   123|         0|            0|            0|  0.00%|        # when meta is a type, we first determine the most-derived metaclass
   124|         0|            0|            0|  0.00%|        # instead of invoking the initial candidate directly
   125|         0|            0|            0|  0.00%|        meta = _calculate_meta(meta, bases)
   126|         0|            0|            0|  0.00%|    if hasattr(meta, '__prepare__'):
   127|         0|            0|            0|  0.00%|        ns = meta.__prepare__(name, bases, **kwds)
   128|         0|            0|            0|  0.00%|    else:
   129|         0|            0|            0|  0.00%|        ns = {}
   130|         0|            0|            0|  0.00%|    return meta, ns, kwds
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|def _calculate_meta(meta, bases):
   133|         0|            0|            0|  0.00%|    """Calculate the most derived metaclass."""
   134|         0|            0|            0|  0.00%|    winner = meta
   135|         0|            0|            0|  0.00%|    for base in bases:
   136|         0|            0|            0|  0.00%|        base_meta = type(base)
   137|         0|            0|            0|  0.00%|        if issubclass(winner, base_meta):
   138|         0|            0|            0|  0.00%|            continue
   139|         0|            0|            0|  0.00%|        if issubclass(base_meta, winner):
   140|         0|            0|            0|  0.00%|            winner = base_meta
   141|         0|            0|            0|  0.00%|            continue
   142|         0|            0|            0|  0.00%|        # else:
   143|         0|            0|            0|  0.00%|        raise TypeError("metaclass conflict: "
   144|         0|            0|            0|  0.00%|                        "the metaclass of a derived class "
   145|         0|            0|            0|  0.00%|                        "must be a (non-strict) subclass "
   146|         0|            0|            0|  0.00%|                        "of the metaclasses of all its bases")
   147|         0|            0|            0|  0.00%|    return winner
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|class DynamicClassAttribute:
   150|         0|            0|            0|  0.00%|    """Route attribute access on a class to __getattr__.
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    This is a descriptor, used to define attributes that act differently when
   153|         0|            0|            0|  0.00%|    accessed through an instance and through a class.  Instance access remains
   154|         0|            0|            0|  0.00%|    normal, but access to an attribute through a class will be routed to the
   155|         0|            0|            0|  0.00%|    class's __getattr__ method; this is done by raising AttributeError.
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    This allows one to have properties active on an instance, and have virtual
   158|         0|            0|            0|  0.00%|    attributes on the class with the same name (see Enum for an example).
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    """
   161|         0|            0|            0|  0.00%|    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
   162|         0|            0|            0|  0.00%|        self.fget = fget
   163|         0|            0|            0|  0.00%|        self.fset = fset
   164|         0|            0|            0|  0.00%|        self.fdel = fdel
   165|         0|            0|            0|  0.00%|        # next two lines make DynamicClassAttribute act the same as property
   166|         0|            0|            0|  0.00%|        self.__doc__ = doc or fget.__doc__
   167|         0|            0|            0|  0.00%|        self.overwrite_doc = doc is None
   168|         0|            0|            0|  0.00%|        # support for abstract methods
   169|         0|            0|            0|  0.00%|        self.__isabstractmethod__ = bool(getattr(fget, '__isabstractmethod__', False))
   170|         0|            0|            0|  0.00%|
   171|       369|   0.00152802|  4.14099e-06|  0.00%|    def __get__(self, instance, ownerclass=None):
   172|       369|   0.00143433|  3.88706e-06|  0.00%|        if instance is None:
   173|         0|            0|            0|  0.00%|            if self.__isabstractmethod__:
   174|         0|            0|            0|  0.00%|                return self
   175|         0|            0|            0|  0.00%|            raise AttributeError()
   176|       369|   0.00140691|  3.81276e-06|  0.00%|        elif self.fget is None:
   177|         0|            0|            0|  0.00%|            raise AttributeError("unreadable attribute")
   178|       369|   0.00423646|  1.14809e-05|  0.00%|        return self.fget(instance)
(call)|       369|   0.00283122|  7.67268e-06|  0.00%|# /opt/conda/lib/python3.8/enum.py:748 value
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|    def __set__(self, instance, value):
   181|         0|            0|            0|  0.00%|        if self.fset is None:
   182|         0|            0|            0|  0.00%|            raise AttributeError("can't set attribute")
   183|         0|            0|            0|  0.00%|        self.fset(instance, value)
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    def __delete__(self, instance):
   186|         0|            0|            0|  0.00%|        if self.fdel is None:
   187|         0|            0|            0|  0.00%|            raise AttributeError("can't delete attribute")
   188|         0|            0|            0|  0.00%|        self.fdel(instance)
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    def getter(self, fget):
   191|         0|            0|            0|  0.00%|        fdoc = fget.__doc__ if self.overwrite_doc else None
   192|         0|            0|            0|  0.00%|        result = type(self)(fget, self.fset, self.fdel, fdoc or self.__doc__)
   193|         0|            0|            0|  0.00%|        result.overwrite_doc = self.overwrite_doc
   194|         0|            0|            0|  0.00%|        return result
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    def setter(self, fset):
   197|         0|            0|            0|  0.00%|        result = type(self)(self.fget, fset, self.fdel, self.__doc__)
   198|         0|            0|            0|  0.00%|        result.overwrite_doc = self.overwrite_doc
   199|         0|            0|            0|  0.00%|        return result
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    def deleter(self, fdel):
   202|         0|            0|            0|  0.00%|        result = type(self)(self.fget, self.fset, fdel, self.__doc__)
   203|         0|            0|            0|  0.00%|        result.overwrite_doc = self.overwrite_doc
   204|         0|            0|            0|  0.00%|        return result
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|class _GeneratorWrapper:
   208|         0|            0|            0|  0.00%|    # TODO: Implement this in C.
   209|         0|            0|            0|  0.00%|    def __init__(self, gen):
   210|         0|            0|            0|  0.00%|        self.__wrapped = gen
   211|         0|            0|            0|  0.00%|        self.__isgen = gen.__class__ is GeneratorType
   212|         0|            0|            0|  0.00%|        self.__name__ = getattr(gen, '__name__', None)
   213|         0|            0|            0|  0.00%|        self.__qualname__ = getattr(gen, '__qualname__', None)
   214|         0|            0|            0|  0.00%|    def send(self, val):
   215|         0|            0|            0|  0.00%|        return self.__wrapped.send(val)
   216|         0|            0|            0|  0.00%|    def throw(self, tp, *rest):
   217|         0|            0|            0|  0.00%|        return self.__wrapped.throw(tp, *rest)
   218|         0|            0|            0|  0.00%|    def close(self):
   219|         0|            0|            0|  0.00%|        return self.__wrapped.close()
   220|         0|            0|            0|  0.00%|    @property
   221|         0|            0|            0|  0.00%|    def gi_code(self):
   222|         0|            0|            0|  0.00%|        return self.__wrapped.gi_code
   223|         0|            0|            0|  0.00%|    @property
   224|         0|            0|            0|  0.00%|    def gi_frame(self):
   225|         0|            0|            0|  0.00%|        return self.__wrapped.gi_frame
   226|         0|            0|            0|  0.00%|    @property
   227|         0|            0|            0|  0.00%|    def gi_running(self):
   228|         0|            0|            0|  0.00%|        return self.__wrapped.gi_running
   229|         0|            0|            0|  0.00%|    @property
   230|         0|            0|            0|  0.00%|    def gi_yieldfrom(self):
   231|         0|            0|            0|  0.00%|        return self.__wrapped.gi_yieldfrom
   232|         0|            0|            0|  0.00%|    cr_code = gi_code
   233|         0|            0|            0|  0.00%|    cr_frame = gi_frame
   234|         0|            0|            0|  0.00%|    cr_running = gi_running
   235|         0|            0|            0|  0.00%|    cr_await = gi_yieldfrom
   236|         0|            0|            0|  0.00%|    def __next__(self):
   237|         0|            0|            0|  0.00%|        return next(self.__wrapped)
   238|         0|            0|            0|  0.00%|    def __iter__(self):
   239|         0|            0|            0|  0.00%|        if self.__isgen:
   240|         0|            0|            0|  0.00%|            return self.__wrapped
   241|         0|            0|            0|  0.00%|        return self
   242|         0|            0|            0|  0.00%|    __await__ = __iter__
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|def coroutine(func):
   245|         0|            0|            0|  0.00%|    """Convert regular generator function to a coroutine."""
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    if not callable(func):
   248|         0|            0|            0|  0.00%|        raise TypeError('types.coroutine() expects a callable')
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|    if (func.__class__ is FunctionType and
   251|         0|            0|            0|  0.00%|        getattr(func, '__code__', None).__class__ is CodeType):
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|        co_flags = func.__code__.co_flags
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|        # Check if 'func' is a coroutine function.
   256|         0|            0|            0|  0.00%|        # (0x180 == CO_COROUTINE | CO_ITERABLE_COROUTINE)
   257|         0|            0|            0|  0.00%|        if co_flags & 0x180:
   258|         0|            0|            0|  0.00%|            return func
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|        # Check if 'func' is a generator function.
   261|         0|            0|            0|  0.00%|        # (0x20 == CO_GENERATOR)
   262|         0|            0|            0|  0.00%|        if co_flags & 0x20:
   263|         0|            0|            0|  0.00%|            # TODO: Implement this in C.
   264|         0|            0|            0|  0.00%|            co = func.__code__
   265|         0|            0|            0|  0.00%|            # 0x100 == CO_ITERABLE_COROUTINE
   266|         0|            0|            0|  0.00%|            func.__code__ = co.replace(co_flags=co.co_flags | 0x100)
   267|         0|            0|            0|  0.00%|            return func
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|    # The following code is primarily to support functions that
   270|         0|            0|            0|  0.00%|    # return generator-like objects (for instance generators
   271|         0|            0|            0|  0.00%|    # compiled with Cython).
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    # Delay functools and _collections_abc import for speeding up types import.
   274|         0|            0|            0|  0.00%|    import functools
   275|         0|            0|            0|  0.00%|    import _collections_abc
   276|         0|            0|            0|  0.00%|    @functools.wraps(func)
   277|         0|            0|            0|  0.00%|    def wrapped(*args, **kwargs):
   278|         0|            0|            0|  0.00%|        coro = func(*args, **kwargs)
   279|         0|            0|            0|  0.00%|        if (coro.__class__ is CoroutineType or
   280|         0|            0|            0|  0.00%|            coro.__class__ is GeneratorType and coro.gi_code.co_flags & 0x100):
   281|         0|            0|            0|  0.00%|            # 'coro' is a native coroutine object or an iterable coroutine
   282|         0|            0|            0|  0.00%|            return coro
   283|         0|            0|            0|  0.00%|        if (isinstance(coro, _collections_abc.Generator) and
   284|         0|            0|            0|  0.00%|            not isinstance(coro, _collections_abc.Coroutine)):
   285|         0|            0|            0|  0.00%|            # 'coro' is either a pure Python generator iterator, or it
   286|         0|            0|            0|  0.00%|            # implements collections.abc.Generator (and does not implement
   287|         0|            0|            0|  0.00%|            # collections.abc.Coroutine).
   288|         0|            0|            0|  0.00%|            return _GeneratorWrapper(coro)
   289|         0|            0|            0|  0.00%|        # 'coro' is either an instance of collections.abc.Coroutine or
   290|         0|            0|            0|  0.00%|        # some other object -- pass it through.
   291|         0|            0|            0|  0.00%|        return coro
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    return wrapped
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|__all__ = [n for n in globals() if n[:1] != '_']
File: /opt/conda/lib/python3.8/site-packages/memory_profiler.py
File duration: 0.00797749s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Profile the memory usage of a Python program"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|# .. we'll use this to pass it to the child script ..
     4|         0|            0|            0|  0.00%|_CLEAN_GLOBALS = globals().copy()
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|__version__ = '0.58.0'
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|_CMD_USAGE = "python -m memory_profiler script_file.py"
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|from asyncio import coroutine, iscoroutinefunction
    11|         0|            0|            0|  0.00%|from contextlib import contextmanager
    12|         0|            0|            0|  0.00%|from functools import partial, wraps
    13|         0|            0|            0|  0.00%|import builtins
    14|         0|            0|            0|  0.00%|import inspect
    15|         0|            0|            0|  0.00%|import linecache
    16|         0|            0|            0|  0.00%|import logging
    17|         0|            0|            0|  0.00%|import os
    18|         0|            0|            0|  0.00%|import pdb
    19|         0|            0|            0|  0.00%|import subprocess
    20|         0|            0|            0|  0.00%|import sys
    21|         0|            0|            0|  0.00%|import time
    22|         0|            0|            0|  0.00%|import traceback
    23|         0|            0|            0|  0.00%|import warnings
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|if sys.platform == "win32":
    26|         0|            0|            0|  0.00%|    # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT
    27|         0|            0|            0|  0.00%|    # can be used to kill a process unconditionally in Windows
    28|         0|            0|            0|  0.00%|    SIGKILL = -1
    29|         0|            0|            0|  0.00%|else:
    30|         0|            0|            0|  0.00%|    from signal import SIGKILL
    31|         0|            0|            0|  0.00%|import psutil
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|# TODO: provide alternative when multiprocessing is not available
    35|         0|            0|            0|  0.00%|try:
    36|         0|            0|            0|  0.00%|    from multiprocessing import Process, Pipe
    37|         0|            0|            0|  0.00%|except ImportError:
    38|         0|            0|            0|  0.00%|    from multiprocessing.dummy import Process, Pipe
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|try:
    41|         0|            0|            0|  0.00%|    from IPython.core.magic import Magics, line_cell_magic, magics_class
    42|         0|            0|            0|  0.00%|except ImportError:
    43|         0|            0|            0|  0.00%|    # ipython_version < '0.13'
    44|         0|            0|            0|  0.00%|    Magics = object
    45|         0|            0|            0|  0.00%|    line_cell_magic = lambda func: func
    46|         0|            0|            0|  0.00%|    magics_class = lambda cls: cls
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|_TWO_20 = float(2 ** 20)
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|# .. get available packages ..
    52|         0|            0|            0|  0.00%|try:
    53|         0|            0|            0|  0.00%|    import tracemalloc
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|    has_tracemalloc = True
    56|         0|            0|            0|  0.00%|except ImportError:
    57|         0|            0|            0|  0.00%|    has_tracemalloc = False
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|class MemitResult(object):
    61|         0|            0|            0|  0.00%|    """memit magic run details.
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    Object based on IPython's TimeitResult
    64|         0|            0|            0|  0.00%|    """
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    def __init__(self, mem_usage, baseline, repeat, timeout, interval,
    67|         0|            0|            0|  0.00%|                 include_children):
    68|         0|            0|            0|  0.00%|        self.mem_usage = mem_usage
    69|         0|            0|            0|  0.00%|        self.baseline = baseline
    70|         0|            0|            0|  0.00%|        self.repeat = repeat
    71|         0|            0|            0|  0.00%|        self.timeout = timeout
    72|         0|            0|            0|  0.00%|        self.interval = interval
    73|         0|            0|            0|  0.00%|        self.include_children = include_children
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    def __str__(self):
    76|         0|            0|            0|  0.00%|        max_mem = max(self.mem_usage)
    77|         0|            0|            0|  0.00%|        inc = max_mem - self.baseline
    78|         0|            0|            0|  0.00%|        return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    def _repr_pretty_(self, p, cycle):
    81|         0|            0|            0|  0.00%|        msg = str(self)
    82|         0|            0|            0|  0.00%|        p.text(u'<MemitResult : ' + msg + u'>')
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|def _get_child_memory(process, meminfo_attr=None):
    86|         0|            0|            0|  0.00%|    """
    87|         0|            0|            0|  0.00%|    Returns a generator that yields memory for all child processes.
    88|         0|            0|            0|  0.00%|    """
    89|         0|            0|            0|  0.00%|    # Convert a pid to a process
    90|         0|            0|            0|  0.00%|    if isinstance(process, int):
    91|         0|            0|            0|  0.00%|        if process == -1: process = os.getpid()
    92|         0|            0|            0|  0.00%|        process = psutil.Process(process)
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    if not meminfo_attr:
    95|         0|            0|            0|  0.00%|        # Use the psutil 2.0 attr if the older version isn't passed in.
    96|         0|            0|            0|  0.00%|        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    # Select the psutil function get the children similar to how we selected
    99|         0|            0|            0|  0.00%|    # the memory_info attr (a change from excepting the AttributeError).
   100|         0|            0|            0|  0.00%|    children_attr = 'children' if hasattr(process, 'children') else 'get_children'
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    # Loop over the child processes and yield their memory
   103|         0|            0|            0|  0.00%|    try:
   104|         0|            0|            0|  0.00%|        for child in getattr(process, children_attr)(recursive=True):
   105|         0|            0|            0|  0.00%|            yield getattr(child, meminfo_attr)()[0] / _TWO_20
   106|         0|            0|            0|  0.00%|    except (psutil.NoSuchProcess, psutil.AccessDenied):
   107|         0|            0|            0|  0.00%|        # https://github.com/fabianp/memory_profiler/issues/71
   108|         0|            0|            0|  0.00%|        yield 0.0
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|def _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):
   112|         0|            0|            0|  0.00%|    # .. low function to get memory consumption ..
   113|         0|            0|            0|  0.00%|    if pid == -1:
   114|         0|            0|            0|  0.00%|        pid = os.getpid()
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    def tracemalloc_tool():
   117|         0|            0|            0|  0.00%|        # .. cross-platform but but requires Python 3.4 or higher ..
   118|         0|            0|            0|  0.00%|        stat = next(filter(lambda item: str(item).startswith(filename),
   119|         0|            0|            0|  0.00%|                           tracemalloc.take_snapshot().statistics('filename')))
   120|         0|            0|            0|  0.00%|        mem = stat.size / _TWO_20
   121|         0|            0|            0|  0.00%|        if timestamps:
   122|         2|  9.01222e-05|  4.50611e-05|  0.00%|            return mem, time.time()
   123|         0|            0|            0|  0.00%|        else:
   124|         0|            0|            0|  0.00%|            return mem
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    def ps_util_tool():
   127|         0|            0|            0|  0.00%|        # .. cross-platform but but requires psutil ..
   128|         0|            0|            0|  0.00%|        process = psutil.Process(pid)
   129|         0|            0|            0|  0.00%|        try:
   130|         0|            0|            0|  0.00%|            # avoid using get_memory_info since it does not exists
   131|         0|            0|            0|  0.00%|            # in psutil > 2.0 and accessing it will cause exception.
   132|         0|            0|            0|  0.00%|            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \
   133|         0|            0|            0|  0.00%|                else 'get_memory_info'
   134|         0|            0|            0|  0.00%|            mem = getattr(process, meminfo_attr)()[0] / _TWO_20
   135|         0|            0|            0|  0.00%|            if include_children:
   136|         0|            0|            0|  0.00%|                mem +=  sum(_get_child_memory(process, meminfo_attr))
   137|         0|            0|            0|  0.00%|            if timestamps:
   138|         0|            0|            0|  0.00%|                return mem, time.time()
   139|         0|            0|            0|  0.00%|            else:
   140|         0|            0|            0|  0.00%|                return mem
   141|         0|            0|            0|  0.00%|        except psutil.AccessDenied:
   142|         0|            0|            0|  0.00%|            pass
   143|         0|            0|            0|  0.00%|            # continue and try to get this from ps
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|    def posix_tool():
   146|         0|            0|            0|  0.00%|        # .. scary stuff ..
   147|         0|            0|            0|  0.00%|        if include_children:
   148|         0|            0|            0|  0.00%|            raise NotImplementedError((
   149|         0|            0|            0|  0.00%|                "The psutil module is required to monitor the "
   150|         0|            0|            0|  0.00%|                "memory usage of child processes."
   151|         0|            0|            0|  0.00%|            ))
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|        warnings.warn("psutil module not found. memory_profiler will be slow")
   154|         0|            0|            0|  0.00%|        # ..
   155|         0|            0|            0|  0.00%|        # .. memory usage in MiB ..
   156|         0|            0|            0|  0.00%|        # .. this should work on both Mac and Linux ..
   157|         0|            0|            0|  0.00%|        # .. subprocess.check_output appeared in 2.7, using Popen ..
   158|         0|            0|            0|  0.00%|        # .. for backwards compatibility ..
   159|         0|            0|            0|  0.00%|        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],
   160|         0|            0|            0|  0.00%|                               stdout=subprocess.PIPE
   161|         0|            0|            0|  0.00%|                               ).communicate()[0].split(b'\n')
   162|         0|            0|            0|  0.00%|        try:
   163|         0|            0|            0|  0.00%|            vsz_index = out[0].split().index(b'RSS')
   164|         0|            0|            0|  0.00%|            mem = float(out[1].split()[vsz_index]) / 1024
   165|         0|            0|            0|  0.00%|            if timestamps:
   166|         0|            0|            0|  0.00%|                return mem, time.time()
   167|         0|            0|            0|  0.00%|            else:
   168|         0|            0|            0|  0.00%|                return mem
   169|         0|            0|            0|  0.00%|        except:
   170|         0|            0|            0|  0.00%|            if timestamps:
   171|         0|            0|            0|  0.00%|                return -1, time.time()
   172|         0|            0|            0|  0.00%|            else:
   173|         0|            0|            0|  0.00%|                return -1
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    if backend == 'tracemalloc' and \
   176|         0|            0|            0|  0.00%|            (filename is None or filename == '<unknown>'):
   177|         0|            0|            0|  0.00%|        raise RuntimeError(
   178|         0|            0|            0|  0.00%|            'There is no access to source file of the profiled function'
   179|         0|            0|            0|  0.00%|        )
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    tools = {'tracemalloc': tracemalloc_tool,
   182|         0|            0|            0|  0.00%|             'psutil': ps_util_tool,
   183|         0|            0|            0|  0.00%|             'posix': posix_tool}
   184|         0|            0|            0|  0.00%|    return tools[backend]()
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|class MemTimer(Process):
   188|         0|            0|            0|  0.00%|    """
   189|         0|            0|            0|  0.00%|    Fetch memory consumption from over a time interval
   190|         0|            0|            0|  0.00%|    """
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|    def __init__(self, monitor_pid, interval, pipe, backend, max_usage=False,
   193|         0|            0|            0|  0.00%|                 *args, **kw):
   194|         0|            0|            0|  0.00%|        self.monitor_pid = monitor_pid
   195|         0|            0|            0|  0.00%|        self.interval = interval
   196|         0|            0|            0|  0.00%|        self.pipe = pipe
   197|         0|            0|            0|  0.00%|        self.cont = True
   198|         0|            0|            0|  0.00%|        self.backend = backend
   199|         0|            0|            0|  0.00%|        self.max_usage = max_usage
   200|         0|            0|            0|  0.00%|        self.n_measurements = 1
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|        self.timestamps = kw.pop("timestamps", False)
   203|         0|            0|            0|  0.00%|        self.include_children = kw.pop("include_children", False)
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|        # get baseline memory usage
   206|         0|            0|            0|  0.00%|        self.mem_usage = [
   207|         0|            0|            0|  0.00%|            _get_memory(self.monitor_pid, self.backend, timestamps=self.timestamps,
   208|         0|            0|            0|  0.00%|                        include_children=self.include_children)]
   209|         0|            0|            0|  0.00%|        super(MemTimer, self).__init__(*args, **kw)
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|    def run(self):
   212|         0|            0|            0|  0.00%|        self.pipe.send(0)  # we're ready
   213|         0|            0|            0|  0.00%|        stop = False
   214|         0|            0|            0|  0.00%|        while True:
   215|         0|            0|            0|  0.00%|            cur_mem = _get_memory(
   216|         0|            0|            0|  0.00%|                self.monitor_pid, self.backend, timestamps=self.timestamps,
   217|         0|            0|            0|  0.00%|                include_children=self.include_children,)
   218|         0|            0|            0|  0.00%|            if not self.max_usage:
   219|         0|            0|            0|  0.00%|                self.mem_usage.append(cur_mem)
   220|         0|            0|            0|  0.00%|            else:
   221|         0|            0|            0|  0.00%|                self.mem_usage[0] = max(cur_mem, self.mem_usage[0])
   222|         0|            0|            0|  0.00%|            self.n_measurements += 1
   223|         0|            0|            0|  0.00%|            if stop:
   224|         0|            0|            0|  0.00%|                break
   225|         0|            0|            0|  0.00%|            stop = self.pipe.poll(self.interval)
   226|         0|            0|            0|  0.00%|            # do one more iteration
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|        self.pipe.send(self.mem_usage)
   229|         0|            0|            0|  0.00%|        self.pipe.send(self.n_measurements)
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|def memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,
   233|         0|            0|            0|  0.00%|                 include_children=False, multiprocess=False, max_usage=False,
   234|         0|            0|            0|  0.00%|                 retval=False, stream=None, backend=None, max_iterations=None):
   235|         0|            0|            0|  0.00%|    """
   236|         0|            0|            0|  0.00%|    Return the memory usage of a process or piece of code
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|    Parameters
   239|         0|            0|            0|  0.00%|    ----------
   240|         0|            0|            0|  0.00%|    proc : {int, string, tuple, subprocess.Popen}, optional
   241|         0|            0|            0|  0.00%|        The process to monitor. Can be given by an integer/string
   242|         0|            0|            0|  0.00%|        representing a PID, by a Popen object or by a tuple
   243|         0|            0|            0|  0.00%|        representing a Python function. The tuple contains three
   244|         0|            0|            0|  0.00%|        values (f, args, kw) and specifies to run the function
   245|         0|            0|            0|  0.00%|        f(*args, **kw).
   246|         0|            0|            0|  0.00%|        Set to -1 (default) for current process.
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    interval : float, optional
   249|         0|            0|            0|  0.00%|        Interval at which measurements are collected.
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    timeout : float, optional
   252|         0|            0|            0|  0.00%|        Maximum amount of time (in seconds) to wait before returning.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    max_usage : bool, optional
   255|         0|            0|            0|  0.00%|        Only return the maximum memory usage (default False)
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    retval : bool, optional
   258|         0|            0|            0|  0.00%|        For profiling python functions. Save the return value of the profiled
   259|         0|            0|            0|  0.00%|        function. Return value of memory_usage becomes a tuple:
   260|         0|            0|            0|  0.00%|        (mem_usage, retval)
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    timestamps : bool, optional
   263|         0|            0|            0|  0.00%|        if True, timestamps of memory usage measurement are collected as well.
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|    include_children : bool, optional
   266|         0|            0|            0|  0.00%|        if True, sum the memory of all forked processes as well
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    multiprocess : bool, optional
   269|         0|            0|            0|  0.00%|        if True, track the memory usage of all forked processes.
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    stream : File
   272|         0|            0|            0|  0.00%|        if stream is a File opened with write access, then results are written
   273|         0|            0|            0|  0.00%|        to this file instead of stored in memory and returned at the end of
   274|         0|            0|            0|  0.00%|        the subprocess. Useful for long-running processes.
   275|         0|            0|            0|  0.00%|        Implies timestamps=True.
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|    max_iterations : int
   278|         0|            0|            0|  0.00%|        Limits the number of iterations (calls to the process being monitored). Relevent
   279|         0|            0|            0|  0.00%|        when the process is a python function.
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    Returns
   282|         0|            0|            0|  0.00%|    -------
   283|         0|            0|            0|  0.00%|    mem_usage : list of floating-point values
   284|         0|            0|            0|  0.00%|        memory usage, in MiB. It's length is always < timeout / interval
   285|         0|            0|            0|  0.00%|        if max_usage is given, returns the two elements maximum memory and
   286|         0|            0|            0|  0.00%|        number of measurements effectuated
   287|         0|            0|            0|  0.00%|    ret : return value of the profiled function
   288|         0|            0|            0|  0.00%|        Only returned if retval is set to True
   289|         0|            0|            0|  0.00%|    """
   290|         0|            0|            0|  0.00%|    backend = choose_backend(backend)
   291|         0|            0|            0|  0.00%|    if stream is not None:
   292|         0|            0|            0|  0.00%|        timestamps = True
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    if not max_usage:
   295|         0|            0|            0|  0.00%|        ret = []
   296|         0|            0|            0|  0.00%|    else:
   297|         0|            0|            0|  0.00%|        ret = -1
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    if timeout is not None:
   300|         0|            0|            0|  0.00%|        max_iter = int(round(timeout / interval))
   301|         0|            0|            0|  0.00%|    elif isinstance(proc, int):
   302|         0|            0|            0|  0.00%|        # external process and no timeout
   303|         0|            0|            0|  0.00%|        max_iter = 1
   304|         0|            0|            0|  0.00%|    else:
   305|         0|            0|            0|  0.00%|        # for a Python function wait until it finishes
   306|         0|            0|            0|  0.00%|        max_iter = float('inf')
   307|         0|            0|            0|  0.00%|        if max_iterations is not None:
   308|         0|            0|            0|  0.00%|            max_iter = max_iterations
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    if callable(proc):
   311|         0|            0|            0|  0.00%|        proc = (proc, (), {})
   312|         0|            0|            0|  0.00%|    if isinstance(proc, (list, tuple)):
   313|         0|            0|            0|  0.00%|        if len(proc) == 1:
   314|         0|            0|            0|  0.00%|            f, args, kw = (proc[0], (), {})
   315|         0|            0|            0|  0.00%|        elif len(proc) == 2:
   316|         0|            0|            0|  0.00%|            f, args, kw = (proc[0], proc[1], {})
   317|         0|            0|            0|  0.00%|        elif len(proc) == 3:
   318|         0|            0|            0|  0.00%|            f, args, kw = (proc[0], proc[1], proc[2])
   319|         0|            0|            0|  0.00%|        else:
   320|         0|            0|            0|  0.00%|            raise ValueError
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|        current_iter = 0
   323|         0|            0|            0|  0.00%|        while True:
   324|         0|            0|            0|  0.00%|            current_iter += 1
   325|         0|            0|            0|  0.00%|            child_conn, parent_conn = Pipe()  # this will store MemTimer's results
   326|         0|            0|            0|  0.00%|            p = MemTimer(os.getpid(), interval, child_conn, backend,
   327|         0|            0|            0|  0.00%|                         timestamps=timestamps,
   328|         0|            0|            0|  0.00%|                         max_usage=max_usage,
   329|         0|            0|            0|  0.00%|                         include_children=include_children)
   330|         0|            0|            0|  0.00%|            p.start()
   331|         0|            0|            0|  0.00%|            parent_conn.recv()  # wait until we start getting memory
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|            # When there is an exception in the "proc" - the (spawned) monitoring processes don't get killed.
   334|         0|            0|            0|  0.00%|            # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!
   335|         0|            0|            0|  0.00%|            try:
   336|         0|            0|            0|  0.00%|                returned = f(*args, **kw)
   337|         0|            0|            0|  0.00%|                parent_conn.send(0)  # finish timing
   338|         0|            0|            0|  0.00%|                ret = parent_conn.recv()
   339|         0|            0|            0|  0.00%|                n_measurements = parent_conn.recv()
   340|         0|            0|            0|  0.00%|                if max_usage:
   341|         0|            0|            0|  0.00%|                    # Convert the one element list produced by MemTimer to a singular value
   342|         0|            0|            0|  0.00%|                    ret = ret[0]
   343|         0|            0|            0|  0.00%|                if retval:
   344|         0|            0|            0|  0.00%|                    ret = ret, returned
   345|         0|            0|            0|  0.00%|            except Exception:
   346|         0|            0|            0|  0.00%|                parent = psutil.Process(os.getpid())
   347|         0|            0|            0|  0.00%|                for child in parent.children(recursive=True):
   348|         0|            0|            0|  0.00%|                    os.kill(child.pid, SIGKILL)
   349|         0|            0|            0|  0.00%|                p.join(0)
   350|         0|            0|            0|  0.00%|                raise
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|            p.join(5 * interval)
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|            if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):
   355|         0|            0|            0|  0.00%|                break
   356|         0|            0|            0|  0.00%|            interval /= 10.
   357|         0|            0|            0|  0.00%|    elif isinstance(proc, subprocess.Popen):
   358|         0|            0|            0|  0.00%|        # external process, launched from Python
   359|         0|            0|            0|  0.00%|        line_count = 0
   360|         0|            0|            0|  0.00%|        while True:
   361|         0|            0|            0|  0.00%|            if not max_usage:
   362|         0|            0|            0|  0.00%|                mem_usage = _get_memory(
   363|         0|            0|            0|  0.00%|                    proc.pid, backend, timestamps=timestamps,
   364|         0|            0|            0|  0.00%|                    include_children=include_children)
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|                if stream is not None:
   367|         0|            0|            0|  0.00%|                    stream.write("MEM {0:.6f} {1:.4f}\n".format(*mem_usage))
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|                    # Write children to the stream file
   370|         0|            0|            0|  0.00%|                    if multiprocess:
   371|         0|            0|            0|  0.00%|                        for idx, chldmem in enumerate(_get_child_memory(proc.pid)):
   372|         0|            0|            0|  0.00%|                            stream.write("CHLD {0} {1:.6f} {2:.4f}\n".format(idx, chldmem, time.time()))
   373|         0|            0|            0|  0.00%|                else:
   374|         0|            0|            0|  0.00%|                    # Create a nested list with the child memory
   375|         0|            0|            0|  0.00%|                    if multiprocess:
   376|         0|            0|            0|  0.00%|                        mem_usage = [mem_usage]
   377|         0|            0|            0|  0.00%|                        for chldmem in _get_child_memory(proc.pid):
   378|         0|            0|            0|  0.00%|                            mem_usage.append(chldmem)
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|                    # Append the memory usage to the return value
   381|         0|            0|            0|  0.00%|                    ret.append(mem_usage)
   382|         0|            0|            0|  0.00%|            else:
   383|         0|            0|            0|  0.00%|                ret = max(ret,
   384|         0|            0|            0|  0.00%|                          _get_memory(
   385|         0|            0|            0|  0.00%|                              proc.pid, backend, include_children=include_children))
   386|         0|            0|            0|  0.00%|            time.sleep(interval)
   387|         0|            0|            0|  0.00%|            line_count += 1
   388|         0|            0|            0|  0.00%|            # flush every 50 lines. Make 'tail -f' usable on profile file
   389|         0|            0|            0|  0.00%|            if line_count > 50:
   390|         0|            0|            0|  0.00%|                line_count = 0
   391|         0|            0|            0|  0.00%|                if stream is not None:
   392|         0|            0|            0|  0.00%|                    stream.flush()
   393|         0|            0|            0|  0.00%|            if timeout is not None:
   394|         0|            0|            0|  0.00%|                max_iter -= 1
   395|         0|            0|            0|  0.00%|                if max_iter == 0:
   396|         0|            0|            0|  0.00%|                    break
   397|         0|            0|            0|  0.00%|            if proc.poll() is not None:
   398|         0|            0|            0|  0.00%|                break
   399|         0|            0|            0|  0.00%|    else:
   400|         0|            0|            0|  0.00%|        # external process
   401|         0|            0|            0|  0.00%|        if max_iter == -1:
   402|         0|            0|            0|  0.00%|            max_iter = 1
   403|         0|            0|            0|  0.00%|        counter = 0
   404|         0|            0|            0|  0.00%|        while counter < max_iter:
   405|         0|            0|            0|  0.00%|            counter += 1
   406|         0|            0|            0|  0.00%|            if not max_usage:
   407|         0|            0|            0|  0.00%|                mem_usage = _get_memory(
   408|         0|            0|            0|  0.00%|                    proc, backend, timestamps=timestamps,
   409|         0|            0|            0|  0.00%|                    include_children=include_children)
   410|         0|            0|            0|  0.00%|                if stream is not None:
   411|         0|            0|            0|  0.00%|                    stream.write("MEM {0:.6f} {1:.4f}\n".format(*mem_usage))
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|                    # Write children to the stream file
   414|         0|            0|            0|  0.00%|                    if multiprocess:
   415|         0|            0|            0|  0.00%|                        for idx, chldmem in enumerate(_get_child_memory(proc)):
   416|         0|            0|            0|  0.00%|                            stream.write("CHLD {0} {1:.6f} {2:.4f}\n".format(idx, chldmem, time.time()))
   417|         0|            0|            0|  0.00%|                else:
   418|         0|            0|            0|  0.00%|                    # Create a nested list with the child memory
   419|         0|            0|            0|  0.00%|                    if multiprocess:
   420|         0|            0|            0|  0.00%|                        mem_usage = [mem_usage]
   421|         0|            0|            0|  0.00%|                        for chldmem in _get_child_memory(proc):
   422|         0|            0|            0|  0.00%|                            mem_usage.append(chldmem)
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|                    # Append the memory usage to the return value
   425|         0|            0|            0|  0.00%|                    ret.append(mem_usage)
   426|         0|            0|            0|  0.00%|            else:
   427|         0|            0|            0|  0.00%|                ret = max([ret,
   428|         0|            0|            0|  0.00%|                           _get_memory(proc, backend, include_children=include_children)
   429|         0|            0|            0|  0.00%|                           ])
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|            time.sleep(interval)
   432|         0|            0|            0|  0.00%|            # Flush every 50 lines.
   433|         0|            0|            0|  0.00%|            if counter % 50 == 0 and stream is not None:
   434|         0|            0|            0|  0.00%|                stream.flush()
   435|         0|            0|            0|  0.00%|    if stream:
   436|         0|            0|            0|  0.00%|        return None
   437|         0|            0|            0|  0.00%|    return ret
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|# ..
   441|         0|            0|            0|  0.00%|# .. utility functions for line-by-line ..
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|def _find_script(script_name):
   445|         0|            0|            0|  0.00%|    """ Find the script.
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    If the input is not a file, then $PATH will be searched.
   448|         0|            0|            0|  0.00%|    """
   449|         0|            0|            0|  0.00%|    if os.path.isfile(script_name):
   450|         0|            0|            0|  0.00%|        return script_name
   451|         0|            0|            0|  0.00%|    path = os.getenv('PATH', os.defpath).split(os.pathsep)
   452|         0|            0|            0|  0.00%|    for folder in path:
   453|         0|            0|            0|  0.00%|        if not folder:
   454|         0|            0|            0|  0.00%|            continue
   455|         0|            0|            0|  0.00%|        fn = os.path.join(folder, script_name)
   456|         0|            0|            0|  0.00%|        if os.path.isfile(fn):
   457|         0|            0|            0|  0.00%|            return fn
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    sys.stderr.write('Could not find script {0}\n'.format(script_name))
   460|         0|            0|            0|  0.00%|    raise SystemExit(1)
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|class _TimeStamperCM(object):
   464|         0|            0|            0|  0.00%|    """Time-stamping context manager."""
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,
   467|         0|            0|            0|  0.00%|                 include_children=False):
   468|         0|            0|            0|  0.00%|        self.timestamps = timestamps
   469|         0|            0|            0|  0.00%|        self.filename = filename
   470|         0|            0|            0|  0.00%|        self.backend = backend
   471|         0|            0|            0|  0.00%|        self.ts = timestamper
   472|         0|            0|            0|  0.00%|        self.func = func
   473|         0|            0|            0|  0.00%|        self.include_children = include_children
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    def __enter__(self):
   476|         0|            0|            0|  0.00%|        if self.ts is not None:
   477|         0|            0|            0|  0.00%|            self.ts.current_stack_level += 1
   478|         0|            0|            0|  0.00%|            self.ts.stack[self.func].append(self.ts.current_stack_level)
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|        self.timestamps.append(
   481|         0|            0|            0|  0.00%|            _get_memory(os.getpid(), self.backend, timestamps=True,
   482|         0|            0|            0|  0.00%|                        include_children=self.include_children, filename=self.filename))
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|    def __exit__(self, *args):
   485|         0|            0|            0|  0.00%|        if self.ts is not None:
   486|         0|            0|            0|  0.00%|            self.ts.current_stack_level -= 1
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|        self.timestamps.append(
   489|         0|            0|            0|  0.00%|            _get_memory(os.getpid(), self.backend, timestamps=True,
   490|         0|            0|            0|  0.00%|                        include_children=self.include_children, filename=self.filename))
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|class TimeStamper:
   494|         0|            0|            0|  0.00%|    """ A profiler that just records start and end execution times for
   495|         0|            0|            0|  0.00%|    any decorated function.
   496|         0|            0|            0|  0.00%|    """
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|    def __init__(self, backend, include_children=False):
   499|         0|            0|            0|  0.00%|        self.functions = {}
   500|         0|            0|            0|  0.00%|        self.backend = backend
   501|         0|            0|            0|  0.00%|        self.include_children = include_children
   502|         0|            0|            0|  0.00%|        self.current_stack_level = -1
   503|         0|            0|            0|  0.00%|        self.stack = {}
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|    def __call__(self, func=None, precision=None):
   506|         0|            0|            0|  0.00%|        if func is not None:
   507|         0|            0|            0|  0.00%|            if not callable(func):
   508|         0|            0|            0|  0.00%|                raise ValueError("Value must be callable")
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|            self.add_function(func)
   511|         0|            0|            0|  0.00%|            f = self.wrap_function(func)
   512|         0|            0|            0|  0.00%|            f.__module__ = func.__module__
   513|         0|            0|            0|  0.00%|            f.__name__ = func.__name__
   514|         0|            0|            0|  0.00%|            f.__doc__ = func.__doc__
   515|         0|            0|            0|  0.00%|            f.__dict__.update(getattr(func, '__dict__', {}))
   516|         0|            0|            0|  0.00%|            return f
   517|         0|            0|            0|  0.00%|        else:
   518|         0|            0|            0|  0.00%|            def inner_partial(f):
   519|         0|            0|            0|  0.00%|                return self.__call__(f, precision=precision)
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|            return inner_partial
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|    def timestamp(self, name="<block>"):
   524|         0|            0|            0|  0.00%|        """Returns a context manager for timestamping a block of code."""
   525|         0|            0|            0|  0.00%|        # Make a fake function
   526|         0|            0|            0|  0.00%|        func = lambda x: x
   527|         0|            0|            0|  0.00%|        func.__module__ = ""
   528|         0|            0|            0|  0.00%|        func.__name__ = name
   529|         0|            0|            0|  0.00%|        self.add_function(func)
   530|         0|            0|            0|  0.00%|        timestamps = []
   531|         0|            0|            0|  0.00%|        self.functions[func].append(timestamps)
   532|         0|            0|            0|  0.00%|        # A new object is required each time, since there can be several
   533|         0|            0|            0|  0.00%|        # nested context managers.
   534|         0|            0|            0|  0.00%|        try:
   535|         0|            0|            0|  0.00%|            filename = inspect.getsourcefile(func)
   536|         0|            0|            0|  0.00%|        except TypeError:
   537|         0|            0|            0|  0.00%|            filename = '<unknown>'
   538|         0|            0|            0|  0.00%|        return _TimeStamperCM(
   539|         0|            0|            0|  0.00%|            timestamps,
   540|         0|            0|            0|  0.00%|            filename,
   541|         0|            0|            0|  0.00%|            self.backend,
   542|         0|            0|            0|  0.00%|            timestamper=self,
   543|         0|            0|            0|  0.00%|            func=func
   544|         0|            0|            0|  0.00%|        )
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|    def add_function(self, func):
   547|         0|            0|            0|  0.00%|        if func not in self.functions:
   548|         0|            0|            0|  0.00%|            self.functions[func] = []
   549|         0|            0|            0|  0.00%|            self.stack[func] = []
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|    def wrap_function(self, func):
   552|         0|            0|            0|  0.00%|        """ Wrap a function to timestamp it.
   553|         0|            0|            0|  0.00%|        """
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|        def f(*args, **kwds):
   556|         0|            0|            0|  0.00%|            # Start time
   557|         0|            0|            0|  0.00%|            try:
   558|         0|            0|            0|  0.00%|                filename = inspect.getsourcefile(func)
   559|         0|            0|            0|  0.00%|            except TypeError:
   560|         0|            0|            0|  0.00%|                filename = '<unknown>'
   561|         0|            0|            0|  0.00%|            timestamps = [
   562|         0|            0|            0|  0.00%|                _get_memory(os.getpid(), self.backend, timestamps=True,
   563|         0|            0|            0|  0.00%|                            include_children=self.include_children, filename=filename)]
   564|         0|            0|            0|  0.00%|            self.functions[func].append(timestamps)
   565|         0|            0|            0|  0.00%|            try:
   566|         0|            0|            0|  0.00%|                with self.call_on_stack(func, *args, **kwds) as result:
   567|         0|            0|            0|  0.00%|                    return result
   568|         0|            0|            0|  0.00%|            finally:
   569|         0|            0|            0|  0.00%|                # end time
   570|         0|            0|            0|  0.00%|                timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,
   571|         0|            0|            0|  0.00%|                                              include_children=self.include_children,
   572|         0|            0|            0|  0.00%|                                              filename=filename))
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|        return f
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|    @contextmanager
   577|         0|            0|            0|  0.00%|    def call_on_stack(self, func, *args, **kwds):
   578|         0|            0|            0|  0.00%|        self.current_stack_level += 1
   579|         0|            0|            0|  0.00%|        self.stack[func].append(self.current_stack_level)
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|        yield func(*args, **kwds)
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|        self.current_stack_level -= 1
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|    def show_results(self, stream=None):
   586|         0|            0|            0|  0.00%|        if stream is None:
   587|         0|            0|            0|  0.00%|            stream = sys.stdout
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|        for func, timestamps in self.functions.items():
   590|         0|            0|            0|  0.00%|            function_name = "%s.%s" % (func.__module__, func.__name__)
   591|         0|            0|            0|  0.00%|            for ts, level in zip(timestamps, self.stack[func]):
   592|         0|            0|            0|  0.00%|                stream.write("FUNC %s %.4f %.4f %.4f %.4f %d\n" % (
   593|         0|            0|            0|  0.00%|                    (function_name,) + ts[0] + ts[1] + (level,)))
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|class CodeMap(dict):
   597|         1|  6.19888e-06|  6.19888e-06|  0.00%|    def __init__(self, include_children, backend):
   598|         1|  1.57356e-05|  1.57356e-05|  0.00%|        self.include_children = include_children
   599|         1|  6.67572e-06|  6.67572e-06|  0.00%|        self._toplevel = []
   600|         1|  6.67572e-06|  6.67572e-06|  0.00%|        self.backend = backend
   601|         0|            0|            0|  0.00%|
   602|         1|  1.93119e-05|  1.93119e-05|  0.00%|    def add(self, code, toplevel_code=None):
   603|         1|  1.00136e-05|  1.00136e-05|  0.00%|        if code in self:
   604|         0|            0|            0|  0.00%|            return
   605|         0|            0|            0|  0.00%|
   606|         1|  6.91414e-06|  6.91414e-06|  0.00%|        if toplevel_code is None:
   607|         1|  6.19888e-06|  6.19888e-06|  0.00%|            filename = code.co_filename
   608|         1|  1.81198e-05|  1.81198e-05|  0.00%|            if filename.endswith((".pyc", ".pyo")):
   609|         0|            0|            0|  0.00%|                filename = filename[:-1]
   610|         1|  4.12464e-05|  4.12464e-05|  0.00%|            if not os.path.exists(filename):
(call)|         1|  7.05719e-05|  7.05719e-05|  0.00%|# /opt/conda/lib/python3.8/genericpath.py:16 exists
   611|         0|            0|            0|  0.00%|                print('ERROR: Could not find file ' + filename)
   612|         0|            0|            0|  0.00%|                if filename.startswith(("ipython-input", "<ipython-input")):
   613|         0|            0|            0|  0.00%|                    print(
   614|         0|            0|            0|  0.00%|                        "NOTE: %mprun can only be used on functions defined in"
   615|         0|            0|            0|  0.00%|                        " physical files, and not in the IPython environment.")
   616|         0|            0|            0|  0.00%|                return
   617|         0|            0|            0|  0.00%|
   618|         1|  6.91414e-06|  6.91414e-06|  0.00%|            toplevel_code = code
   619|         1|  4.48227e-05|  4.48227e-05|  0.00%|            (sub_lines, start_line) = inspect.getsourcelines(code)
(call)|         1|      4.56473|      4.56473|  3.31%|# /opt/conda/lib/python3.8/inspect.py:970 getsourcelines
   620|         2|  1.50204e-05|  7.51019e-06|  0.00%|            linenos = range(start_line,
   621|         1|  8.34465e-06|  8.34465e-06|  0.00%|                            start_line + len(sub_lines))
   622|         1|  8.10623e-06|  8.10623e-06|  0.00%|            self._toplevel.append((filename, code, linenos))
   623|         1|  9.29832e-06|  9.29832e-06|  0.00%|            self[code] = {}
   624|         0|            0|            0|  0.00%|        else:
   625|         0|            0|            0|  0.00%|            self[code] = self[toplevel_code]
   626|         0|            0|            0|  0.00%|
   627|         1|  0.000143051|  0.000143051|  0.00%|        for subcode in filter(inspect.iscode, code.co_consts):
(call)|        13|  0.000133276|   1.0252e-05|  0.00%|# /opt/conda/lib/python3.8/inspect.py:260 iscode
   628|         0|            0|            0|  0.00%|            self.add(subcode, toplevel_code=toplevel_code)
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|    def trace(self, code, lineno, prev_lineno):
   631|         0|            0|            0|  0.00%|        memory = _get_memory(-1, self.backend, include_children=self.include_children,
   632|         0|            0|            0|  0.00%|                             filename=code.co_filename)
   633|         0|            0|            0|  0.00%|        prev_value = self[code].get(lineno, None)
   634|         0|            0|            0|  0.00%|        previous_memory = prev_value[1] if prev_value else 0
   635|         0|            0|            0|  0.00%|        previous_inc = prev_value[0] if prev_value else 0
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None
   638|         0|            0|            0|  0.00%|        prev_line_memory = prev_line_value[1] if prev_line_value else 0
   639|         0|            0|            0|  0.00%|        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1
   640|         0|            0|            0|  0.00%|        self[code][lineno] = (
   641|         0|            0|            0|  0.00%|            previous_inc + (memory - prev_line_memory),
   642|         0|            0|            0|  0.00%|            max(memory, previous_memory),
   643|         0|            0|            0|  0.00%|            occ_count,
   644|         0|            0|            0|  0.00%|        )
   645|         0|            0|            0|  0.00%|
   646|         1|  1.43051e-05|  1.43051e-05|  0.00%|    def items(self):
   647|         0|            0|            0|  0.00%|        """Iterate on the toplevel code blocks."""
   648|         2|  1.35899e-05|  6.79493e-06|  0.00%|        for (filename, code, linenos) in self._toplevel:
   649|         1|  8.58307e-06|  8.58307e-06|  0.00%|            measures = self[code]
   650|         1|  6.67572e-06|  6.67572e-06|  0.00%|            if not measures:
   651|         0|            0|            0|  0.00%|                continue  # skip if no measurement
   652|       141|  0.000848532|  6.01796e-06|  0.00%|            line_iterator = ((line, measures.get(line)) for line in linenos)
   653|         2|  1.26362e-05|  6.31809e-06|  0.00%|            yield (filename, line_iterator)
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|class LineProfiler(object):
   657|         0|            0|            0|  0.00%|    """ A profiler that records the amount of memory for each line """
   658|         0|            0|            0|  0.00%|
   659|         1|  1.23978e-05|  1.23978e-05|  0.00%|    def __init__(self, **kw):
   660|         1|  1.38283e-05|  1.38283e-05|  0.00%|        include_children = kw.get('include_children', False)
   661|         1|  9.29832e-06|  9.29832e-06|  0.00%|        backend = kw.get('backend', 'psutil')
   662|         2|  4.17233e-05|  2.08616e-05|  0.00%|        self.code_map = CodeMap(
(call)|         1|  3.52859e-05|  3.52859e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:597 __init__
   663|         1|  5.48363e-06|  5.48363e-06|  0.00%|            include_children=include_children, backend=backend)
   664|         1|  5.24521e-06|  5.24521e-06|  0.00%|        self.enable_count = 0
   665|         1|  9.53674e-06|  9.53674e-06|  0.00%|        self.max_mem = kw.get('max_mem', None)
   666|         1|   6.4373e-06|   6.4373e-06|  0.00%|        self.prevlines = []
   667|         1|  3.31402e-05|  3.31402e-05|  0.00%|        self.backend = choose_backend(kw.get('backend', None))
(call)|         1|  0.000239134|  0.000239134|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:1155 choose_backend
   668|         1|  1.35899e-05|  1.35899e-05|  0.00%|        self.prev_lineno = None
   669|         0|            0|            0|  0.00%|
   670|         1|  1.78814e-05|  1.78814e-05|  0.00%|    def __call__(self, func=None, precision=1):
   671|         1|  7.39098e-06|  7.39098e-06|  0.00%|        if func is not None:
   672|         1|  2.16961e-05|  2.16961e-05|  0.00%|            self.add_function(func)
(call)|         1|      4.56531|      4.56531|  3.31%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:685 add_function
   673|         1|  2.21729e-05|  2.21729e-05|  0.00%|            f = self.wrap_function(func)
(call)|         1|  0.000272512|  0.000272512|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:705 wrap_function
   674|         1|  7.15256e-06|  7.15256e-06|  0.00%|            f.__module__ = func.__module__
   675|         1|   6.4373e-06|   6.4373e-06|  0.00%|            f.__name__ = func.__name__
   676|         1|  6.19888e-06|  6.19888e-06|  0.00%|            f.__doc__ = func.__doc__
   677|         1|   1.5974e-05|   1.5974e-05|  0.00%|            f.__dict__.update(getattr(func, '__dict__', {}))
   678|         1|  1.52588e-05|  1.52588e-05|  0.00%|            return f
   679|         0|            0|            0|  0.00%|        else:
   680|         0|            0|            0|  0.00%|            def inner_partial(f):
   681|         0|            0|            0|  0.00%|                return self.__call__(f, precision=precision)
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|            return inner_partial
   684|         0|            0|            0|  0.00%|
   685|         1|  5.96046e-06|  5.96046e-06|  0.00%|    def add_function(self, func):
   686|         0|            0|            0|  0.00%|        """ Record line profiling information for the given Python function.
   687|         0|            0|            0|  0.00%|        """
   688|         1|  5.72205e-06|  5.72205e-06|  0.00%|        try:
   689|         0|            0|            0|  0.00%|            # func_code does not exist in Python3
   690|         1|   6.4373e-06|   6.4373e-06|  0.00%|            code = func.__code__
   691|         0|            0|            0|  0.00%|        except AttributeError:
   692|         0|            0|            0|  0.00%|            warnings.warn("Could not extract a code object for the object %r"
   693|         0|            0|            0|  0.00%|                          % func)
   694|         0|            0|            0|  0.00%|        else:
   695|         1|  2.36034e-05|  2.36034e-05|  0.00%|            self.code_map.add(code)
(call)|         1|      4.56527|      4.56527|  3.31%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:602 add
   696|         0|            0|            0|  0.00%|
   697|         1|  5.96046e-06|  5.96046e-06|  0.00%|    @contextmanager
   698|         0|            0|            0|  0.00%|    def _count_ctxmgr(self):
   699|         1|  1.66893e-05|  1.66893e-05|  0.00%|        self.enable_by_count()
(call)|         1|  6.98566e-05|  6.98566e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:731 enable_by_count
   700|         1|  5.72205e-06|  5.72205e-06|  0.00%|        try:
   701|         1|  5.00679e-06|  5.00679e-06|  0.00%|            yield
   702|         0|            0|            0|  0.00%|        finally:
   703|         0|            0|            0|  0.00%|            self.disable_by_count()
   704|         0|            0|            0|  0.00%|
   705|         1|  9.53674e-06|  9.53674e-06|  0.00%|    def wrap_function(self, func):
   706|         0|            0|            0|  0.00%|        """ Wrap a function to profile it.
   707|         0|            0|            0|  0.00%|        """
   708|         0|            0|            0|  0.00%|
   709|         1|   3.3617e-05|   3.3617e-05|  0.00%|        if iscoroutinefunction(func):
(call)|         1|  0.000216484|  0.000216484|  0.00%|# /opt/conda/lib/python3.8/asyncio/coroutines.py:164 iscoroutinefunction
   710|         0|            0|            0|  0.00%|            @coroutine
   711|         0|            0|            0|  0.00%|            def f(*args, **kwargs):
   712|         0|            0|            0|  0.00%|                with self._count_ctxmgr():
   713|         0|            0|            0|  0.00%|                    yield from func(*args, **kwargs)
   714|         0|            0|            0|  0.00%|        else:
   715|         2|  1.38283e-05|  6.91414e-06|  0.00%|            def f(*args, **kwds):
   716|         1|    4.673e-05|    4.673e-05|  0.00%|                with self._count_ctxmgr():
(call)|         1|  0.000122309|  0.000122309|  0.00%|# /opt/conda/lib/python3.8/contextlib.py:238 helper
(call)|         1|  0.000148773|  0.000148773|  0.00%|# /opt/conda/lib/python3.8/contextlib.py:108 __enter__
   717|         0|            0|            0|  0.00%|                    return func(*args, **kwds)
   718|         0|            0|            0|  0.00%|
   719|         1|  5.96046e-06|  5.96046e-06|  0.00%|        return f
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|    def runctx(self, cmd, globals, locals):
   722|         0|            0|            0|  0.00%|        """ Profile a single executable statement in the given namespaces.
   723|         0|            0|            0|  0.00%|        """
   724|         0|            0|            0|  0.00%|        self.enable_by_count()
   725|         0|            0|            0|  0.00%|        try:
   726|         0|            0|            0|  0.00%|            exec(cmd, globals, locals)
   727|         0|            0|            0|  0.00%|        finally:
   728|         0|            0|            0|  0.00%|            self.disable_by_count()
   729|         0|            0|            0|  0.00%|        return self
   730|         0|            0|            0|  0.00%|
   731|         1|  6.19888e-06|  6.19888e-06|  0.00%|    def enable_by_count(self):
   732|         0|            0|            0|  0.00%|        """ Enable the profiler if it hasn't been enabled before.
   733|         0|            0|            0|  0.00%|        """
   734|         1|   6.4373e-06|   6.4373e-06|  0.00%|        if self.enable_count == 0:
   735|         1|  1.74046e-05|  1.74046e-05|  0.00%|            self.enable()
(call)|         1|   3.3617e-05|   3.3617e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:798 enable
   736|         1|  6.19888e-06|  6.19888e-06|  0.00%|        self.enable_count += 1
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|    def disable_by_count(self):
   739|         0|            0|            0|  0.00%|        """ Disable the profiler if the number of disable requests matches the
   740|         0|            0|            0|  0.00%|        number of enable requests.
   741|         0|            0|            0|  0.00%|        """
   742|         0|            0|            0|  0.00%|        if self.enable_count > 0:
   743|         0|            0|            0|  0.00%|            self.enable_count -= 1
   744|         0|            0|            0|  0.00%|            if self.enable_count == 0:
   745|         0|            0|            0|  0.00%|                self.disable()
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|    def trace_memory_usage(self, frame, event, arg):
   748|         0|            0|            0|  0.00%|        """Callback for sys.settrace"""
   749|         0|            0|            0|  0.00%|        if frame.f_code in self.code_map:
   750|         0|            0|            0|  0.00%|            if event == 'call':
   751|         0|            0|            0|  0.00%|                # "call" event just saves the lineno but not the memory
   752|         0|            0|            0|  0.00%|                self.prevlines.append(frame.f_lineno)
   753|         0|            0|            0|  0.00%|            elif event == 'line':
   754|         0|            0|            0|  0.00%|                # trace needs current line and previous line
   755|         0|            0|            0|  0.00%|                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)
   756|         0|            0|            0|  0.00%|                # saving previous line
   757|         0|            0|            0|  0.00%|                self.prev_lineno = self.prevlines[-1]
   758|         0|            0|            0|  0.00%|                self.prevlines[-1] = frame.f_lineno
   759|         0|            0|            0|  0.00%|            elif event == 'return':
   760|         0|            0|            0|  0.00%|                lineno = self.prevlines.pop()
   761|         0|            0|            0|  0.00%|                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)
   762|         0|            0|            0|  0.00%|                self.prev_lineno = lineno
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|        if self._original_trace_function is not None:
   765|         0|            0|            0|  0.00%|            self._original_trace_function(frame, event, arg)
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|        return self.trace_memory_usage
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|    def trace_max_mem(self, frame, event, arg):
   770|         0|            0|            0|  0.00%|        # run into PDB as soon as memory is higher than MAX_MEM
   771|         0|            0|            0|  0.00%|        if event in ('line', 'return') and frame.f_code in self.code_map:
   772|         0|            0|            0|  0.00%|            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)
   773|         0|            0|            0|  0.00%|            if c >= self.max_mem:
   774|         0|            0|            0|  0.00%|                t = ('Current memory {0:.2f} MiB exceeded the '
   775|         0|            0|            0|  0.00%|                     'maximum of {1:.2f} MiB\n'.format(c, self.max_mem))
   776|         0|            0|            0|  0.00%|                sys.stdout.write(t)
   777|         0|            0|            0|  0.00%|                sys.stdout.write('Stepping into the debugger \n')
   778|         0|            0|            0|  0.00%|                frame.f_lineno -= 2
   779|         0|            0|            0|  0.00%|                p = pdb.Pdb()
   780|         0|            0|            0|  0.00%|                p.quitting = False
   781|         0|            0|            0|  0.00%|                p.stopframe = frame
   782|         0|            0|            0|  0.00%|                p.returnframe = None
   783|         0|            0|            0|  0.00%|                p.stoplineno = frame.f_lineno - 3
   784|         0|            0|            0|  0.00%|                p.botframe = None
   785|         0|            0|            0|  0.00%|                return p.trace_dispatch
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|        if self._original_trace_function is not None:
   788|         0|            0|            0|  0.00%|            (self._original_trace_function)(frame, event, arg)
   789|         0|            0|            0|  0.00%|
   790|         0|            0|            0|  0.00%|        return self.trace_max_mem
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|    def __enter__(self):
   793|         0|            0|            0|  0.00%|        self.enable_by_count()
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|    def __exit__(self, exc_type, exc_val, exc_tb):
   796|         0|            0|            0|  0.00%|        self.disable_by_count()
   797|         0|            0|            0|  0.00%|
   798|         1|  5.96046e-06|  5.96046e-06|  0.00%|    def enable(self):
   799|         1|  1.21593e-05|  1.21593e-05|  0.00%|        self._original_trace_function = sys.gettrace()
   800|         1|  6.19888e-06|  6.19888e-06|  0.00%|        if self.max_mem is not None:
   801|         0|            0|            0|  0.00%|            sys.settrace(self.trace_max_mem)
   802|         0|            0|            0|  0.00%|        else:
   803|         1|  9.29832e-06|  9.29832e-06|  0.00%|            sys.settrace(self.trace_memory_usage)
   804|         0|            0|            0|  0.00%|
   805|         0|            0|            0|  0.00%|    def disable(self):
   806|         0|            0|            0|  0.00%|        sys.settrace(self._original_trace_function)
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|
   809|         1|  1.57356e-05|  1.57356e-05|  0.00%|def show_results(prof, stream=None, precision=1):
   810|         1|   1.0252e-05|   1.0252e-05|  0.00%|    if stream is None:
   811|         1|  8.82149e-06|  8.82149e-06|  0.00%|        stream = sys.stdout
   812|         1|  7.86781e-06|  7.86781e-06|  0.00%|    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'
   813|         0|            0|            0|  0.00%|
   814|         2|  4.72069e-05|  2.36034e-05|  0.00%|    for (filename, lines) in prof.code_map.items():
(call)|         2|   6.4373e-05|  3.21865e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:646 items
   815|         2|  3.43323e-05|  1.71661e-05|  0.00%|        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurences',
   816|         1|  7.62939e-06|  7.62939e-06|  0.00%|                                 'Line Contents')
   817|         0|            0|            0|  0.00%|
   818|         1|  4.17233e-05|  4.17233e-05|  0.00%|        stream.write(u'Filename: ' + filename + '\n\n')
   819|         1|  2.90871e-05|  2.90871e-05|  0.00%|        stream.write(header + u'\n')
   820|         1|  3.62396e-05|  3.62396e-05|  0.00%|        stream.write(u'=' * len(header) + '\n')
   821|         0|            0|            0|  0.00%|
   822|         1|  4.17233e-05|  4.17233e-05|  0.00%|        all_lines = linecache.getlines(filename)
(call)|         1|  4.93526e-05|  4.93526e-05|  0.00%|# /opt/conda/lib/python3.8/linecache.py:37 getlines
   823|         0|            0|            0|  0.00%|
   824|         1|  1.38283e-05|  1.38283e-05|  0.00%|        float_format = u'{0}.{1}f'.format(precision + 4, precision)
   825|         1|  8.34465e-06|  8.34465e-06|  0.00%|        template_mem = u'{0:' + float_format + '} MiB'
   826|        70|   0.00105762|  1.51089e-05|  0.00%|        for (lineno, mem) in lines:
(call)|        70|  0.000839949|  1.19993e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:652 <genexpr>
   827|        69|  0.000327826|  4.75109e-06|  0.00%|            if mem:
   828|        42|  0.000229597|   5.4666e-06|  0.00%|                inc = mem[0]
   829|        42|  0.000204086|   4.8592e-06|  0.00%|                total_mem = mem[1]
   830|        42|   0.00042057|  1.00136e-05|  0.00%|                total_mem = template_mem.format(total_mem)
   831|        42|  0.000220299|  5.24521e-06|  0.00%|                occurences = mem[2]
   832|        42|  0.000360966|  8.59442e-06|  0.00%|                inc = template_mem.format(inc)
   833|         0|            0|            0|  0.00%|            else:
   834|        27|  0.000118256|  4.37984e-06|  0.00%|                total_mem = u''
   835|        27|  0.000119448|  4.42399e-06|  0.00%|                inc = u''
   836|        27|  0.000116587|  4.31803e-06|  0.00%|                occurences = u''
   837|        69|  0.000732183|  1.06114e-05|  0.00%|            tmp = template.format(lineno, total_mem, inc, occurences, all_lines[lineno - 1])
   838|        69|   0.00141668|  2.05316e-05|  0.00%|            stream.write(tmp)
   839|         1|  1.88351e-05|  1.88351e-05|  0.00%|        stream.write(u'\n\n')
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|def _func_exec(stmt, ns):
   843|         0|            0|            0|  0.00%|    # helper for magic_memit, just a function proxy for the exec
   844|         0|            0|            0|  0.00%|    # statement
   845|         0|            0|            0|  0.00%|    exec(stmt, ns)
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|@magics_class
   849|         0|            0|            0|  0.00%|class MemoryProfilerMagics(Magics):
   850|         0|            0|            0|  0.00%|    # A lprun-style %mprun magic for IPython.
   851|         0|            0|            0|  0.00%|    @line_cell_magic
   852|         0|            0|            0|  0.00%|    def mprun(self, parameter_s='', cell=None):
   853|         0|            0|            0|  0.00%|        """ Execute a statement under the line-by-line memory profiler from the
   854|         0|            0|            0|  0.00%|        memory_profiler module.
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|        Usage, in line mode:
   857|         0|            0|            0|  0.00%|          %mprun -f func1 -f func2 <statement>
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|        Usage, in cell mode:
   860|         0|            0|            0|  0.00%|          %%mprun -f func1 -f func2 [statement]
   861|         0|            0|            0|  0.00%|          code...
   862|         0|            0|            0|  0.00%|          code...
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|        In cell mode, the additional code lines are appended to the (possibly
   865|         0|            0|            0|  0.00%|        empty) statement in the first line. Cell mode allows you to easily
   866|         0|            0|            0|  0.00%|        profile multiline blocks without having to put them in a separate
   867|         0|            0|            0|  0.00%|        function.
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|        The given statement (which doesn't require quote marks) is run via the
   870|         0|            0|            0|  0.00%|        LineProfiler. Profiling is enabled for the functions specified by the -f
   871|         0|            0|            0|  0.00%|        options. The statistics will be shown side-by-side with the code through
   872|         0|            0|            0|  0.00%|        the pager once the statement has completed.
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|        Options:
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|        -f <function>: LineProfiler only profiles functions and methods it is told
   877|         0|            0|            0|  0.00%|        to profile.  This option tells the profiler about these functions. Multiple
   878|         0|            0|            0|  0.00%|        -f options may be used. The argument may be any expression that gives
   879|         0|            0|            0|  0.00%|        a Python function or method object. However, one must be careful to avoid
   880|         0|            0|            0|  0.00%|        spaces that may confuse the option parser. Additionally, functions defined
   881|         0|            0|            0|  0.00%|        in the interpreter at the In[] prompt or via %run currently cannot be
   882|         0|            0|            0|  0.00%|        displayed.  Write these functions out to a separate file and import them.
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|        One or more -f options are required to get any useful results.
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|        -T <filename>: dump the text-formatted statistics with the code
   887|         0|            0|            0|  0.00%|        side-by-side out to a text file.
   888|         0|            0|            0|  0.00%|
   889|         0|            0|            0|  0.00%|        -r: return the LineProfiler object after it has completed profiling.
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|        -c: If present, add the memory usage of any children process to the report.
   892|         0|            0|            0|  0.00%|        """
   893|         0|            0|            0|  0.00%|        from io import StringIO
   894|         0|            0|            0|  0.00%|        from memory_profiler import show_results, LineProfiler
   895|         0|            0|            0|  0.00%|
   896|         0|            0|            0|  0.00%|        # Local imports to avoid hard dependency.
   897|         0|            0|            0|  0.00%|        from distutils.version import LooseVersion
   898|         0|            0|            0|  0.00%|        import IPython
   899|         0|            0|            0|  0.00%|        ipython_version = LooseVersion(IPython.__version__)
   900|         0|            0|            0|  0.00%|        if ipython_version < '0.11':
   901|         0|            0|            0|  0.00%|            from IPython.genutils import page
   902|         0|            0|            0|  0.00%|            from IPython.ipstruct import Struct
   903|         0|            0|            0|  0.00%|            from IPython.ipapi import UsageError
   904|         0|            0|            0|  0.00%|        else:
   905|         0|            0|            0|  0.00%|            from IPython.core.page import page
   906|         0|            0|            0|  0.00%|            from IPython.utils.ipstruct import Struct
   907|         0|            0|            0|  0.00%|            from IPython.core.error import UsageError
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|        # Escape quote markers.
   910|         0|            0|            0|  0.00%|        opts_def = Struct(T=[''], f=[])
   911|         0|            0|            0|  0.00%|        parameter_s = parameter_s.replace('"', r'\"').replace("'", r"\'")
   912|         0|            0|            0|  0.00%|        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c',
   913|         0|            0|            0|  0.00%|                                           list_all=True)
   914|         0|            0|            0|  0.00%|        opts.merge(opts_def)
   915|         0|            0|            0|  0.00%|        global_ns = self.shell.user_global_ns
   916|         0|            0|            0|  0.00%|        local_ns = self.shell.user_ns
   917|         0|            0|            0|  0.00%|
   918|         0|            0|            0|  0.00%|        if cell is not None:
   919|         0|            0|            0|  0.00%|            arg_str += '\n' + cell
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|        # Get the requested functions.
   922|         0|            0|            0|  0.00%|        funcs = []
   923|         0|            0|            0|  0.00%|        for name in opts.f:
   924|         0|            0|            0|  0.00%|            try:
   925|         0|            0|            0|  0.00%|                funcs.append(eval(name, global_ns, local_ns))
   926|         0|            0|            0|  0.00%|            except Exception as e:
   927|         0|            0|            0|  0.00%|                raise UsageError('Could not find function %r.\n%s: %s' % (name,
   928|         0|            0|            0|  0.00%|                                                                          e.__class__.__name__,
   929|         0|            0|            0|  0.00%|                                                                          e))
   930|         0|            0|            0|  0.00%|
   931|         0|            0|            0|  0.00%|        include_children = 'c' in opts
   932|         0|            0|            0|  0.00%|        profile = LineProfiler(include_children=include_children)
   933|         0|            0|            0|  0.00%|        for func in funcs:
   934|         0|            0|            0|  0.00%|            profile(func)
   935|         0|            0|            0|  0.00%|
   936|         0|            0|            0|  0.00%|        # Add the profiler to the builtins for @profile.
   937|         0|            0|            0|  0.00%|        if 'profile' in builtins.__dict__:
   938|         0|            0|            0|  0.00%|            had_profile = True
   939|         0|            0|            0|  0.00%|            old_profile = builtins.__dict__['profile']
   940|         0|            0|            0|  0.00%|        else:
   941|         0|            0|            0|  0.00%|            had_profile = False
   942|         0|            0|            0|  0.00%|            old_profile = None
   943|         0|            0|            0|  0.00%|        builtins.__dict__['profile'] = profile
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|        try:
   946|         0|            0|            0|  0.00%|            profile.runctx(arg_str, global_ns, local_ns)
   947|         0|            0|            0|  0.00%|            message = ''
   948|         0|            0|            0|  0.00%|        except SystemExit:
   949|         0|            0|            0|  0.00%|            message = "*** SystemExit exception caught in code being profiled."
   950|         0|            0|            0|  0.00%|        except KeyboardInterrupt:
   951|         0|            0|            0|  0.00%|            message = ("*** KeyboardInterrupt exception caught in code being "
   952|         0|            0|            0|  0.00%|                       "profiled.")
   953|         0|            0|            0|  0.00%|        finally:
   954|         0|            0|            0|  0.00%|            if had_profile:
   955|         0|            0|            0|  0.00%|                builtins.__dict__['profile'] = old_profile
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|        # Trap text output.
   958|         0|            0|            0|  0.00%|        stdout_trap = StringIO()
   959|         0|            0|            0|  0.00%|        show_results(profile, stdout_trap)
   960|         0|            0|            0|  0.00%|        output = stdout_trap.getvalue()
   961|         0|            0|            0|  0.00%|        output = output.rstrip()
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|        if ipython_version < '0.11':
   964|         0|            0|            0|  0.00%|            page(output, screen_lines=self.shell.rc.screen_length)
   965|         0|            0|            0|  0.00%|        else:
   966|         0|            0|            0|  0.00%|            page(output)
   967|         0|            0|            0|  0.00%|        print(message, )
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|        text_file = opts.T[0]
   970|         0|            0|            0|  0.00%|        if text_file:
   971|         0|            0|            0|  0.00%|            with open(text_file, 'w') as pfile:
   972|         0|            0|            0|  0.00%|                pfile.write(output)
   973|         0|            0|            0|  0.00%|            print('\n*** Profile printout saved to text file %s. %s' % (
   974|         0|            0|            0|  0.00%|                text_file,
   975|         0|            0|            0|  0.00%|                message))
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|        return_value = None
   978|         0|            0|            0|  0.00%|        if 'r' in opts:
   979|         0|            0|            0|  0.00%|            return_value = profile
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|        return return_value
   982|         0|            0|            0|  0.00%|
   983|         0|            0|            0|  0.00%|    # a timeit-style %memit magic for IPython
   984|         0|            0|            0|  0.00%|    @line_cell_magic
   985|         0|            0|            0|  0.00%|    def memit(self, line='', cell=None):
   986|         0|            0|            0|  0.00%|        """Measure memory usage of a Python statement
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|        Usage, in line mode:
   989|         0|            0|            0|  0.00%|          %memit [-r<R>t<T>i<I>] statement
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|        Usage, in cell mode:
   992|         0|            0|            0|  0.00%|          %%memit [-r<R>t<T>i<I>] setup_code
   993|         0|            0|            0|  0.00%|          code...
   994|         0|            0|            0|  0.00%|          code...
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|        This function can be used both as a line and cell magic:
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|        - In line mode you can measure a single-line statement (though multiple
   999|         0|            0|            0|  0.00%|          ones can be chained with using semicolons).
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|        - In cell mode, the statement in the first line is used as setup code
  1002|         0|            0|            0|  0.00%|          (executed but not measured) and the body of the cell is measured.
  1003|         0|            0|            0|  0.00%|          The cell body has access to any variables created in the setup code.
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|        Options:
  1006|         0|            0|            0|  0.00%|        -r<R>: repeat the loop iteration <R> times and take the best result.
  1007|         0|            0|            0|  0.00%|        Default: 1
  1008|         0|            0|            0|  0.00%|
  1009|         0|            0|            0|  0.00%|        -t<T>: timeout after <T> seconds. Default: None
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|        -i<I>: Get time information at an interval of I times per second.
  1012|         0|            0|            0|  0.00%|            Defaults to 0.1 so that there is ten measurements per second.
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|        -c: If present, add the memory usage of any children process to the report.
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|        -o: If present, return a object containing memit run details
  1017|         0|            0|            0|  0.00%|
  1018|         0|            0|            0|  0.00%|        -q: If present, be quiet and do not output a result.
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|        Examples
  1021|         0|            0|            0|  0.00%|        --------
  1022|         0|            0|            0|  0.00%|        ::
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|          In [1]: %memit range(10000)
  1025|         0|            0|            0|  0.00%|          peak memory: 21.42 MiB, increment: 0.41 MiB
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|          In [2]: %memit range(1000000)
  1028|         0|            0|            0|  0.00%|          peak memory: 52.10 MiB, increment: 31.08 MiB
  1029|         0|            0|            0|  0.00%|
  1030|         0|            0|            0|  0.00%|          In [3]: %%memit l=range(1000000)
  1031|         0|            0|            0|  0.00%|             ...: len(l)
  1032|         0|            0|            0|  0.00%|             ...:
  1033|         0|            0|            0|  0.00%|          peak memory: 52.14 MiB, increment: 0.08 MiB
  1034|         0|            0|            0|  0.00%|
  1035|         0|            0|            0|  0.00%|        """
  1036|         0|            0|            0|  0.00%|        from memory_profiler import memory_usage, _func_exec
  1037|         0|            0|            0|  0.00%|        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False,
  1038|         0|            0|            0|  0.00%|                                        strict=False)
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|        if cell is None:
  1041|         0|            0|            0|  0.00%|            setup = 'pass'
  1042|         0|            0|            0|  0.00%|        else:
  1043|         0|            0|            0|  0.00%|            setup = stmt
  1044|         0|            0|            0|  0.00%|            stmt = cell
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|        repeat = int(getattr(opts, 'r', 1))
  1047|         0|            0|            0|  0.00%|        if repeat < 1:
  1048|         0|            0|            0|  0.00%|            repeat == 1
  1049|         0|            0|            0|  0.00%|        timeout = int(getattr(opts, 't', 0))
  1050|         0|            0|            0|  0.00%|        if timeout <= 0:
  1051|         0|            0|            0|  0.00%|            timeout = None
  1052|         0|            0|            0|  0.00%|        interval = float(getattr(opts, 'i', 0.1))
  1053|         0|            0|            0|  0.00%|        include_children = 'c' in opts
  1054|         0|            0|            0|  0.00%|        return_result = 'o' in opts
  1055|         0|            0|            0|  0.00%|        quiet = 'q' in opts
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|        # I've noticed we get less noisier measurements if we run
  1058|         0|            0|            0|  0.00%|        # a garbage collection first
  1059|         0|            0|            0|  0.00%|        import gc
  1060|         0|            0|            0|  0.00%|        gc.collect()
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|        _func_exec(setup, self.shell.user_ns)
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|        mem_usage = []
  1065|         0|            0|            0|  0.00%|        counter = 0
  1066|         0|            0|            0|  0.00%|        baseline = memory_usage()[0]
  1067|         0|            0|            0|  0.00%|        while counter < repeat:
  1068|         0|            0|            0|  0.00%|            counter += 1
  1069|         0|            0|            0|  0.00%|            tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),
  1070|         0|            0|            0|  0.00%|                               timeout=timeout, interval=interval,
  1071|         0|            0|            0|  0.00%|                               max_usage=True,
  1072|         0|            0|            0|  0.00%|                               include_children=include_children)
  1073|         0|            0|            0|  0.00%|            mem_usage.append(tmp)
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|        result = MemitResult(mem_usage, baseline, repeat, timeout, interval,
  1076|         0|            0|            0|  0.00%|                             include_children)
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|        if not quiet:
  1079|         0|            0|            0|  0.00%|            if mem_usage:
  1080|         0|            0|            0|  0.00%|                print(result)
  1081|         0|            0|            0|  0.00%|            else:
  1082|         0|            0|            0|  0.00%|                print('ERROR: could not read memory usage, try with a '
  1083|         0|            0|            0|  0.00%|                      'lower interval or more iterations')
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|        if return_result:
  1086|         0|            0|            0|  0.00%|            return result
  1087|         0|            0|            0|  0.00%|
  1088|         0|            0|            0|  0.00%|    @classmethod
  1089|         0|            0|            0|  0.00%|    def register_magics(cls, ip):
  1090|         0|            0|            0|  0.00%|        from distutils.version import LooseVersion
  1091|         0|            0|            0|  0.00%|        import IPython
  1092|         0|            0|            0|  0.00%|        ipython_version = LooseVersion(IPython.__version__)
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|        if ipython_version < '0.13':
  1095|         0|            0|            0|  0.00%|            try:
  1096|         0|            0|            0|  0.00%|                _register_magic = ip.define_magic
  1097|         0|            0|            0|  0.00%|            except AttributeError:  # ipython 0.10
  1098|         0|            0|            0|  0.00%|                _register_magic = ip.expose_magic
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|            _register_magic('mprun', cls.mprun.__func__)
  1101|         0|            0|            0|  0.00%|            _register_magic('memit', cls.memit.__func__)
  1102|         0|            0|            0|  0.00%|        else:
  1103|         0|            0|            0|  0.00%|            ip.register_magics(cls)
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|# commenting out due to failures with some versions of IPython
  1107|         0|            0|            0|  0.00%|# see https://github.com/fabianp/memory_profiler/issues/106
  1108|         0|            0|            0|  0.00%|# # Ensuring old interface of magics expose for IPython 0.10
  1109|         0|            0|            0|  0.00%|# magic_mprun = MemoryProfilerMagics().mprun.__func__
  1110|         0|            0|            0|  0.00%|# magic_memit = MemoryProfilerMagics().memit.__func__
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|def load_ipython_extension(ip):
  1114|         0|            0|            0|  0.00%|    """This is called to load the module as an IPython extension."""
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|    MemoryProfilerMagics.register_magics(ip)
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|def profile(func=None, stream=None, precision=1, backend='psutil'):
  1120|         0|            0|            0|  0.00%|    """
  1121|         0|            0|            0|  0.00%|    Decorator that will run the function and print a line-by-line profile
  1122|         0|            0|            0|  0.00%|    """
  1123|         0|            0|            0|  0.00%|    backend = choose_backend(backend)
  1124|         0|            0|            0|  0.00%|    if backend == 'tracemalloc' and has_tracemalloc:
  1125|         0|            0|            0|  0.00%|        if not tracemalloc.is_tracing():
  1126|         0|            0|            0|  0.00%|            tracemalloc.start()
  1127|         0|            0|            0|  0.00%|    if func is not None:
  1128|         0|            0|            0|  0.00%|        get_prof = partial(LineProfiler, backend=backend)
  1129|         0|            0|            0|  0.00%|        show_results_bound = partial(
  1130|         0|            0|            0|  0.00%|            show_results, stream=stream, precision=precision
  1131|         0|            0|            0|  0.00%|        )
  1132|         0|            0|            0|  0.00%|        if iscoroutinefunction(func):
  1133|         0|            0|            0|  0.00%|            @coroutine
  1134|         0|            0|            0|  0.00%|            def wrapper(*args, **kwargs):
  1135|         0|            0|            0|  0.00%|                prof = get_prof()
  1136|         0|            0|            0|  0.00%|                val = yield from prof(func)(*args, **kwargs)
  1137|         0|            0|            0|  0.00%|                show_results_bound(prof)
  1138|         0|            0|            0|  0.00%|                return val
  1139|         0|            0|            0|  0.00%|        else:
  1140|         1|  4.43459e-05|  4.43459e-05|  0.00%|            def wrapper(*args, **kwargs):
  1141|         1|  0.000114202|  0.000114202|  0.00%|                prof = get_prof()
(call)|         1|    0.0004251|    0.0004251|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:659 __init__
  1142|         0|            0|            0|  0.00%|                val = prof(func)(*args, **kwargs)
(call)|         1|       4.5657|       4.5657|  3.31%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:670 __call__
(call)|         1|  1.52588e-05|  1.52588e-05|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:715 f
  1143|         1|  3.45707e-05|  3.45707e-05|  0.00%|                show_results_bound(prof)
(call)|         1|   0.00659943|   0.00659943|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:809 show_results
  1144|         1|  6.91414e-06|  6.91414e-06|  0.00%|                return val
  1145|         0|            0|            0|  0.00%|
  1146|         0|            0|            0|  0.00%|        return wrapper
  1147|         0|            0|            0|  0.00%|    else:
  1148|         0|            0|            0|  0.00%|        def inner_wrapper(f):
  1149|         0|            0|            0|  0.00%|            return profile(f, stream=stream, precision=precision,
  1150|         0|            0|            0|  0.00%|                           backend=backend)
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|        return inner_wrapper
  1153|         0|            0|            0|  0.00%|
  1154|         0|            0|            0|  0.00%|
  1155|         1|  1.97887e-05|  1.97887e-05|  0.00%|def choose_backend(new_backend=None):
  1156|         0|            0|            0|  0.00%|    """
  1157|         0|            0|            0|  0.00%|    Function that tries to setup backend, chosen by user, and if failed,
  1158|         0|            0|            0|  0.00%|    setup one of the allowable backends
  1159|         0|            0|            0|  0.00%|    """
  1160|         0|            0|            0|  0.00%|
  1161|         1|  1.54972e-05|  1.54972e-05|  0.00%|    _backend = 'no_backend'
  1162|         1|  1.21593e-05|  1.21593e-05|  0.00%|    all_backends = [
  1163|         1|  6.91414e-06|  6.91414e-06|  0.00%|        ('psutil', True),
  1164|         1|  1.28746e-05|  1.28746e-05|  0.00%|        ('posix', os.name == 'posix'),
  1165|         1|  1.19209e-05|  1.19209e-05|  0.00%|        ('tracemalloc', has_tracemalloc),
  1166|         0|            0|            0|  0.00%|    ]
  1167|         9|  9.08375e-05|  1.00931e-05|  0.00%|    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))
(call)|         4|  3.95775e-05|  9.89437e-06|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:1167 <genexpr>
  1168|         0|            0|            0|  0.00%|
  1169|         1|  5.96046e-06|  5.96046e-06|  0.00%|    if new_backend is not None:
  1170|         1|   2.3365e-05|   2.3365e-05|  0.00%|        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))
  1171|         0|            0|            0|  0.00%|
  1172|         1|  9.29832e-06|  9.29832e-06|  0.00%|    for n_backend, is_available in all_backends:
  1173|         1|   6.4373e-06|   6.4373e-06|  0.00%|        if is_available:
  1174|         1|  6.19888e-06|  6.19888e-06|  0.00%|            _backend = n_backend
  1175|         1|  5.96046e-06|  5.96046e-06|  0.00%|            break
  1176|         1|  5.96046e-06|  5.96046e-06|  0.00%|    if _backend != new_backend and new_backend is not None:
  1177|         0|            0|            0|  0.00%|        warnings.warn('{0} can not be used, {1} used instead'.format(
  1178|         0|            0|            0|  0.00%|            new_backend, _backend))
  1179|         1|  5.96046e-06|  5.96046e-06|  0.00%|    return _backend
  1180|         0|            0|            0|  0.00%|
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|# Insert in the built-ins to have profile
  1183|         0|            0|            0|  0.00%|# globally defined (global variables is not enough
  1184|         0|            0|            0|  0.00%|# for all cases, e.g. a script that imports another
  1185|         0|            0|            0|  0.00%|# script where @profile is used)
  1186|         0|            0|            0|  0.00%|def exec_with_profiler(filename, profiler, backend, passed_args=[]):
  1187|         0|            0|            0|  0.00%|    from runpy import run_module
  1188|         0|            0|            0|  0.00%|    builtins.__dict__['profile'] = profiler
  1189|         0|            0|            0|  0.00%|    ns = dict(_CLEAN_GLOBALS,
  1190|         0|            0|            0|  0.00%|              profile=profiler,
  1191|         0|            0|            0|  0.00%|             # Make sure the __file__ variable is usable
  1192|         0|            0|            0|  0.00%|             # by the script we're profiling
  1193|         0|            0|            0|  0.00%|              __file__=filename)
  1194|         0|            0|            0|  0.00%|    # Make sure the script's directory in on sys.path
  1195|         0|            0|            0|  0.00%|    # credit to line_profiler
  1196|         0|            0|            0|  0.00%|    sys.path.insert(0, os.path.dirname(script_filename))
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|    _backend = choose_backend(backend)
  1199|         0|            0|            0|  0.00%|    sys.argv = [filename] + passed_args
  1200|         0|            0|            0|  0.00%|    try:
  1201|         0|            0|            0|  0.00%|        if _backend == 'tracemalloc' and has_tracemalloc:
  1202|         0|            0|            0|  0.00%|            tracemalloc.start()
  1203|         0|            0|            0|  0.00%|        with open(filename) as f:
  1204|         0|            0|            0|  0.00%|            exec(compile(f.read(), filename, 'exec'), ns, ns)
  1205|         0|            0|            0|  0.00%|    finally:
  1206|         0|            0|            0|  0.00%|        if has_tracemalloc and tracemalloc.is_tracing():
  1207|         0|            0|            0|  0.00%|            tracemalloc.stop()
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|def run_module_with_profiler(module, profiler, backend, passed_args=[]):
  1211|         0|            0|            0|  0.00%|    from runpy import run_module
  1212|         0|            0|            0|  0.00%|    builtins.__dict__['profile'] = profiler
  1213|         0|            0|            0|  0.00%|    ns = dict(_CLEAN_GLOBALS, profile=profiler)
  1214|         0|            0|            0|  0.00%|    _backend = choose_backend(backend)
  1215|         0|            0|            0|  0.00%|    sys.argv = [module] + passed_args
  1216|         0|            0|            0|  0.00%|    if _backend == 'tracemalloc' and has_tracemalloc:
  1217|         0|            0|            0|  0.00%|        tracemalloc.start()
  1218|         0|            0|            0|  0.00%|    try:
  1219|         0|            0|            0|  0.00%|        run_module(module, run_name="__main__", init_globals=ns)
  1220|         0|            0|            0|  0.00%|    finally:
  1221|         0|            0|            0|  0.00%|        if has_tracemalloc and tracemalloc.is_tracing():
  1222|         0|            0|            0|  0.00%|            tracemalloc.stop()
  1223|         0|            0|            0|  0.00%|
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|class LogFile(object):
  1226|         0|            0|            0|  0.00%|    """File-like object to log text using the `logging` module and the log
  1227|         0|            0|            0|  0.00%|    report can be customised."""
  1228|         0|            0|            0|  0.00%|
  1229|         0|            0|            0|  0.00%|    def __init__(self, name=None, reportIncrementFlag=False):
  1230|         0|            0|            0|  0.00%|        """
  1231|         0|            0|            0|  0.00%|        :param name: name of the logger module
  1232|         0|            0|            0|  0.00%|               reportIncrementFlag: This must be set to True if only the steps
  1233|         0|            0|            0|  0.00%|               with memory increments are to be reported
  1234|         0|            0|            0|  0.00%|
  1235|         0|            0|            0|  0.00%|        :type self: object
  1236|         0|            0|            0|  0.00%|              name: string
  1237|         0|            0|            0|  0.00%|              reportIncrementFlag: bool
  1238|         0|            0|            0|  0.00%|        """
  1239|         0|            0|            0|  0.00%|        self.logger = logging.getLogger(name)
  1240|         0|            0|            0|  0.00%|        self.reportIncrementFlag = reportIncrementFlag
  1241|         0|            0|            0|  0.00%|
  1242|         0|            0|            0|  0.00%|    def write(self, msg, level=logging.INFO):
  1243|         0|            0|            0|  0.00%|        if self.reportIncrementFlag:
  1244|         0|            0|            0|  0.00%|            if "MiB" in msg and float(msg.split("MiB")[1].strip()) > 0:
  1245|         0|            0|            0|  0.00%|                self.logger.log(level, msg)
  1246|         0|            0|            0|  0.00%|            elif msg.__contains__("Filename:") or msg.__contains__(
  1247|         0|            0|            0|  0.00%|                    "Line Contents"):
  1248|         0|            0|            0|  0.00%|                self.logger.log(level, msg)
  1249|         0|            0|            0|  0.00%|        else:
  1250|         0|            0|            0|  0.00%|            self.logger.log(level, msg)
  1251|         0|            0|            0|  0.00%|
  1252|         0|            0|            0|  0.00%|    def flush(self):
  1253|         0|            0|            0|  0.00%|        for handler in self.logger.handlers:
  1254|         0|            0|            0|  0.00%|            handler.flush()
  1255|         0|            0|            0|  0.00%|
  1256|         0|            0|            0|  0.00%|
  1257|         0|            0|            0|  0.00%|if __name__ == '__main__':
  1258|         0|            0|            0|  0.00%|    from argparse import ArgumentParser, REMAINDER
  1259|         0|            0|            0|  0.00%|
  1260|         0|            0|            0|  0.00%|    parser = ArgumentParser(usage=_CMD_USAGE)
  1261|         0|            0|            0|  0.00%|    parser.add_argument('--version', action='version', version=__version__)
  1262|         0|            0|            0|  0.00%|    parser.add_argument(
  1263|         0|            0|            0|  0.00%|        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',
  1264|         0|            0|            0|  0.00%|        type=float, action='store',
  1265|         0|            0|            0|  0.00%|        help='step into the debugger when memory exceeds MAXMEM')
  1266|         0|            0|            0|  0.00%|    parser.add_argument(
  1267|         0|            0|            0|  0.00%|        '--precision', dest='precision', type=int,
  1268|         0|            0|            0|  0.00%|        action='store', default=3,
  1269|         0|            0|            0|  0.00%|        help='precision of memory output in number of significant digits')
  1270|         0|            0|            0|  0.00%|    parser.add_argument('-o', dest='out_filename', type=str,
  1271|         0|            0|            0|  0.00%|        action='store', default=None,
  1272|         0|            0|            0|  0.00%|        help='path to a file where results will be written')
  1273|         0|            0|            0|  0.00%|    parser.add_argument('--timestamp', dest='timestamp', default=False,
  1274|         0|            0|            0|  0.00%|        action='store_true',
  1275|         0|            0|            0|  0.00%|        help='''print timestamp instead of memory measurement for
  1276|         0|            0|            0|  0.00%|        decorated functions''')
  1277|         0|            0|            0|  0.00%|    parser.add_argument('--include-children', dest='include_children',
  1278|         0|            0|            0|  0.00%|        default=False, action='store_true',
  1279|         0|            0|            0|  0.00%|        help='also include memory used by child processes')
  1280|         0|            0|            0|  0.00%|    parser.add_argument('--backend', dest='backend', type=str, action='store',
  1281|         0|            0|            0|  0.00%|        choices=['tracemalloc', 'psutil', 'posix'], default='psutil',
  1282|         0|            0|            0|  0.00%|        help='backend using for getting memory info '
  1283|         0|            0|            0|  0.00%|             '(one of the {tracemalloc, psutil, posix})')
  1284|         0|            0|            0|  0.00%|    parser.add_argument("program", nargs=REMAINDER,
  1285|         0|            0|            0|  0.00%|        help='python script or module followed by command line arguements to run')
  1286|         0|            0|            0|  0.00%|    args = parser.parse_args()
  1287|         0|            0|            0|  0.00%|
  1288|         0|            0|            0|  0.00%|    if len(args.program) == 0:
  1289|         0|            0|            0|  0.00%|        print("A program to run must be provided. Use -h for help")
  1290|         0|            0|            0|  0.00%|        sys.exit(1)
  1291|         0|            0|            0|  0.00%|
  1292|         0|            0|            0|  0.00%|    target = args.program[0]
  1293|         0|            0|            0|  0.00%|    script_args = args.program[1:]
  1294|         0|            0|            0|  0.00%|    _backend = choose_backend(args.backend)
  1295|         0|            0|            0|  0.00%|    if args.timestamp:
  1296|         0|            0|            0|  0.00%|        prof = TimeStamper(_backend, include_children=args.include_children)
  1297|         0|            0|            0|  0.00%|    else:
  1298|         0|            0|            0|  0.00%|        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    try:
  1301|         0|            0|            0|  0.00%|        if args.program[0].endswith('.py'):
  1302|         0|            0|            0|  0.00%|            script_filename = _find_script(args.program[0])
  1303|         0|            0|            0|  0.00%|            exec_with_profiler(script_filename, prof, args.backend, script_args)
  1304|         0|            0|            0|  0.00%|        else:
  1305|         0|            0|            0|  0.00%|            run_module_with_profiler(target, prof, args.backend, script_args)
  1306|         0|            0|            0|  0.00%|    finally:
  1307|         0|            0|            0|  0.00%|        if args.out_filename is not None:
  1308|         0|            0|            0|  0.00%|            out_file = open(args.out_filename, "a")
  1309|         0|            0|            0|  0.00%|        else:
  1310|         0|            0|            0|  0.00%|            out_file = sys.stdout
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|        if args.timestamp:
  1313|         0|            0|            0|  0.00%|            prof.show_results(stream=out_file)
  1314|         0|            0|            0|  0.00%|        else:
  1315|         0|            0|            0|  0.00%|            show_results(prof, precision=args.precision, stream=out_file)
File: <string>
File duration: 0.00558972s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|       952|   0.00558972|  5.87156e-06|  0.00%|
File: /opt/conda/lib/python3.8/enum.py
File duration: 0.00314093s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import sys
     2|         0|            0|            0|  0.00%|from types import MappingProxyType, DynamicClassAttribute
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|__all__ = [
     6|         0|            0|            0|  0.00%|        'EnumMeta',
     7|         0|            0|            0|  0.00%|        'Enum', 'IntEnum', 'Flag', 'IntFlag',
     8|         0|            0|            0|  0.00%|        'auto', 'unique',
     9|         0|            0|            0|  0.00%|        ]
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|def _is_descriptor(obj):
    13|         0|            0|            0|  0.00%|    """
    14|         0|            0|            0|  0.00%|    Returns True if obj is a descriptor, False otherwise.
    15|         0|            0|            0|  0.00%|    """
    16|         0|            0|            0|  0.00%|    return (
    17|         0|            0|            0|  0.00%|            hasattr(obj, '__get__') or
    18|         0|            0|            0|  0.00%|            hasattr(obj, '__set__') or
    19|         0|            0|            0|  0.00%|            hasattr(obj, '__delete__')
    20|         0|            0|            0|  0.00%|            )
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|def _is_dunder(name):
    23|         0|            0|            0|  0.00%|    """
    24|         0|            0|            0|  0.00%|    Returns True if a __dunder__ name, False otherwise.
    25|         0|            0|            0|  0.00%|    """
    26|         0|            0|            0|  0.00%|    return (
    27|         0|            0|            0|  0.00%|            len(name) > 4 and
    28|         0|            0|            0|  0.00%|            name[:2] == name[-2:] == '__' and
    29|         0|            0|            0|  0.00%|            name[2] != '_' and
    30|         0|            0|            0|  0.00%|            name[-3] != '_'
    31|         0|            0|            0|  0.00%|            )
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|def _is_sunder(name):
    34|         0|            0|            0|  0.00%|    """
    35|         0|            0|            0|  0.00%|    Returns True if a _sunder_ name, False otherwise.
    36|         0|            0|            0|  0.00%|    """
    37|         0|            0|            0|  0.00%|    return (
    38|         0|            0|            0|  0.00%|            len(name) > 2 and
    39|         0|            0|            0|  0.00%|            name[0] == name[-1] == '_' and
    40|         0|            0|            0|  0.00%|            name[1:2] != '_' and
    41|         0|            0|            0|  0.00%|            name[-2:-1] != '_'
    42|         0|            0|            0|  0.00%|            )
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|def _make_class_unpicklable(cls):
    45|         0|            0|            0|  0.00%|    """
    46|         0|            0|            0|  0.00%|    Make the given class un-picklable.
    47|         0|            0|            0|  0.00%|    """
    48|         0|            0|            0|  0.00%|    def _break_on_call_reduce(self, proto):
    49|         0|            0|            0|  0.00%|        raise TypeError('%r cannot be pickled' % self)
    50|         0|            0|            0|  0.00%|    cls.__reduce_ex__ = _break_on_call_reduce
    51|         0|            0|            0|  0.00%|    cls.__module__ = '<unknown>'
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|_auto_null = object()
    54|         0|            0|            0|  0.00%|class auto:
    55|         0|            0|            0|  0.00%|    """
    56|         0|            0|            0|  0.00%|    Instances are replaced with an appropriate value in Enum class suites.
    57|         0|            0|            0|  0.00%|    """
    58|         0|            0|            0|  0.00%|    value = _auto_null
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|class _EnumDict(dict):
    62|         0|            0|            0|  0.00%|    """
    63|         0|            0|            0|  0.00%|    Track enum member order and ensure member names are not reused.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    EnumMeta will use the names found in self._member_names as the
    66|         0|            0|            0|  0.00%|    enumeration member names.
    67|         0|            0|            0|  0.00%|    """
    68|         0|            0|            0|  0.00%|    def __init__(self):
    69|         0|            0|            0|  0.00%|        super().__init__()
    70|         0|            0|            0|  0.00%|        self._member_names = []
    71|         0|            0|            0|  0.00%|        self._last_values = []
    72|         0|            0|            0|  0.00%|        self._ignore = []
    73|         0|            0|            0|  0.00%|        self._auto_called = False
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    def __setitem__(self, key, value):
    76|         0|            0|            0|  0.00%|        """
    77|         0|            0|            0|  0.00%|        Changes anything not dundered or not a descriptor.
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|        If an enum member name is used twice, an error is raised; duplicate
    80|         0|            0|            0|  0.00%|        values are not checked for.
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|        Single underscore (sunder) names are reserved.
    83|         0|            0|            0|  0.00%|        """
    84|         0|            0|            0|  0.00%|        if _is_sunder(key):
    85|         0|            0|            0|  0.00%|            if key not in (
    86|         0|            0|            0|  0.00%|                    '_order_', '_create_pseudo_member_',
    87|         0|            0|            0|  0.00%|                    '_generate_next_value_', '_missing_', '_ignore_',
    88|         0|            0|            0|  0.00%|                    ):
    89|         0|            0|            0|  0.00%|                raise ValueError('_names_ are reserved for future Enum use')
    90|         0|            0|            0|  0.00%|            if key == '_generate_next_value_':
    91|         0|            0|            0|  0.00%|                # check if members already defined as auto()
    92|         0|            0|            0|  0.00%|                if self._auto_called:
    93|         0|            0|            0|  0.00%|                    raise TypeError("_generate_next_value_ must be defined before members")
    94|         0|            0|            0|  0.00%|                setattr(self, '_generate_next_value', value)
    95|         0|            0|            0|  0.00%|            elif key == '_ignore_':
    96|         0|            0|            0|  0.00%|                if isinstance(value, str):
    97|         0|            0|            0|  0.00%|                    value = value.replace(',',' ').split()
    98|         0|            0|            0|  0.00%|                else:
    99|         0|            0|            0|  0.00%|                    value = list(value)
   100|         0|            0|            0|  0.00%|                self._ignore = value
   101|         0|            0|            0|  0.00%|                already = set(value) & set(self._member_names)
   102|         0|            0|            0|  0.00%|                if already:
   103|         0|            0|            0|  0.00%|                    raise ValueError(
   104|         0|            0|            0|  0.00%|                            '_ignore_ cannot specify already set names: %r'
   105|         0|            0|            0|  0.00%|                            % (already, )
   106|         0|            0|            0|  0.00%|                            )
   107|         0|            0|            0|  0.00%|        elif _is_dunder(key):
   108|         0|            0|            0|  0.00%|            if key == '__order__':
   109|         0|            0|            0|  0.00%|                key = '_order_'
   110|         0|            0|            0|  0.00%|        elif key in self._member_names:
   111|         0|            0|            0|  0.00%|            # descriptor overwriting an enum?
   112|         0|            0|            0|  0.00%|            raise TypeError('Attempted to reuse key: %r' % key)
   113|         0|            0|            0|  0.00%|        elif key in self._ignore:
   114|         0|            0|            0|  0.00%|            pass
   115|         0|            0|            0|  0.00%|        elif not _is_descriptor(value):
   116|         0|            0|            0|  0.00%|            if key in self:
   117|         0|            0|            0|  0.00%|                # enum overwriting a descriptor?
   118|         0|            0|            0|  0.00%|                raise TypeError('%r already defined as: %r' % (key, self[key]))
   119|         0|            0|            0|  0.00%|            if isinstance(value, auto):
   120|         0|            0|            0|  0.00%|                if value.value == _auto_null:
   121|         0|            0|            0|  0.00%|                    value.value = self._generate_next_value(
   122|         0|            0|            0|  0.00%|                            key,
   123|         0|            0|            0|  0.00%|                            1,
   124|         0|            0|            0|  0.00%|                            len(self._member_names),
   125|         0|            0|            0|  0.00%|                            self._last_values[:],
   126|         0|            0|            0|  0.00%|                            )
   127|         0|            0|            0|  0.00%|                    self._auto_called = True
   128|         0|            0|            0|  0.00%|                value = value.value
   129|         0|            0|            0|  0.00%|            self._member_names.append(key)
   130|         0|            0|            0|  0.00%|            self._last_values.append(value)
   131|         0|            0|            0|  0.00%|        super().__setitem__(key, value)
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|# Dummy value for Enum as EnumMeta explicitly checks for it, but of course
   135|         0|            0|            0|  0.00%|# until EnumMeta finishes running the first time the Enum class doesn't exist.
   136|         0|            0|            0|  0.00%|# This is also why there are checks in EnumMeta like `if Enum is not None`
   137|         0|            0|            0|  0.00%|Enum = None
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|class EnumMeta(type):
   140|         0|            0|            0|  0.00%|    """
   141|         0|            0|            0|  0.00%|    Metaclass for Enum
   142|         0|            0|            0|  0.00%|    """
   143|         0|            0|            0|  0.00%|    @classmethod
   144|         0|            0|            0|  0.00%|    def __prepare__(metacls, cls, bases):
   145|         0|            0|            0|  0.00%|        # check that previous enum members do not exist
   146|         0|            0|            0|  0.00%|        metacls._check_for_existing_members(cls, bases)
   147|         0|            0|            0|  0.00%|        # create the namespace dict
   148|         0|            0|            0|  0.00%|        enum_dict = _EnumDict()
   149|         0|            0|            0|  0.00%|        # inherit previous flags and _generate_next_value_ function
   150|         0|            0|            0|  0.00%|        member_type, first_enum = metacls._get_mixins_(cls, bases)
   151|         0|            0|            0|  0.00%|        if first_enum is not None:
   152|         0|            0|            0|  0.00%|            enum_dict['_generate_next_value_'] = getattr(
   153|         0|            0|            0|  0.00%|                    first_enum, '_generate_next_value_', None,
   154|         0|            0|            0|  0.00%|                    )
   155|         0|            0|            0|  0.00%|        return enum_dict
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    def __new__(metacls, cls, bases, classdict):
   158|         0|            0|            0|  0.00%|        # an Enum class is final once enumeration items have been defined; it
   159|         0|            0|            0|  0.00%|        # cannot be mixed with other types (int, float, etc.) if it has an
   160|         0|            0|            0|  0.00%|        # inherited __new__ unless a new __new__ is defined (or the resulting
   161|         0|            0|            0|  0.00%|        # class will fail).
   162|         0|            0|            0|  0.00%|        #
   163|         0|            0|            0|  0.00%|        # remove any keys listed in _ignore_
   164|         0|            0|            0|  0.00%|        classdict.setdefault('_ignore_', []).append('_ignore_')
   165|         0|            0|            0|  0.00%|        ignore = classdict['_ignore_']
   166|         0|            0|            0|  0.00%|        for key in ignore:
   167|         0|            0|            0|  0.00%|            classdict.pop(key, None)
   168|         0|            0|            0|  0.00%|        member_type, first_enum = metacls._get_mixins_(cls, bases)
   169|         0|            0|            0|  0.00%|        __new__, save_new, use_args = metacls._find_new_(
   170|         0|            0|            0|  0.00%|                classdict, member_type, first_enum,
   171|         0|            0|            0|  0.00%|                )
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        # save enum items into separate mapping so they don't get baked into
   174|         0|            0|            0|  0.00%|        # the new class
   175|         0|            0|            0|  0.00%|        enum_members = {k: classdict[k] for k in classdict._member_names}
   176|         0|            0|            0|  0.00%|        for name in classdict._member_names:
   177|         0|            0|            0|  0.00%|            del classdict[name]
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|        # adjust the sunders
   180|         0|            0|            0|  0.00%|        _order_ = classdict.pop('_order_', None)
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        # check for illegal enum names (any others?)
   183|         0|            0|            0|  0.00%|        invalid_names = set(enum_members) & {'mro', ''}
   184|         0|            0|            0|  0.00%|        if invalid_names:
   185|         0|            0|            0|  0.00%|            raise ValueError('Invalid enum member name: {0}'.format(
   186|         0|            0|            0|  0.00%|                ','.join(invalid_names)))
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|        # create a default docstring if one has not been provided
   189|         0|            0|            0|  0.00%|        if '__doc__' not in classdict:
   190|         0|            0|            0|  0.00%|            classdict['__doc__'] = 'An enumeration.'
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|        # create our new Enum type
   193|         0|            0|            0|  0.00%|        enum_class = super().__new__(metacls, cls, bases, classdict)
   194|         0|            0|            0|  0.00%|        enum_class._member_names_ = []               # names in definition order
   195|         0|            0|            0|  0.00%|        enum_class._member_map_ = {}                 # name->value map
   196|         0|            0|            0|  0.00%|        enum_class._member_type_ = member_type
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|        # save DynamicClassAttribute attributes from super classes so we know
   199|         0|            0|            0|  0.00%|        # if we can take the shortcut of storing members in the class dict
   200|         0|            0|            0|  0.00%|        dynamic_attributes = {
   201|         0|            0|            0|  0.00%|                k for c in enum_class.mro()
   202|         0|            0|            0|  0.00%|                for k, v in c.__dict__.items()
   203|         0|            0|            0|  0.00%|                if isinstance(v, DynamicClassAttribute)
   204|         0|            0|            0|  0.00%|                }
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|        # Reverse value->name map for hashable values.
   207|         0|            0|            0|  0.00%|        enum_class._value2member_map_ = {}
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|        # If a custom type is mixed into the Enum, and it does not know how
   210|         0|            0|            0|  0.00%|        # to pickle itself, pickle.dumps will succeed but pickle.loads will
   211|         0|            0|            0|  0.00%|        # fail.  Rather than have the error show up later and possibly far
   212|         0|            0|            0|  0.00%|        # from the source, sabotage the pickle protocol for this class so
   213|         0|            0|            0|  0.00%|        # that pickle.dumps also fails.
   214|         0|            0|            0|  0.00%|        #
   215|         0|            0|            0|  0.00%|        # However, if the new class implements its own __reduce_ex__, do not
   216|         0|            0|            0|  0.00%|        # sabotage -- it's on them to make sure it works correctly.  We use
   217|         0|            0|            0|  0.00%|        # __reduce_ex__ instead of any of the others as it is preferred by
   218|         0|            0|            0|  0.00%|        # pickle over __reduce__, and it handles all pickle protocols.
   219|         0|            0|            0|  0.00%|        if '__reduce_ex__' not in classdict:
   220|         0|            0|            0|  0.00%|            if member_type is not object:
   221|         0|            0|            0|  0.00%|                methods = ('__getnewargs_ex__', '__getnewargs__',
   222|         0|            0|            0|  0.00%|                        '__reduce_ex__', '__reduce__')
   223|         0|            0|            0|  0.00%|                if not any(m in member_type.__dict__ for m in methods):
   224|         0|            0|            0|  0.00%|                    _make_class_unpicklable(enum_class)
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        # instantiate them, checking for duplicates as we go
   227|         0|            0|            0|  0.00%|        # we instantiate first instead of checking for duplicates first in case
   228|         0|            0|            0|  0.00%|        # a custom __new__ is doing something funky with the values -- such as
   229|         0|            0|            0|  0.00%|        # auto-numbering ;)
   230|         0|            0|            0|  0.00%|        for member_name in classdict._member_names:
   231|         0|            0|            0|  0.00%|            value = enum_members[member_name]
   232|         0|            0|            0|  0.00%|            if not isinstance(value, tuple):
   233|         0|            0|            0|  0.00%|                args = (value, )
   234|         0|            0|            0|  0.00%|            else:
   235|         0|            0|            0|  0.00%|                args = value
   236|         0|            0|            0|  0.00%|            if member_type is tuple:   # special case for tuple enums
   237|         0|            0|            0|  0.00%|                args = (args, )     # wrap it one more time
   238|         0|            0|            0|  0.00%|            if not use_args:
   239|         0|            0|            0|  0.00%|                enum_member = __new__(enum_class)
   240|         0|            0|            0|  0.00%|                if not hasattr(enum_member, '_value_'):
   241|         0|            0|            0|  0.00%|                    enum_member._value_ = value
   242|         0|            0|            0|  0.00%|            else:
   243|         0|            0|            0|  0.00%|                enum_member = __new__(enum_class, *args)
   244|         0|            0|            0|  0.00%|                if not hasattr(enum_member, '_value_'):
   245|         0|            0|            0|  0.00%|                    if member_type is object:
   246|         0|            0|            0|  0.00%|                        enum_member._value_ = value
   247|         0|            0|            0|  0.00%|                    else:
   248|         0|            0|            0|  0.00%|                        enum_member._value_ = member_type(*args)
   249|         0|            0|            0|  0.00%|            value = enum_member._value_
   250|         0|            0|            0|  0.00%|            enum_member._name_ = member_name
   251|         0|            0|            0|  0.00%|            enum_member.__objclass__ = enum_class
   252|         0|            0|            0|  0.00%|            enum_member.__init__(*args)
   253|         0|            0|            0|  0.00%|            # If another member with the same value was already defined, the
   254|         0|            0|            0|  0.00%|            # new member becomes an alias to the existing one.
   255|         0|            0|            0|  0.00%|            for name, canonical_member in enum_class._member_map_.items():
   256|         0|            0|            0|  0.00%|                if canonical_member._value_ == enum_member._value_:
   257|         0|            0|            0|  0.00%|                    enum_member = canonical_member
   258|         0|            0|            0|  0.00%|                    break
   259|         0|            0|            0|  0.00%|            else:
   260|         0|            0|            0|  0.00%|                # Aliases don't appear in member names (only in __members__).
   261|         0|            0|            0|  0.00%|                enum_class._member_names_.append(member_name)
   262|         0|            0|            0|  0.00%|            # performance boost for any member that would not shadow
   263|         0|            0|            0|  0.00%|            # a DynamicClassAttribute
   264|         0|            0|            0|  0.00%|            if member_name not in dynamic_attributes:
   265|         0|            0|            0|  0.00%|                setattr(enum_class, member_name, enum_member)
   266|         0|            0|            0|  0.00%|            # now add to _member_map_
   267|         0|            0|            0|  0.00%|            enum_class._member_map_[member_name] = enum_member
   268|         0|            0|            0|  0.00%|            try:
   269|         0|            0|            0|  0.00%|                # This may fail if value is not hashable. We can't add the value
   270|         0|            0|            0|  0.00%|                # to the map, and by-value lookups for this value will be
   271|         0|            0|            0|  0.00%|                # linear.
   272|         0|            0|            0|  0.00%|                enum_class._value2member_map_[value] = enum_member
   273|         0|            0|            0|  0.00%|            except TypeError:
   274|         0|            0|            0|  0.00%|                pass
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|        # double check that repr and friends are not the mixin's or various
   277|         0|            0|            0|  0.00%|        # things break (such as pickle)
   278|         0|            0|            0|  0.00%|        # however, if the method is defined in the Enum itself, don't replace
   279|         0|            0|            0|  0.00%|        # it
   280|         0|            0|            0|  0.00%|        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):
   281|         0|            0|            0|  0.00%|            if name in classdict:
   282|         0|            0|            0|  0.00%|                continue
   283|         0|            0|            0|  0.00%|            class_method = getattr(enum_class, name)
   284|         0|            0|            0|  0.00%|            obj_method = getattr(member_type, name, None)
   285|         0|            0|            0|  0.00%|            enum_method = getattr(first_enum, name, None)
   286|         0|            0|            0|  0.00%|            if obj_method is not None and obj_method is class_method:
   287|         0|            0|            0|  0.00%|                setattr(enum_class, name, enum_method)
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|        # replace any other __new__ with our own (as long as Enum is not None,
   290|         0|            0|            0|  0.00%|        # anyway) -- again, this is to support pickle
   291|         0|            0|            0|  0.00%|        if Enum is not None:
   292|         0|            0|            0|  0.00%|            # if the user defined their own __new__, save it before it gets
   293|         0|            0|            0|  0.00%|            # clobbered in case they subclass later
   294|         0|            0|            0|  0.00%|            if save_new:
   295|         0|            0|            0|  0.00%|                enum_class.__new_member__ = __new__
   296|         0|            0|            0|  0.00%|            enum_class.__new__ = Enum.__new__
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|        # py3 support for definition order (helps keep py2/py3 code in sync)
   299|         0|            0|            0|  0.00%|        if _order_ is not None:
   300|         0|            0|            0|  0.00%|            if isinstance(_order_, str):
   301|         0|            0|            0|  0.00%|                _order_ = _order_.replace(',', ' ').split()
   302|         0|            0|            0|  0.00%|            if _order_ != enum_class._member_names_:
   303|         0|            0|            0|  0.00%|                raise TypeError('member order does not match _order_')
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|        return enum_class
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    def __bool__(self):
   308|         0|            0|            0|  0.00%|        """
   309|         0|            0|            0|  0.00%|        classes/types should always be True.
   310|         0|            0|            0|  0.00%|        """
   311|         0|            0|            0|  0.00%|        return True
   312|         0|            0|            0|  0.00%|
   313|         4|  2.81334e-05|  7.03335e-06|  0.00%|    def __call__(cls, value, names=None, *, module=None, qualname=None, type=None, start=1):
   314|         0|            0|            0|  0.00%|        """
   315|         0|            0|            0|  0.00%|        Either returns an existing member, or creates a new enum class.
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|        This method is used both when an enum class is given a value to match
   318|         0|            0|            0|  0.00%|        to an enumeration member (i.e. Color(3)) and for the functional API
   319|         0|            0|            0|  0.00%|        (i.e. Color = Enum('Color', names='RED GREEN BLUE')).
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|        When used for the functional API:
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|        `value` will be the name of the new class.
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|        `names` should be either a string of white-space/comma delimited names
   326|         0|            0|            0|  0.00%|        (values will start at `start`), or an iterator/mapping of name, value pairs.
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|        `module` should be set to the module this class is being created in;
   329|         0|            0|            0|  0.00%|        if it is not set, an attempt to find that module will be made, but if
   330|         0|            0|            0|  0.00%|        it fails the class will not be picklable.
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|        `qualname` should be set to the actual location this class can be found
   333|         0|            0|            0|  0.00%|        at in its module; by default it is set to the global scope.  If this is
   334|         0|            0|            0|  0.00%|        not correct, unpickling will fail in some circumstances.
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|        `type`, if set, will be mixed in as the first base class.
   337|         0|            0|            0|  0.00%|        """
   338|         4|  1.97887e-05|  4.94719e-06|  0.00%|        if names is None:  # simple value lookup
   339|         4|  6.31809e-05|  1.57952e-05|  0.00%|            return cls.__new__(cls, value)
(call)|         4|  9.56059e-05|  2.39015e-05|  0.00%|# /opt/conda/lib/python3.8/enum.py:631 __new__
   340|         0|            0|            0|  0.00%|        # otherwise, functional API: we're creating a new Enum type
   341|         0|            0|            0|  0.00%|        return cls._create_(
   342|         0|            0|            0|  0.00%|                value,
   343|         0|            0|            0|  0.00%|                names,
   344|         0|            0|            0|  0.00%|                module=module,
   345|         0|            0|            0|  0.00%|                qualname=qualname,
   346|         0|            0|            0|  0.00%|                type=type,
   347|         0|            0|            0|  0.00%|                start=start,
   348|         0|            0|            0|  0.00%|                )
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|    def __contains__(cls, member):
   351|         0|            0|            0|  0.00%|        if not isinstance(member, Enum):
   352|         0|            0|            0|  0.00%|            raise TypeError(
   353|         0|            0|            0|  0.00%|                "unsupported operand type(s) for 'in': '%s' and '%s'" % (
   354|         0|            0|            0|  0.00%|                    type(member).__qualname__, cls.__class__.__qualname__))
   355|         0|            0|            0|  0.00%|        return isinstance(member, cls) and member._name_ in cls._member_map_
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|    def __delattr__(cls, attr):
   358|         0|            0|            0|  0.00%|        # nicer error message when someone tries to delete an attribute
   359|         0|            0|            0|  0.00%|        # (see issue19025).
   360|         0|            0|            0|  0.00%|        if attr in cls._member_map_:
   361|         0|            0|            0|  0.00%|            raise AttributeError("%s: cannot delete Enum member." % cls.__name__)
   362|         0|            0|            0|  0.00%|        super().__delattr__(attr)
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|    def __dir__(self):
   365|         0|            0|            0|  0.00%|        return (
   366|         0|            0|            0|  0.00%|                ['__class__', '__doc__', '__members__', '__module__']
   367|         0|            0|            0|  0.00%|                + self._member_names_
   368|         0|            0|            0|  0.00%|                )
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    def __getattr__(cls, name):
   371|         0|            0|            0|  0.00%|        """
   372|         0|            0|            0|  0.00%|        Return the enum member matching `name`
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|        We use __getattr__ instead of descriptors or inserting into the enum
   375|         0|            0|            0|  0.00%|        class' __dict__ in order to support `name` and `value` being both
   376|         0|            0|            0|  0.00%|        properties for enum members (which live in the class' __dict__) and
   377|         0|            0|            0|  0.00%|        enum members themselves.
   378|         0|            0|            0|  0.00%|        """
   379|         0|            0|            0|  0.00%|        if _is_dunder(name):
   380|         0|            0|            0|  0.00%|            raise AttributeError(name)
   381|         0|            0|            0|  0.00%|        try:
   382|         0|            0|            0|  0.00%|            return cls._member_map_[name]
   383|         0|            0|            0|  0.00%|        except KeyError:
   384|         0|            0|            0|  0.00%|            raise AttributeError(name) from None
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|    def __getitem__(cls, name):
   387|         0|            0|            0|  0.00%|        return cls._member_map_[name]
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    def __iter__(cls):
   390|         0|            0|            0|  0.00%|        """
   391|         0|            0|            0|  0.00%|        Returns members in definition order.
   392|         0|            0|            0|  0.00%|        """
   393|         0|            0|            0|  0.00%|        return (cls._member_map_[name] for name in cls._member_names_)
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    def __len__(cls):
   396|         0|            0|            0|  0.00%|        return len(cls._member_names_)
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    @property
   399|         0|            0|            0|  0.00%|    def __members__(cls):
   400|         0|            0|            0|  0.00%|        """
   401|         0|            0|            0|  0.00%|        Returns a mapping of member name->value.
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|        This mapping lists all enum members, including aliases. Note that this
   404|         0|            0|            0|  0.00%|        is a read-only view of the internal mapping.
   405|         0|            0|            0|  0.00%|        """
   406|         0|            0|            0|  0.00%|        return MappingProxyType(cls._member_map_)
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|    def __repr__(cls):
   409|         0|            0|            0|  0.00%|        return "<enum %r>" % cls.__name__
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    def __reversed__(cls):
   412|         0|            0|            0|  0.00%|        """
   413|         0|            0|            0|  0.00%|        Returns members in reverse definition order.
   414|         0|            0|            0|  0.00%|        """
   415|         0|            0|            0|  0.00%|        return (cls._member_map_[name] for name in reversed(cls._member_names_))
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|    def __setattr__(cls, name, value):
   418|         0|            0|            0|  0.00%|        """
   419|         0|            0|            0|  0.00%|        Block attempts to reassign Enum members.
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|        A simple assignment to the class namespace only changes one of the
   422|         0|            0|            0|  0.00%|        several possible ways to get an Enum member from the Enum class,
   423|         0|            0|            0|  0.00%|        resulting in an inconsistent Enumeration.
   424|         0|            0|            0|  0.00%|        """
   425|         0|            0|            0|  0.00%|        member_map = cls.__dict__.get('_member_map_', {})
   426|         0|            0|            0|  0.00%|        if name in member_map:
   427|         0|            0|            0|  0.00%|            raise AttributeError('Cannot reassign members.')
   428|         0|            0|            0|  0.00%|        super().__setattr__(name, value)
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|    def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1):
   431|         0|            0|            0|  0.00%|        """
   432|         0|            0|            0|  0.00%|        Convenience method to create a new Enum class.
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|        `names` can be:
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|        * A string containing member names, separated either with spaces or
   437|         0|            0|            0|  0.00%|          commas.  Values are incremented by 1 from `start`.
   438|         0|            0|            0|  0.00%|        * An iterable of member names.  Values are incremented by 1 from `start`.
   439|         0|            0|            0|  0.00%|        * An iterable of (member name, value) pairs.
   440|         0|            0|            0|  0.00%|        * A mapping of member name -> value pairs.
   441|         0|            0|            0|  0.00%|        """
   442|         0|            0|            0|  0.00%|        metacls = cls.__class__
   443|         0|            0|            0|  0.00%|        bases = (cls, ) if type is None else (type, cls)
   444|         0|            0|            0|  0.00%|        _, first_enum = cls._get_mixins_(cls, bases)
   445|         0|            0|            0|  0.00%|        classdict = metacls.__prepare__(class_name, bases)
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|        # special processing needed for names?
   448|         0|            0|            0|  0.00%|        if isinstance(names, str):
   449|         0|            0|            0|  0.00%|            names = names.replace(',', ' ').split()
   450|         0|            0|            0|  0.00%|        if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):
   451|         0|            0|            0|  0.00%|            original_names, names = names, []
   452|         0|            0|            0|  0.00%|            last_values = []
   453|         0|            0|            0|  0.00%|            for count, name in enumerate(original_names):
   454|         0|            0|            0|  0.00%|                value = first_enum._generate_next_value_(name, start, count, last_values[:])
   455|         0|            0|            0|  0.00%|                last_values.append(value)
   456|         0|            0|            0|  0.00%|                names.append((name, value))
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|        # Here, names is either an iterable of (name, value) or a mapping.
   459|         0|            0|            0|  0.00%|        for item in names:
   460|         0|            0|            0|  0.00%|            if isinstance(item, str):
   461|         0|            0|            0|  0.00%|                member_name, member_value = item, names[item]
   462|         0|            0|            0|  0.00%|            else:
   463|         0|            0|            0|  0.00%|                member_name, member_value = item
   464|         0|            0|            0|  0.00%|            classdict[member_name] = member_value
   465|         0|            0|            0|  0.00%|        enum_class = metacls.__new__(metacls, class_name, bases, classdict)
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|        # TODO: replace the frame hack if a blessed way to know the calling
   468|         0|            0|            0|  0.00%|        # module is ever developed
   469|         0|            0|            0|  0.00%|        if module is None:
   470|         0|            0|            0|  0.00%|            try:
   471|         0|            0|            0|  0.00%|                module = sys._getframe(2).f_globals['__name__']
   472|         0|            0|            0|  0.00%|            except (AttributeError, ValueError, KeyError) as exc:
   473|         0|            0|            0|  0.00%|                pass
   474|         0|            0|            0|  0.00%|        if module is None:
   475|         0|            0|            0|  0.00%|            _make_class_unpicklable(enum_class)
   476|         0|            0|            0|  0.00%|        else:
   477|         0|            0|            0|  0.00%|            enum_class.__module__ = module
   478|         0|            0|            0|  0.00%|        if qualname is not None:
   479|         0|            0|            0|  0.00%|            enum_class.__qualname__ = qualname
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        return enum_class
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|    def _convert_(cls, name, module, filter, source=None):
   484|         0|            0|            0|  0.00%|        """
   485|         0|            0|            0|  0.00%|        Create a new Enum subclass that replaces a collection of global constants
   486|         0|            0|            0|  0.00%|        """
   487|         0|            0|            0|  0.00%|        # convert all constants from source (or module) that pass filter() to
   488|         0|            0|            0|  0.00%|        # a new Enum called name, and export the enum and its members back to
   489|         0|            0|            0|  0.00%|        # module;
   490|         0|            0|            0|  0.00%|        # also, replace the __reduce_ex__ method so unpickling works in
   491|         0|            0|            0|  0.00%|        # previous Python versions
   492|         0|            0|            0|  0.00%|        module_globals = vars(sys.modules[module])
   493|         0|            0|            0|  0.00%|        if source:
   494|         0|            0|            0|  0.00%|            source = vars(source)
   495|         0|            0|            0|  0.00%|        else:
   496|         0|            0|            0|  0.00%|            source = module_globals
   497|         0|            0|            0|  0.00%|        # _value2member_map_ is populated in the same order every time
   498|         0|            0|            0|  0.00%|        # for a consistent reverse mapping of number to name when there
   499|         0|            0|            0|  0.00%|        # are multiple names for the same number.
   500|         0|            0|            0|  0.00%|        members = [
   501|         0|            0|            0|  0.00%|                (name, value)
   502|         0|            0|            0|  0.00%|                for name, value in source.items()
   503|         0|            0|            0|  0.00%|                if filter(name)]
   504|         0|            0|            0|  0.00%|        try:
   505|         0|            0|            0|  0.00%|            # sort by value
   506|         0|            0|            0|  0.00%|            members.sort(key=lambda t: (t[1], t[0]))
   507|         0|            0|            0|  0.00%|        except TypeError:
   508|         0|            0|            0|  0.00%|            # unless some values aren't comparable, in which case sort by name
   509|         0|            0|            0|  0.00%|            members.sort(key=lambda t: t[0])
   510|         0|            0|            0|  0.00%|        cls = cls(name, members, module=module)
   511|         0|            0|            0|  0.00%|        cls.__reduce_ex__ = _reduce_ex_by_name
   512|         0|            0|            0|  0.00%|        module_globals.update(cls.__members__)
   513|         0|            0|            0|  0.00%|        module_globals[name] = cls
   514|         0|            0|            0|  0.00%|        return cls
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    def _convert(cls, *args, **kwargs):
   517|         0|            0|            0|  0.00%|        import warnings
   518|         0|            0|            0|  0.00%|        warnings.warn("_convert is deprecated and will be removed in 3.9, use "
   519|         0|            0|            0|  0.00%|                      "_convert_ instead.", DeprecationWarning, stacklevel=2)
   520|         0|            0|            0|  0.00%|        return cls._convert_(*args, **kwargs)
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|    @staticmethod
   523|         0|            0|            0|  0.00%|    def _check_for_existing_members(class_name, bases):
   524|         0|            0|            0|  0.00%|        for chain in bases:
   525|         0|            0|            0|  0.00%|            for base in chain.__mro__:
   526|         0|            0|            0|  0.00%|                if issubclass(base, Enum) and base._member_names_:
   527|         0|            0|            0|  0.00%|                    raise TypeError(
   528|         0|            0|            0|  0.00%|                            "%s: cannot extend enumeration %r"
   529|         0|            0|            0|  0.00%|                            % (class_name, base.__name__)
   530|         0|            0|            0|  0.00%|                            )
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|    @staticmethod
   533|         0|            0|            0|  0.00%|    def _get_mixins_(class_name, bases):
   534|         0|            0|            0|  0.00%|        """
   535|         0|            0|            0|  0.00%|        Returns the type for creating enum members, and the first inherited
   536|         0|            0|            0|  0.00%|        enum class.
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|        bases: the tuple of bases that was given to __new__
   539|         0|            0|            0|  0.00%|        """
   540|         0|            0|            0|  0.00%|        if not bases:
   541|         0|            0|            0|  0.00%|            return object, Enum
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|        def _find_data_type(bases):
   544|         0|            0|            0|  0.00%|            data_types = []
   545|         0|            0|            0|  0.00%|            for chain in bases:
   546|         0|            0|            0|  0.00%|                candidate = None
   547|         0|            0|            0|  0.00%|                for base in chain.__mro__:
   548|         0|            0|            0|  0.00%|                    if base is object:
   549|         0|            0|            0|  0.00%|                        continue
   550|         0|            0|            0|  0.00%|                    elif issubclass(base, Enum):
   551|         0|            0|            0|  0.00%|                        if base._member_type_ is not object:
   552|         0|            0|            0|  0.00%|                            data_types.append(base._member_type_)
   553|         0|            0|            0|  0.00%|                            break
   554|         0|            0|            0|  0.00%|                    elif '__new__' in base.__dict__:
   555|         0|            0|            0|  0.00%|                        if issubclass(base, Enum):
   556|         0|            0|            0|  0.00%|                            continue
   557|         0|            0|            0|  0.00%|                        data_types.append(candidate or base)
   558|         0|            0|            0|  0.00%|                        break
   559|         0|            0|            0|  0.00%|                    else:
   560|         0|            0|            0|  0.00%|                        candidate = base
   561|         0|            0|            0|  0.00%|            if len(data_types) > 1:
   562|         0|            0|            0|  0.00%|                raise TypeError('%r: too many data types: %r' % (class_name, data_types))
   563|         0|            0|            0|  0.00%|            elif data_types:
   564|         0|            0|            0|  0.00%|                return data_types[0]
   565|         0|            0|            0|  0.00%|            else:
   566|         0|            0|            0|  0.00%|                return None
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|        # ensure final parent class is an Enum derivative, find any concrete
   569|         0|            0|            0|  0.00%|        # data type, and check that Enum has no members
   570|         0|            0|            0|  0.00%|        first_enum = bases[-1]
   571|         0|            0|            0|  0.00%|        if not issubclass(first_enum, Enum):
   572|         0|            0|            0|  0.00%|            raise TypeError("new enumerations should be created as "
   573|         0|            0|            0|  0.00%|                    "`EnumName([mixin_type, ...] [data_type,] enum_type)`")
   574|         0|            0|            0|  0.00%|        member_type = _find_data_type(bases) or object
   575|         0|            0|            0|  0.00%|        if first_enum._member_names_:
   576|         0|            0|            0|  0.00%|            raise TypeError("Cannot extend enumerations")
   577|         0|            0|            0|  0.00%|        return member_type, first_enum
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    @staticmethod
   580|         0|            0|            0|  0.00%|    def _find_new_(classdict, member_type, first_enum):
   581|         0|            0|            0|  0.00%|        """
   582|         0|            0|            0|  0.00%|        Returns the __new__ to be used for creating the enum members.
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|        classdict: the class dictionary given to __new__
   585|         0|            0|            0|  0.00%|        member_type: the data type whose __new__ will be used by default
   586|         0|            0|            0|  0.00%|        first_enum: enumeration to check for an overriding __new__
   587|         0|            0|            0|  0.00%|        """
   588|         0|            0|            0|  0.00%|        # now find the correct __new__, checking to see of one was defined
   589|         0|            0|            0|  0.00%|        # by the user; also check earlier enum classes in case a __new__ was
   590|         0|            0|            0|  0.00%|        # saved as __new_member__
   591|         0|            0|            0|  0.00%|        __new__ = classdict.get('__new__', None)
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|        # should __new__ be saved as __new_member__ later?
   594|         0|            0|            0|  0.00%|        save_new = __new__ is not None
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|        if __new__ is None:
   597|         0|            0|            0|  0.00%|            # check all possibles for __new_member__ before falling back to
   598|         0|            0|            0|  0.00%|            # __new__
   599|         0|            0|            0|  0.00%|            for method in ('__new_member__', '__new__'):
   600|         0|            0|            0|  0.00%|                for possible in (member_type, first_enum):
   601|         0|            0|            0|  0.00%|                    target = getattr(possible, method, None)
   602|         0|            0|            0|  0.00%|                    if target not in {
   603|         0|            0|            0|  0.00%|                            None,
   604|         0|            0|            0|  0.00%|                            None.__new__,
   605|         0|            0|            0|  0.00%|                            object.__new__,
   606|         0|            0|            0|  0.00%|                            Enum.__new__,
   607|         0|            0|            0|  0.00%|                            }:
   608|         0|            0|            0|  0.00%|                        __new__ = target
   609|         0|            0|            0|  0.00%|                        break
   610|         0|            0|            0|  0.00%|                if __new__ is not None:
   611|         0|            0|            0|  0.00%|                    break
   612|         0|            0|            0|  0.00%|            else:
   613|         0|            0|            0|  0.00%|                __new__ = object.__new__
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|        # if a non-object.__new__ is used then whatever value/tuple was
   616|         0|            0|            0|  0.00%|        # assigned to the enum member name will be passed to __new__ and to the
   617|         0|            0|            0|  0.00%|        # new enum member's __init__
   618|         0|            0|            0|  0.00%|        if __new__ is object.__new__:
   619|         0|            0|            0|  0.00%|            use_args = False
   620|         0|            0|            0|  0.00%|        else:
   621|         0|            0|            0|  0.00%|            use_args = True
   622|         0|            0|            0|  0.00%|        return __new__, save_new, use_args
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|class Enum(metaclass=EnumMeta):
   626|         0|            0|            0|  0.00%|    """
   627|         0|            0|            0|  0.00%|    Generic enumeration.
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|    Derive from this class to define new enumerations.
   630|         0|            0|            0|  0.00%|    """
   631|         4|  3.14713e-05|  7.86781e-06|  0.00%|    def __new__(cls, value):
   632|         0|            0|            0|  0.00%|        # all enum instances are actually created during class construction
   633|         0|            0|            0|  0.00%|        # without calling this method; this method is called by the metaclass'
   634|         0|            0|            0|  0.00%|        # __call__ (i.e. Color(3) ), and by pickle
   635|         4|  2.21729e-05|  5.54323e-06|  0.00%|        if type(value) is cls:
   636|         0|            0|            0|  0.00%|            # For lookups like Color(Color.RED)
   637|         0|            0|            0|  0.00%|            return value
   638|         0|            0|            0|  0.00%|        # by-value search for a matching enum member
   639|         0|            0|            0|  0.00%|        # see if it's in the reverse mapping (for hashable values)
   640|         4|  1.93119e-05|  4.82798e-06|  0.00%|        try:
   641|         4|  2.26498e-05|  5.66244e-06|  0.00%|            return cls._value2member_map_[value]
   642|         0|            0|            0|  0.00%|        except KeyError:
   643|         0|            0|            0|  0.00%|            # Not found, no need to do long O(n) search
   644|         0|            0|            0|  0.00%|            pass
   645|         0|            0|            0|  0.00%|        except TypeError:
   646|         0|            0|            0|  0.00%|            # not there, now do long search -- O(n) behavior
   647|         0|            0|            0|  0.00%|            for member in cls._member_map_.values():
   648|         0|            0|            0|  0.00%|                if member._value_ == value:
   649|         0|            0|            0|  0.00%|                    return member
   650|         0|            0|            0|  0.00%|        # still not found -- try _missing_ hook
   651|         0|            0|            0|  0.00%|        try:
   652|         0|            0|            0|  0.00%|            exc = None
   653|         0|            0|            0|  0.00%|            result = cls._missing_(value)
   654|         0|            0|            0|  0.00%|        except Exception as e:
   655|         0|            0|            0|  0.00%|            exc = e
   656|         0|            0|            0|  0.00%|            result = None
   657|         0|            0|            0|  0.00%|        if isinstance(result, cls):
   658|         0|            0|            0|  0.00%|            return result
   659|         0|            0|            0|  0.00%|        else:
   660|         0|            0|            0|  0.00%|            ve_exc = ValueError("%r is not a valid %s" % (value, cls.__name__))
   661|         0|            0|            0|  0.00%|            if result is None and exc is None:
   662|         0|            0|            0|  0.00%|                raise ve_exc
   663|         0|            0|            0|  0.00%|            elif exc is None:
   664|         0|            0|            0|  0.00%|                exc = TypeError(
   665|         0|            0|            0|  0.00%|                        'error in %s._missing_: returned %r instead of None or a valid member'
   666|         0|            0|            0|  0.00%|                        % (cls.__name__, result)
   667|         0|            0|            0|  0.00%|                        )
   668|         0|            0|            0|  0.00%|            exc.__context__ = ve_exc
   669|         0|            0|            0|  0.00%|            raise exc
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|    def _generate_next_value_(name, start, count, last_values):
   672|         0|            0|            0|  0.00%|        """
   673|         0|            0|            0|  0.00%|        Generate the next value when not given.
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|        name: the name of the member
   676|         0|            0|            0|  0.00%|        start: the initial start value or None
   677|         0|            0|            0|  0.00%|        count: the number of existing members
   678|         0|            0|            0|  0.00%|        last_value: the last value assigned or None
   679|         0|            0|            0|  0.00%|        """
   680|         0|            0|            0|  0.00%|        for last_value in reversed(last_values):
   681|         0|            0|            0|  0.00%|            try:
   682|         0|            0|            0|  0.00%|                return last_value + 1
   683|         0|            0|            0|  0.00%|            except TypeError:
   684|         0|            0|            0|  0.00%|                pass
   685|         0|            0|            0|  0.00%|        else:
   686|         0|            0|            0|  0.00%|            return start
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|    @classmethod
   689|         0|            0|            0|  0.00%|    def _missing_(cls, value):
   690|         0|            0|            0|  0.00%|        return None
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    def __repr__(self):
   693|         0|            0|            0|  0.00%|        return "<%s.%s: %r>" % (
   694|         0|            0|            0|  0.00%|                self.__class__.__name__, self._name_, self._value_)
   695|         0|            0|            0|  0.00%|
   696|         0|            0|            0|  0.00%|    def __str__(self):
   697|         0|            0|            0|  0.00%|        return "%s.%s" % (self.__class__.__name__, self._name_)
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|    def __dir__(self):
   700|         0|            0|            0|  0.00%|        """
   701|         0|            0|            0|  0.00%|        Returns all members and all public methods
   702|         0|            0|            0|  0.00%|        """
   703|         0|            0|            0|  0.00%|        added_behavior = [
   704|         0|            0|            0|  0.00%|                m
   705|         0|            0|            0|  0.00%|                for cls in self.__class__.mro()
   706|         0|            0|            0|  0.00%|                for m in cls.__dict__
   707|         0|            0|            0|  0.00%|                if m[0] != '_' and m not in self._member_map_
   708|         0|            0|            0|  0.00%|                ] + [m for m in self.__dict__ if m[0] != '_']
   709|         0|            0|            0|  0.00%|        return (['__class__', '__doc__', '__module__'] + added_behavior)
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    def __format__(self, format_spec):
   712|         0|            0|            0|  0.00%|        """
   713|         0|            0|            0|  0.00%|        Returns format using actual value type unless __str__ has been overridden.
   714|         0|            0|            0|  0.00%|        """
   715|         0|            0|            0|  0.00%|        # mixed-in Enums should use the mixed-in type's __format__, otherwise
   716|         0|            0|            0|  0.00%|        # we can get strange results with the Enum name showing up instead of
   717|         0|            0|            0|  0.00%|        # the value
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|        # pure Enum branch, or branch with __str__ explicitly overridden
   720|         0|            0|            0|  0.00%|        str_overridden = type(self).__str__ not in (Enum.__str__, Flag.__str__)
   721|         0|            0|            0|  0.00%|        if self._member_type_ is object or str_overridden:
   722|         0|            0|            0|  0.00%|            cls = str
   723|         0|            0|            0|  0.00%|            val = str(self)
   724|         0|            0|            0|  0.00%|        # mix-in branch
   725|         0|            0|            0|  0.00%|        else:
   726|         0|            0|            0|  0.00%|            cls = self._member_type_
   727|         0|            0|            0|  0.00%|            val = self._value_
   728|         0|            0|            0|  0.00%|        return cls.__format__(val, format_spec)
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    def __hash__(self):
   731|         0|            0|            0|  0.00%|        return hash(self._name_)
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|    def __reduce_ex__(self, proto):
   734|         0|            0|            0|  0.00%|        return self.__class__, (self._value_, )
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|    # DynamicClassAttribute is used to provide access to the `name` and
   737|         0|            0|            0|  0.00%|    # `value` properties of enum members while keeping some measure of
   738|         0|            0|            0|  0.00%|    # protection from modification, while still allowing for an enumeration
   739|         0|            0|            0|  0.00%|    # to have members named `name` and `value`.  This works because enumeration
   740|         0|            0|            0|  0.00%|    # members are not set directly on the enum class -- __getattr__ is
   741|         0|            0|            0|  0.00%|    # used to look them up.
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|    @DynamicClassAttribute
   744|         0|            0|            0|  0.00%|    def name(self):
   745|         0|            0|            0|  0.00%|        """The name of the Enum member."""
   746|         0|            0|            0|  0.00%|        return self._name_
   747|         0|            0|            0|  0.00%|
   748|       369|   0.00140405|  3.80501e-06|  0.00%|    @DynamicClassAttribute
   749|         0|            0|            0|  0.00%|    def value(self):
   750|         0|            0|            0|  0.00%|        """The value of the Enum member."""
   751|       369|   0.00142717|  3.86768e-06|  0.00%|        return self._value_
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|class IntEnum(int, Enum):
   755|         0|            0|            0|  0.00%|    """Enum where members are also (and must be) ints"""
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|def _reduce_ex_by_name(self, proto):
   759|         0|            0|            0|  0.00%|    return self.name
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|class Flag(Enum):
   762|         0|            0|            0|  0.00%|    """
   763|         0|            0|            0|  0.00%|    Support for flags
   764|         0|            0|            0|  0.00%|    """
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    def _generate_next_value_(name, start, count, last_values):
   767|         0|            0|            0|  0.00%|        """
   768|         0|            0|            0|  0.00%|        Generate the next value when not given.
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|        name: the name of the member
   771|         0|            0|            0|  0.00%|        start: the initial start value or None
   772|         0|            0|            0|  0.00%|        count: the number of existing members
   773|         0|            0|            0|  0.00%|        last_value: the last value assigned or None
   774|         0|            0|            0|  0.00%|        """
   775|         0|            0|            0|  0.00%|        if not count:
   776|         0|            0|            0|  0.00%|            return start if start is not None else 1
   777|         0|            0|            0|  0.00%|        for last_value in reversed(last_values):
   778|         0|            0|            0|  0.00%|            try:
   779|         0|            0|            0|  0.00%|                high_bit = _high_bit(last_value)
   780|         0|            0|            0|  0.00%|                break
   781|         0|            0|            0|  0.00%|            except Exception:
   782|         0|            0|            0|  0.00%|                raise TypeError('Invalid Flag value: %r' % last_value) from None
   783|         0|            0|            0|  0.00%|        return 2 ** (high_bit+1)
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|    @classmethod
   786|         0|            0|            0|  0.00%|    def _missing_(cls, value):
   787|         0|            0|            0|  0.00%|        """
   788|         0|            0|            0|  0.00%|        Returns member (possibly creating it) if one can be found for value.
   789|         0|            0|            0|  0.00%|        """
   790|         0|            0|            0|  0.00%|        original_value = value
   791|         0|            0|            0|  0.00%|        if value < 0:
   792|         0|            0|            0|  0.00%|            value = ~value
   793|         0|            0|            0|  0.00%|        possible_member = cls._create_pseudo_member_(value)
   794|         0|            0|            0|  0.00%|        if original_value < 0:
   795|         0|            0|            0|  0.00%|            possible_member = ~possible_member
   796|         0|            0|            0|  0.00%|        return possible_member
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|    @classmethod
   799|         0|            0|            0|  0.00%|    def _create_pseudo_member_(cls, value):
   800|         0|            0|            0|  0.00%|        """
   801|         0|            0|            0|  0.00%|        Create a composite member iff value contains only members.
   802|         0|            0|            0|  0.00%|        """
   803|         0|            0|            0|  0.00%|        pseudo_member = cls._value2member_map_.get(value, None)
   804|         0|            0|            0|  0.00%|        if pseudo_member is None:
   805|         0|            0|            0|  0.00%|            # verify all bits are accounted for
   806|         0|            0|            0|  0.00%|            _, extra_flags = _decompose(cls, value)
   807|         0|            0|            0|  0.00%|            if extra_flags:
   808|         0|            0|            0|  0.00%|                raise ValueError("%r is not a valid %s" % (value, cls.__name__))
   809|         0|            0|            0|  0.00%|            # construct a singleton enum pseudo-member
   810|         0|            0|            0|  0.00%|            pseudo_member = object.__new__(cls)
   811|         0|            0|            0|  0.00%|            pseudo_member._name_ = None
   812|         0|            0|            0|  0.00%|            pseudo_member._value_ = value
   813|         0|            0|            0|  0.00%|            # use setdefault in case another thread already created a composite
   814|         0|            0|            0|  0.00%|            # with this value
   815|         0|            0|            0|  0.00%|            pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
   816|         0|            0|            0|  0.00%|        return pseudo_member
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    def __contains__(self, other):
   819|         0|            0|            0|  0.00%|        """
   820|         0|            0|            0|  0.00%|        Returns True if self has at least the same flags set as other.
   821|         0|            0|            0|  0.00%|        """
   822|         0|            0|            0|  0.00%|        if not isinstance(other, self.__class__):
   823|         0|            0|            0|  0.00%|            raise TypeError(
   824|         0|            0|            0|  0.00%|                "unsupported operand type(s) for 'in': '%s' and '%s'" % (
   825|         0|            0|            0|  0.00%|                    type(other).__qualname__, self.__class__.__qualname__))
   826|         0|            0|            0|  0.00%|        return other._value_ & self._value_ == other._value_
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|    def __repr__(self):
   829|         0|            0|            0|  0.00%|        cls = self.__class__
   830|         0|            0|            0|  0.00%|        if self._name_ is not None:
   831|         0|            0|            0|  0.00%|            return '<%s.%s: %r>' % (cls.__name__, self._name_, self._value_)
   832|         0|            0|            0|  0.00%|        members, uncovered = _decompose(cls, self._value_)
   833|         0|            0|            0|  0.00%|        return '<%s.%s: %r>' % (
   834|         0|            0|            0|  0.00%|                cls.__name__,
   835|         0|            0|            0|  0.00%|                '|'.join([str(m._name_ or m._value_) for m in members]),
   836|         0|            0|            0|  0.00%|                self._value_,
   837|         0|            0|            0|  0.00%|                )
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|    def __str__(self):
   840|         0|            0|            0|  0.00%|        cls = self.__class__
   841|         0|            0|            0|  0.00%|        if self._name_ is not None:
   842|         0|            0|            0|  0.00%|            return '%s.%s' % (cls.__name__, self._name_)
   843|         0|            0|            0|  0.00%|        members, uncovered = _decompose(cls, self._value_)
   844|         0|            0|            0|  0.00%|        if len(members) == 1 and members[0]._name_ is None:
   845|         0|            0|            0|  0.00%|            return '%s.%r' % (cls.__name__, members[0]._value_)
   846|         0|            0|            0|  0.00%|        else:
   847|         0|            0|            0|  0.00%|            return '%s.%s' % (
   848|         0|            0|            0|  0.00%|                    cls.__name__,
   849|         0|            0|            0|  0.00%|                    '|'.join([str(m._name_ or m._value_) for m in members]),
   850|         0|            0|            0|  0.00%|                    )
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|    def __bool__(self):
   853|         0|            0|            0|  0.00%|        return bool(self._value_)
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|    def __or__(self, other):
   856|         0|            0|            0|  0.00%|        if not isinstance(other, self.__class__):
   857|         0|            0|            0|  0.00%|            return NotImplemented
   858|         0|            0|            0|  0.00%|        return self.__class__(self._value_ | other._value_)
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|    def __and__(self, other):
   861|         0|            0|            0|  0.00%|        if not isinstance(other, self.__class__):
   862|         0|            0|            0|  0.00%|            return NotImplemented
   863|         0|            0|            0|  0.00%|        return self.__class__(self._value_ & other._value_)
   864|         0|            0|            0|  0.00%|
   865|         0|            0|            0|  0.00%|    def __xor__(self, other):
   866|         0|            0|            0|  0.00%|        if not isinstance(other, self.__class__):
   867|         0|            0|            0|  0.00%|            return NotImplemented
   868|         0|            0|            0|  0.00%|        return self.__class__(self._value_ ^ other._value_)
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    def __invert__(self):
   871|         0|            0|            0|  0.00%|        members, uncovered = _decompose(self.__class__, self._value_)
   872|         0|            0|            0|  0.00%|        inverted = self.__class__(0)
   873|         0|            0|            0|  0.00%|        for m in self.__class__:
   874|         0|            0|            0|  0.00%|            if m not in members and not (m._value_ & self._value_):
   875|         0|            0|            0|  0.00%|                inverted = inverted | m
   876|         0|            0|            0|  0.00%|        return self.__class__(inverted)
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|class IntFlag(int, Flag):
   880|         0|            0|            0|  0.00%|    """
   881|         0|            0|            0|  0.00%|    Support for integer-based Flags
   882|         0|            0|            0|  0.00%|    """
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|    @classmethod
   885|         0|            0|            0|  0.00%|    def _missing_(cls, value):
   886|         0|            0|            0|  0.00%|        """
   887|         0|            0|            0|  0.00%|        Returns member (possibly creating it) if one can be found for value.
   888|         0|            0|            0|  0.00%|        """
   889|         0|            0|            0|  0.00%|        if not isinstance(value, int):
   890|         0|            0|            0|  0.00%|            raise ValueError("%r is not a valid %s" % (value, cls.__name__))
   891|         0|            0|            0|  0.00%|        new_member = cls._create_pseudo_member_(value)
   892|         0|            0|            0|  0.00%|        return new_member
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|    @classmethod
   895|         0|            0|            0|  0.00%|    def _create_pseudo_member_(cls, value):
   896|         0|            0|            0|  0.00%|        """
   897|         0|            0|            0|  0.00%|        Create a composite member iff value contains only members.
   898|         0|            0|            0|  0.00%|        """
   899|         0|            0|            0|  0.00%|        pseudo_member = cls._value2member_map_.get(value, None)
   900|         0|            0|            0|  0.00%|        if pseudo_member is None:
   901|         0|            0|            0|  0.00%|            need_to_create = [value]
   902|         0|            0|            0|  0.00%|            # get unaccounted for bits
   903|         0|            0|            0|  0.00%|            _, extra_flags = _decompose(cls, value)
   904|         0|            0|            0|  0.00%|            # timer = 10
   905|         0|            0|            0|  0.00%|            while extra_flags:
   906|         0|            0|            0|  0.00%|                # timer -= 1
   907|         0|            0|            0|  0.00%|                bit = _high_bit(extra_flags)
   908|         0|            0|            0|  0.00%|                flag_value = 2 ** bit
   909|         0|            0|            0|  0.00%|                if (flag_value not in cls._value2member_map_ and
   910|         0|            0|            0|  0.00%|                        flag_value not in need_to_create
   911|         0|            0|            0|  0.00%|                        ):
   912|         0|            0|            0|  0.00%|                    need_to_create.append(flag_value)
   913|         0|            0|            0|  0.00%|                if extra_flags == -flag_value:
   914|         0|            0|            0|  0.00%|                    extra_flags = 0
   915|         0|            0|            0|  0.00%|                else:
   916|         0|            0|            0|  0.00%|                    extra_flags ^= flag_value
   917|         0|            0|            0|  0.00%|            for value in reversed(need_to_create):
   918|         0|            0|            0|  0.00%|                # construct singleton pseudo-members
   919|         0|            0|            0|  0.00%|                pseudo_member = int.__new__(cls, value)
   920|         0|            0|            0|  0.00%|                pseudo_member._name_ = None
   921|         0|            0|            0|  0.00%|                pseudo_member._value_ = value
   922|         0|            0|            0|  0.00%|                # use setdefault in case another thread already created a composite
   923|         0|            0|            0|  0.00%|                # with this value
   924|         0|            0|            0|  0.00%|                pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
   925|         0|            0|            0|  0.00%|        return pseudo_member
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|    def __or__(self, other):
   928|         0|            0|            0|  0.00%|        if not isinstance(other, (self.__class__, int)):
   929|         0|            0|            0|  0.00%|            return NotImplemented
   930|         0|            0|            0|  0.00%|        result = self.__class__(self._value_ | self.__class__(other)._value_)
   931|         0|            0|            0|  0.00%|        return result
   932|         0|            0|            0|  0.00%|
   933|         2|  1.28746e-05|   6.4373e-06|  0.00%|    def __and__(self, other):
   934|         2|  3.67165e-05|  1.83582e-05|  0.00%|        if not isinstance(other, (self.__class__, int)):
   935|         0|            0|            0|  0.00%|            return NotImplemented
   936|         2|  5.34058e-05|  2.67029e-05|  0.00%|        return self.__class__(self._value_ & self.__class__(other)._value_)
(call)|         4|  0.000206709|  5.16772e-05|  0.00%|# /opt/conda/lib/python3.8/enum.py:313 __call__
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|    def __xor__(self, other):
   939|         0|            0|            0|  0.00%|        if not isinstance(other, (self.__class__, int)):
   940|         0|            0|            0|  0.00%|            return NotImplemented
   941|         0|            0|            0|  0.00%|        return self.__class__(self._value_ ^ self.__class__(other)._value_)
   942|         0|            0|            0|  0.00%|
   943|         0|            0|            0|  0.00%|    __ror__ = __or__
   944|         0|            0|            0|  0.00%|    __rand__ = __and__
   945|         0|            0|            0|  0.00%|    __rxor__ = __xor__
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|    def __invert__(self):
   948|         0|            0|            0|  0.00%|        result = self.__class__(~self._value_)
   949|         0|            0|            0|  0.00%|        return result
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|
   952|         0|            0|            0|  0.00%|def _high_bit(value):
   953|         0|            0|            0|  0.00%|    """
   954|         0|            0|            0|  0.00%|    returns index of highest bit, or -1 if value is zero or negative
   955|         0|            0|            0|  0.00%|    """
   956|         0|            0|            0|  0.00%|    return value.bit_length() - 1
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|def unique(enumeration):
   959|         0|            0|            0|  0.00%|    """
   960|         0|            0|            0|  0.00%|    Class decorator for enumerations ensuring unique member values.
   961|         0|            0|            0|  0.00%|    """
   962|         0|            0|            0|  0.00%|    duplicates = []
   963|         0|            0|            0|  0.00%|    for name, member in enumeration.__members__.items():
   964|         0|            0|            0|  0.00%|        if name != member.name:
   965|         0|            0|            0|  0.00%|            duplicates.append((name, member.name))
   966|         0|            0|            0|  0.00%|    if duplicates:
   967|         0|            0|            0|  0.00%|        alias_details = ', '.join(
   968|         0|            0|            0|  0.00%|                ["%s -> %s" % (alias, name) for (alias, name) in duplicates])
   969|         0|            0|            0|  0.00%|        raise ValueError('duplicate values found in %r: %s' %
   970|         0|            0|            0|  0.00%|                (enumeration, alias_details))
   971|         0|            0|            0|  0.00%|    return enumeration
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|def _decompose(flag, value):
   974|         0|            0|            0|  0.00%|    """
   975|         0|            0|            0|  0.00%|    Extract all members from the value.
   976|         0|            0|            0|  0.00%|    """
   977|         0|            0|            0|  0.00%|    # _decompose is only called if the value is not named
   978|         0|            0|            0|  0.00%|    not_covered = value
   979|         0|            0|            0|  0.00%|    negative = value < 0
   980|         0|            0|            0|  0.00%|    # issue29167: wrap accesses to _value2member_map_ in a list to avoid race
   981|         0|            0|            0|  0.00%|    #             conditions between iterating over it and having more pseudo-
   982|         0|            0|            0|  0.00%|    #             members added to it
   983|         0|            0|            0|  0.00%|    if negative:
   984|         0|            0|            0|  0.00%|        # only check for named flags
   985|         0|            0|            0|  0.00%|        flags_to_check = [
   986|         0|            0|            0|  0.00%|                (m, v)
   987|         0|            0|            0|  0.00%|                for v, m in list(flag._value2member_map_.items())
   988|         0|            0|            0|  0.00%|                if m.name is not None
   989|         0|            0|            0|  0.00%|                ]
   990|         0|            0|            0|  0.00%|    else:
   991|         0|            0|            0|  0.00%|        # check for named flags and powers-of-two flags
   992|         0|            0|            0|  0.00%|        flags_to_check = [
   993|         0|            0|            0|  0.00%|                (m, v)
   994|         0|            0|            0|  0.00%|                for v, m in list(flag._value2member_map_.items())
   995|         0|            0|            0|  0.00%|                if m.name is not None or _power_of_two(v)
   996|         0|            0|            0|  0.00%|                ]
   997|         0|            0|            0|  0.00%|    members = []
   998|         0|            0|            0|  0.00%|    for member, member_value in flags_to_check:
   999|         0|            0|            0|  0.00%|        if member_value and member_value & value == member_value:
  1000|         0|            0|            0|  0.00%|            members.append(member)
  1001|         0|            0|            0|  0.00%|            not_covered &= ~member_value
  1002|         0|            0|            0|  0.00%|    if not members and value in flag._value2member_map_:
  1003|         0|            0|            0|  0.00%|        members.append(flag._value2member_map_[value])
  1004|         0|            0|            0|  0.00%|    members.sort(key=lambda m: m._value_, reverse=True)
  1005|         0|            0|            0|  0.00%|    if len(members) > 1 and members[0].value == value:
  1006|         0|            0|            0|  0.00%|        # we have the breakdown, don't need the value member itself
  1007|         0|            0|            0|  0.00%|        members.pop(0)
  1008|         0|            0|            0|  0.00%|    return members, not_covered
  1009|         0|            0|            0|  0.00%|
  1010|         0|            0|            0|  0.00%|def _power_of_two(value):
  1011|         0|            0|            0|  0.00%|    if value < 1:
  1012|         0|            0|            0|  0.00%|        return False
  1013|         0|            0|            0|  0.00%|    return value == 2 ** _high_bit(value)
File: /opt/conda/lib/python3.8/linecache.py
File duration: 0.000225067s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Cache lines from Python source files.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This is intended to read lines from modules imported -- hence if a filename
     4|         0|            0|            0|  0.00%|is not found, it will look down the module search path for a file by
     5|         0|            0|            0|  0.00%|that name.
     6|         0|            0|            0|  0.00%|"""
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import functools
     9|         0|            0|            0|  0.00%|import sys
    10|         0|            0|            0|  0.00%|import os
    11|         0|            0|            0|  0.00%|import tokenize
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|__all__ = ["getline", "clearcache", "checkcache"]
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|def getline(filename, lineno, module_globals=None):
    16|         0|            0|            0|  0.00%|    lines = getlines(filename, module_globals)
    17|         0|            0|            0|  0.00%|    if 1 <= lineno <= len(lines):
    18|         0|            0|            0|  0.00%|        return lines[lineno-1]
    19|         0|            0|            0|  0.00%|    else:
    20|         0|            0|            0|  0.00%|        return ''
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|# The cache
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# The cache. Maps filenames to either a thunk which will provide source code,
    26|         0|            0|            0|  0.00%|# or a tuple (size, mtime, lines, fullname) once loaded.
    27|         0|            0|            0|  0.00%|cache = {}
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|def clearcache():
    31|         0|            0|            0|  0.00%|    """Clear the cache entirely."""
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|    global cache
    34|         0|            0|            0|  0.00%|    cache = {}
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         2|  2.86102e-05|  1.43051e-05|  0.00%|def getlines(filename, module_globals=None):
    38|         0|            0|            0|  0.00%|    """Get the lines for a Python source file from the cache.
    39|         0|            0|            0|  0.00%|    Update the cache if it doesn't contain an entry for this file already."""
    40|         0|            0|            0|  0.00%|
    41|         2|  2.38419e-05|  1.19209e-05|  0.00%|    if filename in cache:
    42|         2|  1.12057e-05|  5.60284e-06|  0.00%|        entry = cache[filename]
    43|         2|  1.93119e-05|  9.65595e-06|  0.00%|        if len(entry) != 1:
    44|         2|  1.09673e-05|  5.48363e-06|  0.00%|            return cache[filename][2]
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    try:
    47|         0|            0|            0|  0.00%|        return updatecache(filename, module_globals)
    48|         0|            0|            0|  0.00%|    except MemoryError:
    49|         0|            0|            0|  0.00%|        clearcache()
    50|         0|            0|            0|  0.00%|        return []
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         1|  1.00136e-05|  1.00136e-05|  0.00%|def checkcache(filename=None):
    54|         0|            0|            0|  0.00%|    """Discard cache entries that are out of date.
    55|         0|            0|            0|  0.00%|    (This is not checked upon each call!)"""
    56|         0|            0|            0|  0.00%|
    57|         1|  1.74046e-05|  1.74046e-05|  0.00%|    if filename is None:
    58|         0|            0|            0|  0.00%|        filenames = list(cache.keys())
    59|         0|            0|            0|  0.00%|    else:
    60|         1|  7.62939e-06|  7.62939e-06|  0.00%|        if filename in cache:
    61|         1|   6.4373e-06|   6.4373e-06|  0.00%|            filenames = [filename]
    62|         0|            0|            0|  0.00%|        else:
    63|         0|            0|            0|  0.00%|            return
    64|         0|            0|            0|  0.00%|
    65|         2|  1.26362e-05|  6.31809e-06|  0.00%|    for filename in filenames:
    66|         1|  1.16825e-05|  1.16825e-05|  0.00%|        entry = cache[filename]
    67|         1|  1.16825e-05|  1.16825e-05|  0.00%|        if len(entry) == 1:
    68|         0|            0|            0|  0.00%|            # lazy cache entry, leave it lazy.
    69|         0|            0|            0|  0.00%|            continue
    70|         1|  1.54972e-05|  1.54972e-05|  0.00%|        size, mtime, lines, fullname = entry
    71|         1|  6.67572e-06|  6.67572e-06|  0.00%|        if mtime is None:
    72|         0|            0|            0|  0.00%|            continue   # no-op for files loaded via a __loader__
    73|         1|  5.96046e-06|  5.96046e-06|  0.00%|        try:
    74|         1|  1.64509e-05|  1.64509e-05|  0.00%|            stat = os.stat(fullname)
    75|         0|            0|            0|  0.00%|        except OSError:
    76|         0|            0|            0|  0.00%|            cache.pop(filename, None)
    77|         0|            0|            0|  0.00%|            continue
    78|         1|  9.05991e-06|  9.05991e-06|  0.00%|        if size != stat.st_size or mtime != stat.st_mtime:
    79|         0|            0|            0|  0.00%|            cache.pop(filename, None)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|def updatecache(filename, module_globals=None):
    83|         0|            0|            0|  0.00%|    """Update a cache entry and return its list of lines.
    84|         0|            0|            0|  0.00%|    If something's wrong, print a message, discard the cache entry,
    85|         0|            0|            0|  0.00%|    and return an empty list."""
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    if filename in cache:
    88|         0|            0|            0|  0.00%|        if len(cache[filename]) != 1:
    89|         0|            0|            0|  0.00%|            cache.pop(filename, None)
    90|         0|            0|            0|  0.00%|    if not filename or (filename.startswith('<') and filename.endswith('>')):
    91|         0|            0|            0|  0.00%|        return []
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    fullname = filename
    94|         0|            0|            0|  0.00%|    try:
    95|         0|            0|            0|  0.00%|        stat = os.stat(fullname)
    96|         0|            0|            0|  0.00%|    except OSError:
    97|         0|            0|            0|  0.00%|        basename = filename
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|        # Realise a lazy loader based lookup if there is one
   100|         0|            0|            0|  0.00%|        # otherwise try to lookup right now.
   101|         0|            0|            0|  0.00%|        if lazycache(filename, module_globals):
   102|         0|            0|            0|  0.00%|            try:
   103|         0|            0|            0|  0.00%|                data = cache[filename][0]()
   104|         0|            0|            0|  0.00%|            except (ImportError, OSError):
   105|         0|            0|            0|  0.00%|                pass
   106|         0|            0|            0|  0.00%|            else:
   107|         0|            0|            0|  0.00%|                if data is None:
   108|         0|            0|            0|  0.00%|                    # No luck, the PEP302 loader cannot find the source
   109|         0|            0|            0|  0.00%|                    # for this module.
   110|         0|            0|            0|  0.00%|                    return []
   111|         0|            0|            0|  0.00%|                cache[filename] = (
   112|         0|            0|            0|  0.00%|                    len(data), None,
   113|         0|            0|            0|  0.00%|                    [line+'\n' for line in data.splitlines()], fullname
   114|         0|            0|            0|  0.00%|                )
   115|         0|            0|            0|  0.00%|                return cache[filename][2]
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|        # Try looking through the module search path, which is only useful
   118|         0|            0|            0|  0.00%|        # when handling a relative filename.
   119|         0|            0|            0|  0.00%|        if os.path.isabs(filename):
   120|         0|            0|            0|  0.00%|            return []
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|        for dirname in sys.path:
   123|         0|            0|            0|  0.00%|            try:
   124|         0|            0|            0|  0.00%|                fullname = os.path.join(dirname, basename)
   125|         0|            0|            0|  0.00%|            except (TypeError, AttributeError):
   126|         0|            0|            0|  0.00%|                # Not sufficiently string-like to do anything useful with.
   127|         0|            0|            0|  0.00%|                continue
   128|         0|            0|            0|  0.00%|            try:
   129|         0|            0|            0|  0.00%|                stat = os.stat(fullname)
   130|         0|            0|            0|  0.00%|                break
   131|         0|            0|            0|  0.00%|            except OSError:
   132|         0|            0|            0|  0.00%|                pass
   133|         0|            0|            0|  0.00%|        else:
   134|         0|            0|            0|  0.00%|            return []
   135|         0|            0|            0|  0.00%|    try:
   136|         0|            0|            0|  0.00%|        with tokenize.open(fullname) as fp:
   137|         0|            0|            0|  0.00%|            lines = fp.readlines()
   138|         0|            0|            0|  0.00%|    except OSError:
   139|         0|            0|            0|  0.00%|        return []
   140|         0|            0|            0|  0.00%|    if lines and not lines[-1].endswith('\n'):
   141|         0|            0|            0|  0.00%|        lines[-1] += '\n'
   142|         0|            0|            0|  0.00%|    size, mtime = stat.st_size, stat.st_mtime
   143|         0|            0|            0|  0.00%|    cache[filename] = size, mtime, lines, fullname
   144|         0|            0|            0|  0.00%|    return lines
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|def lazycache(filename, module_globals):
   148|         0|            0|            0|  0.00%|    """Seed the cache for filename with module_globals.
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    The module loader will be asked for the source only when getlines is
   151|         0|            0|            0|  0.00%|    called, not immediately.
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    If there is an entry in the cache already, it is not altered.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    :return: True if a lazy load is registered in the cache,
   156|         0|            0|            0|  0.00%|        otherwise False. To register such a load a module loader with a
   157|         0|            0|            0|  0.00%|        get_source method must be found, the filename must be a cachable
   158|         0|            0|            0|  0.00%|        filename, and the filename must not be already cached.
   159|         0|            0|            0|  0.00%|    """
   160|         0|            0|            0|  0.00%|    if filename in cache:
   161|         0|            0|            0|  0.00%|        if len(cache[filename]) == 1:
   162|         0|            0|            0|  0.00%|            return True
   163|         0|            0|            0|  0.00%|        else:
   164|         0|            0|            0|  0.00%|            return False
   165|         0|            0|            0|  0.00%|    if not filename or (filename.startswith('<') and filename.endswith('>')):
   166|         0|            0|            0|  0.00%|        return False
   167|         0|            0|            0|  0.00%|    # Try for a __loader__, if available
   168|         0|            0|            0|  0.00%|    if module_globals and '__loader__' in module_globals:
   169|         0|            0|            0|  0.00%|        name = module_globals.get('__name__')
   170|         0|            0|            0|  0.00%|        loader = module_globals['__loader__']
   171|         0|            0|            0|  0.00%|        get_source = getattr(loader, 'get_source', None)
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        if name and get_source:
   174|         0|            0|            0|  0.00%|            get_lines = functools.partial(get_source, name)
   175|         0|            0|            0|  0.00%|            cache[filename] = (get_lines,)
   176|         0|            0|            0|  0.00%|            return True
   177|         0|            0|            0|  0.00%|    return False
File: /opt/conda/lib/python3.8/contextlib.py
File duration: 0.000167847s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Utilities for with-statement contexts.  See PEP 343."""
     2|         0|            0|            0|  0.00%|import abc
     3|         0|            0|            0|  0.00%|import sys
     4|         0|            0|            0|  0.00%|import _collections_abc
     5|         0|            0|            0|  0.00%|from collections import deque
     6|         0|            0|            0|  0.00%|from functools import wraps
     7|         0|            0|            0|  0.00%|from types import MethodType
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|__all__ = ["asynccontextmanager", "contextmanager", "closing", "nullcontext",
    10|         0|            0|            0|  0.00%|           "AbstractContextManager", "AbstractAsyncContextManager",
    11|         0|            0|            0|  0.00%|           "AsyncExitStack", "ContextDecorator", "ExitStack",
    12|         0|            0|            0|  0.00%|           "redirect_stdout", "redirect_stderr", "suppress"]
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|class AbstractContextManager(abc.ABC):
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|    """An abstract base class for context managers."""
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|    def __enter__(self):
    20|         0|            0|            0|  0.00%|        """Return `self` upon entering the runtime context."""
    21|         0|            0|            0|  0.00%|        return self
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|    @abc.abstractmethod
    24|         0|            0|            0|  0.00%|    def __exit__(self, exc_type, exc_value, traceback):
    25|         0|            0|            0|  0.00%|        """Raise any exception triggered within the runtime context."""
    26|         0|            0|            0|  0.00%|        return None
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|    @classmethod
    29|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
    30|         0|            0|            0|  0.00%|        if cls is AbstractContextManager:
    31|         0|            0|            0|  0.00%|            return _collections_abc._check_methods(C, "__enter__", "__exit__")
    32|         0|            0|            0|  0.00%|        return NotImplemented
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|class AbstractAsyncContextManager(abc.ABC):
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|    """An abstract base class for asynchronous context managers."""
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    async def __aenter__(self):
    40|         0|            0|            0|  0.00%|        """Return `self` upon entering the runtime context."""
    41|         0|            0|            0|  0.00%|        return self
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|    @abc.abstractmethod
    44|         0|            0|            0|  0.00%|    async def __aexit__(self, exc_type, exc_value, traceback):
    45|         0|            0|            0|  0.00%|        """Raise any exception triggered within the runtime context."""
    46|         0|            0|            0|  0.00%|        return None
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|    @classmethod
    49|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
    50|         0|            0|            0|  0.00%|        if cls is AbstractAsyncContextManager:
    51|         0|            0|            0|  0.00%|            return _collections_abc._check_methods(C, "__aenter__",
    52|         0|            0|            0|  0.00%|                                                   "__aexit__")
    53|         0|            0|            0|  0.00%|        return NotImplemented
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|class ContextDecorator(object):
    57|         0|            0|            0|  0.00%|    "A base class or mixin that enables context managers to work as decorators."
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    def _recreate_cm(self):
    60|         0|            0|            0|  0.00%|        """Return a recreated instance of self.
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|        Allows an otherwise one-shot context manager like
    63|         0|            0|            0|  0.00%|        _GeneratorContextManager to support use as
    64|         0|            0|            0|  0.00%|        a decorator via implicit recreation.
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|        This is a private interface just for _GeneratorContextManager.
    67|         0|            0|            0|  0.00%|        See issue #11647 for details.
    68|         0|            0|            0|  0.00%|        """
    69|         0|            0|            0|  0.00%|        return self
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    def __call__(self, func):
    72|         0|            0|            0|  0.00%|        @wraps(func)
    73|         0|            0|            0|  0.00%|        def inner(*args, **kwds):
    74|         0|            0|            0|  0.00%|            with self._recreate_cm():
    75|         0|            0|            0|  0.00%|                return func(*args, **kwds)
    76|         0|            0|            0|  0.00%|        return inner
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|class _GeneratorContextManagerBase:
    80|         0|            0|            0|  0.00%|    """Shared functionality for @contextmanager and @asynccontextmanager."""
    81|         0|            0|            0|  0.00%|
    82|         1|  7.86781e-06|  7.86781e-06|  0.00%|    def __init__(self, func, args, kwds):
    83|         1|  7.86781e-06|  7.86781e-06|  0.00%|        self.gen = func(*args, **kwds)
    84|         1|  7.86781e-06|  7.86781e-06|  0.00%|        self.func, self.args, self.kwds = func, args, kwds
    85|         0|            0|            0|  0.00%|        # Issue 19330: ensure context manager instances have good docstrings
    86|         1|  7.86781e-06|  7.86781e-06|  0.00%|        doc = getattr(func, "__doc__", None)
    87|         1|  1.38283e-05|  1.38283e-05|  0.00%|        if doc is None:
    88|         1|  1.71661e-05|  1.71661e-05|  0.00%|            doc = type(self).__doc__
    89|         1|  6.67572e-06|  6.67572e-06|  0.00%|        self.__doc__ = doc
    90|         0|            0|            0|  0.00%|        # Unfortunately, this still doesn't provide good help output when
    91|         0|            0|            0|  0.00%|        # inspecting the created context manager instances, since pydoc
    92|         0|            0|            0|  0.00%|        # currently bypasses the instance docstring and shows the docstring
    93|         0|            0|            0|  0.00%|        # for the class instead.
    94|         0|            0|            0|  0.00%|        # See http://bugs.python.org/issue19404 for more details.
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|class _GeneratorContextManager(_GeneratorContextManagerBase,
    98|         0|            0|            0|  0.00%|                               AbstractContextManager,
    99|         0|            0|            0|  0.00%|                               ContextDecorator):
   100|         0|            0|            0|  0.00%|    """Helper for @contextmanager decorator."""
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    def _recreate_cm(self):
   103|         0|            0|            0|  0.00%|        # _GCM instances are one-shot context managers, so the
   104|         0|            0|            0|  0.00%|        # CM must be recreated each time a decorated function is
   105|         0|            0|            0|  0.00%|        # called
   106|         0|            0|            0|  0.00%|        return self.__class__(self.func, self.args, self.kwds)
   107|         0|            0|            0|  0.00%|
   108|         1|  1.16825e-05|  1.16825e-05|  0.00%|    def __enter__(self):
   109|         0|            0|            0|  0.00%|        # do not keep args and kwds alive unnecessarily
   110|         0|            0|            0|  0.00%|        # they are only needed for recreation, which is not possible anymore
   111|         1|  6.91414e-06|  6.91414e-06|  0.00%|        del self.args, self.kwds, self.func
   112|         1|  5.72205e-06|  5.72205e-06|  0.00%|        try:
   113|         1|  2.12193e-05|  2.12193e-05|  0.00%|            return next(self.gen)
(call)|         1|  0.000103235|  0.000103235|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:697 _count_ctxmgr
   114|         0|            0|            0|  0.00%|        except StopIteration:
   115|         0|            0|            0|  0.00%|            raise RuntimeError("generator didn't yield") from None
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|    def __exit__(self, type, value, traceback):
   118|         0|            0|            0|  0.00%|        if type is None:
   119|         0|            0|            0|  0.00%|            try:
   120|         0|            0|            0|  0.00%|                next(self.gen)
   121|         0|            0|            0|  0.00%|            except StopIteration:
   122|         0|            0|            0|  0.00%|                return False
   123|         0|            0|            0|  0.00%|            else:
   124|         0|            0|            0|  0.00%|                raise RuntimeError("generator didn't stop")
   125|         0|            0|            0|  0.00%|        else:
   126|         0|            0|            0|  0.00%|            if value is None:
   127|         0|            0|            0|  0.00%|                # Need to force instantiation so we can reliably
   128|         0|            0|            0|  0.00%|                # tell if we get the same exception back
   129|         0|            0|            0|  0.00%|                value = type()
   130|         0|            0|            0|  0.00%|            try:
   131|         0|            0|            0|  0.00%|                self.gen.throw(type, value, traceback)
   132|         0|            0|            0|  0.00%|            except StopIteration as exc:
   133|         0|            0|            0|  0.00%|                # Suppress StopIteration *unless* it's the same exception that
   134|         0|            0|            0|  0.00%|                # was passed to throw().  This prevents a StopIteration
   135|         0|            0|            0|  0.00%|                # raised inside the "with" statement from being suppressed.
   136|         0|            0|            0|  0.00%|                return exc is not value
   137|         0|            0|            0|  0.00%|            except RuntimeError as exc:
   138|         0|            0|            0|  0.00%|                # Don't re-raise the passed in exception. (issue27122)
   139|         0|            0|            0|  0.00%|                if exc is value:
   140|         0|            0|            0|  0.00%|                    return False
   141|         0|            0|            0|  0.00%|                # Likewise, avoid suppressing if a StopIteration exception
   142|         0|            0|            0|  0.00%|                # was passed to throw() and later wrapped into a RuntimeError
   143|         0|            0|            0|  0.00%|                # (see PEP 479).
   144|         0|            0|            0|  0.00%|                if type is StopIteration and exc.__cause__ is value:
   145|         0|            0|            0|  0.00%|                    return False
   146|         0|            0|            0|  0.00%|                raise
   147|         0|            0|            0|  0.00%|            except:
   148|         0|            0|            0|  0.00%|                # only re-raise if it's *not* the exception that was
   149|         0|            0|            0|  0.00%|                # passed to throw(), because __exit__() must not raise
   150|         0|            0|            0|  0.00%|                # an exception unless __exit__() itself failed.  But throw()
   151|         0|            0|            0|  0.00%|                # has to raise the exception to signal propagation, so this
   152|         0|            0|            0|  0.00%|                # fixes the impedance mismatch between the throw() protocol
   153|         0|            0|            0|  0.00%|                # and the __exit__() protocol.
   154|         0|            0|            0|  0.00%|                #
   155|         0|            0|            0|  0.00%|                # This cannot use 'except BaseException as exc' (as in the
   156|         0|            0|            0|  0.00%|                # async implementation) to maintain compatibility with
   157|         0|            0|            0|  0.00%|                # Python 2, where old-style class exceptions are not caught
   158|         0|            0|            0|  0.00%|                # by 'except BaseException'.
   159|         0|            0|            0|  0.00%|                if sys.exc_info()[1] is value:
   160|         0|            0|            0|  0.00%|                    return False
   161|         0|            0|            0|  0.00%|                raise
   162|         0|            0|            0|  0.00%|            raise RuntimeError("generator didn't stop after throw()")
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|class _AsyncGeneratorContextManager(_GeneratorContextManagerBase,
   166|         0|            0|            0|  0.00%|                                    AbstractAsyncContextManager):
   167|         0|            0|            0|  0.00%|    """Helper for @asynccontextmanager."""
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|    async def __aenter__(self):
   170|         0|            0|            0|  0.00%|        try:
   171|         0|            0|            0|  0.00%|            return await self.gen.__anext__()
   172|         0|            0|            0|  0.00%|        except StopAsyncIteration:
   173|         0|            0|            0|  0.00%|            raise RuntimeError("generator didn't yield") from None
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    async def __aexit__(self, typ, value, traceback):
   176|         0|            0|            0|  0.00%|        if typ is None:
   177|         0|            0|            0|  0.00%|            try:
   178|         0|            0|            0|  0.00%|                await self.gen.__anext__()
   179|         0|            0|            0|  0.00%|            except StopAsyncIteration:
   180|         0|            0|            0|  0.00%|                return
   181|         0|            0|            0|  0.00%|            else:
   182|         0|            0|            0|  0.00%|                raise RuntimeError("generator didn't stop")
   183|         0|            0|            0|  0.00%|        else:
   184|         0|            0|            0|  0.00%|            if value is None:
   185|         0|            0|            0|  0.00%|                value = typ()
   186|         0|            0|            0|  0.00%|            # See _GeneratorContextManager.__exit__ for comments on subtleties
   187|         0|            0|            0|  0.00%|            # in this implementation
   188|         0|            0|            0|  0.00%|            try:
   189|         0|            0|            0|  0.00%|                await self.gen.athrow(typ, value, traceback)
   190|         0|            0|            0|  0.00%|                raise RuntimeError("generator didn't stop after athrow()")
   191|         0|            0|            0|  0.00%|            except StopAsyncIteration as exc:
   192|         0|            0|            0|  0.00%|                return exc is not value
   193|         0|            0|            0|  0.00%|            except RuntimeError as exc:
   194|         0|            0|            0|  0.00%|                if exc is value:
   195|         0|            0|            0|  0.00%|                    return False
   196|         0|            0|            0|  0.00%|                # Avoid suppressing if a StopIteration exception
   197|         0|            0|            0|  0.00%|                # was passed to throw() and later wrapped into a RuntimeError
   198|         0|            0|            0|  0.00%|                # (see PEP 479 for sync generators; async generators also
   199|         0|            0|            0|  0.00%|                # have this behavior). But do this only if the exception wrapped
   200|         0|            0|            0|  0.00%|                # by the RuntimeError is actully Stop(Async)Iteration (see
   201|         0|            0|            0|  0.00%|                # issue29692).
   202|         0|            0|            0|  0.00%|                if isinstance(value, (StopIteration, StopAsyncIteration)):
   203|         0|            0|            0|  0.00%|                    if exc.__cause__ is value:
   204|         0|            0|            0|  0.00%|                        return False
   205|         0|            0|            0|  0.00%|                raise
   206|         0|            0|            0|  0.00%|            except BaseException as exc:
   207|         0|            0|            0|  0.00%|                if exc is not value:
   208|         0|            0|            0|  0.00%|                    raise
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|def contextmanager(func):
   212|         0|            0|            0|  0.00%|    """@contextmanager decorator.
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    Typical usage:
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|        @contextmanager
   217|         0|            0|            0|  0.00%|        def some_generator(<arguments>):
   218|         0|            0|            0|  0.00%|            <setup>
   219|         0|            0|            0|  0.00%|            try:
   220|         0|            0|            0|  0.00%|                yield <value>
   221|         0|            0|            0|  0.00%|            finally:
   222|         0|            0|            0|  0.00%|                <cleanup>
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    This makes this:
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        with some_generator(<arguments>) as <variable>:
   227|         0|            0|            0|  0.00%|            <body>
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|    equivalent to this:
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|        <setup>
   232|         0|            0|            0|  0.00%|        try:
   233|         0|            0|            0|  0.00%|            <variable> = <value>
   234|         0|            0|            0|  0.00%|            <body>
   235|         0|            0|            0|  0.00%|        finally:
   236|         0|            0|            0|  0.00%|            <cleanup>
   237|         0|            0|            0|  0.00%|    """
   238|         1|  1.07288e-05|  1.07288e-05|  0.00%|    @wraps(func)
   239|         0|            0|            0|  0.00%|    def helper(*args, **kwds):
   240|         1|  4.24385e-05|  4.24385e-05|  0.00%|        return _GeneratorContextManager(func, args, kwds)
(call)|         1|  6.91414e-05|  6.91414e-05|  0.00%|# /opt/conda/lib/python3.8/contextlib.py:82 __init__
   241|         0|            0|            0|  0.00%|    return helper
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|def asynccontextmanager(func):
   245|         0|            0|            0|  0.00%|    """@asynccontextmanager decorator.
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    Typical usage:
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|        @asynccontextmanager
   250|         0|            0|            0|  0.00%|        async def some_async_generator(<arguments>):
   251|         0|            0|            0|  0.00%|            <setup>
   252|         0|            0|            0|  0.00%|            try:
   253|         0|            0|            0|  0.00%|                yield <value>
   254|         0|            0|            0|  0.00%|            finally:
   255|         0|            0|            0|  0.00%|                <cleanup>
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    This makes this:
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|        async with some_async_generator(<arguments>) as <variable>:
   260|         0|            0|            0|  0.00%|            <body>
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    equivalent to this:
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|        <setup>
   265|         0|            0|            0|  0.00%|        try:
   266|         0|            0|            0|  0.00%|            <variable> = <value>
   267|         0|            0|            0|  0.00%|            <body>
   268|         0|            0|            0|  0.00%|        finally:
   269|         0|            0|            0|  0.00%|            <cleanup>
   270|         0|            0|            0|  0.00%|    """
   271|         0|            0|            0|  0.00%|    @wraps(func)
   272|         0|            0|            0|  0.00%|    def helper(*args, **kwds):
   273|         0|            0|            0|  0.00%|        return _AsyncGeneratorContextManager(func, args, kwds)
   274|         0|            0|            0|  0.00%|    return helper
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|class closing(AbstractContextManager):
   278|         0|            0|            0|  0.00%|    """Context to automatically close something at the end of a block.
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|    Code like this:
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|        with closing(<module>.open(<arguments>)) as f:
   283|         0|            0|            0|  0.00%|            <block>
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    is equivalent to this:
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        f = <module>.open(<arguments>)
   288|         0|            0|            0|  0.00%|        try:
   289|         0|            0|            0|  0.00%|            <block>
   290|         0|            0|            0|  0.00%|        finally:
   291|         0|            0|            0|  0.00%|            f.close()
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    """
   294|         0|            0|            0|  0.00%|    def __init__(self, thing):
   295|         0|            0|            0|  0.00%|        self.thing = thing
   296|         0|            0|            0|  0.00%|    def __enter__(self):
   297|         0|            0|            0|  0.00%|        return self.thing
   298|         0|            0|            0|  0.00%|    def __exit__(self, *exc_info):
   299|         0|            0|            0|  0.00%|        self.thing.close()
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|class _RedirectStream(AbstractContextManager):
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    _stream = None
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|    def __init__(self, new_target):
   307|         0|            0|            0|  0.00%|        self._new_target = new_target
   308|         0|            0|            0|  0.00%|        # We use a list of old targets to make this CM re-entrant
   309|         0|            0|            0|  0.00%|        self._old_targets = []
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    def __enter__(self):
   312|         0|            0|            0|  0.00%|        self._old_targets.append(getattr(sys, self._stream))
   313|         0|            0|            0|  0.00%|        setattr(sys, self._stream, self._new_target)
   314|         0|            0|            0|  0.00%|        return self._new_target
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    def __exit__(self, exctype, excinst, exctb):
   317|         0|            0|            0|  0.00%|        setattr(sys, self._stream, self._old_targets.pop())
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|class redirect_stdout(_RedirectStream):
   321|         0|            0|            0|  0.00%|    """Context manager for temporarily redirecting stdout to another file.
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|        # How to send help() to stderr
   324|         0|            0|            0|  0.00%|        with redirect_stdout(sys.stderr):
   325|         0|            0|            0|  0.00%|            help(dir)
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|        # How to write help() to a file
   328|         0|            0|            0|  0.00%|        with open('help.txt', 'w') as f:
   329|         0|            0|            0|  0.00%|            with redirect_stdout(f):
   330|         0|            0|            0|  0.00%|                help(pow)
   331|         0|            0|            0|  0.00%|    """
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    _stream = "stdout"
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|class redirect_stderr(_RedirectStream):
   337|         0|            0|            0|  0.00%|    """Context manager for temporarily redirecting stderr to another file."""
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    _stream = "stderr"
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|class suppress(AbstractContextManager):
   343|         0|            0|            0|  0.00%|    """Context manager to suppress specified exceptions
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    After the exception is suppressed, execution proceeds with the next
   346|         0|            0|            0|  0.00%|    statement following the with statement.
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|         with suppress(FileNotFoundError):
   349|         0|            0|            0|  0.00%|             os.remove(somefile)
   350|         0|            0|            0|  0.00%|         # Execution still resumes here if the file was already removed
   351|         0|            0|            0|  0.00%|    """
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|    def __init__(self, *exceptions):
   354|         0|            0|            0|  0.00%|        self._exceptions = exceptions
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|    def __enter__(self):
   357|         0|            0|            0|  0.00%|        pass
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    def __exit__(self, exctype, excinst, exctb):
   360|         0|            0|            0|  0.00%|        # Unlike isinstance and issubclass, CPython exception handling
   361|         0|            0|            0|  0.00%|        # currently only looks at the concrete type hierarchy (ignoring
   362|         0|            0|            0|  0.00%|        # the instance and subclass checking hooks). While Guido considers
   363|         0|            0|            0|  0.00%|        # that a bug rather than a feature, it's a fairly hard one to fix
   364|         0|            0|            0|  0.00%|        # due to various internal implementation details. suppress provides
   365|         0|            0|            0|  0.00%|        # the simpler issubclass based semantics, rather than trying to
   366|         0|            0|            0|  0.00%|        # exactly reproduce the limitations of the CPython interpreter.
   367|         0|            0|            0|  0.00%|        #
   368|         0|            0|            0|  0.00%|        # See http://bugs.python.org/issue12029 for more details
   369|         0|            0|            0|  0.00%|        return exctype is not None and issubclass(exctype, self._exceptions)
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|class _BaseExitStack:
   373|         0|            0|            0|  0.00%|    """A base class for ExitStack and AsyncExitStack."""
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|    @staticmethod
   376|         0|            0|            0|  0.00%|    def _create_exit_wrapper(cm, cm_exit):
   377|         0|            0|            0|  0.00%|        return MethodType(cm_exit, cm)
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    @staticmethod
   380|         0|            0|            0|  0.00%|    def _create_cb_wrapper(callback, /, *args, **kwds):
   381|         0|            0|            0|  0.00%|        def _exit_wrapper(exc_type, exc, tb):
   382|         0|            0|            0|  0.00%|            callback(*args, **kwds)
   383|         0|            0|            0|  0.00%|        return _exit_wrapper
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    def __init__(self):
   386|         0|            0|            0|  0.00%|        self._exit_callbacks = deque()
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    def pop_all(self):
   389|         0|            0|            0|  0.00%|        """Preserve the context stack by transferring it to a new instance."""
   390|         0|            0|            0|  0.00%|        new_stack = type(self)()
   391|         0|            0|            0|  0.00%|        new_stack._exit_callbacks = self._exit_callbacks
   392|         0|            0|            0|  0.00%|        self._exit_callbacks = deque()
   393|         0|            0|            0|  0.00%|        return new_stack
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    def push(self, exit):
   396|         0|            0|            0|  0.00%|        """Registers a callback with the standard __exit__ method signature.
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|        Can suppress exceptions the same way __exit__ method can.
   399|         0|            0|            0|  0.00%|        Also accepts any object with an __exit__ method (registering a call
   400|         0|            0|            0|  0.00%|        to the method instead of the object itself).
   401|         0|            0|            0|  0.00%|        """
   402|         0|            0|            0|  0.00%|        # We use an unbound method rather than a bound method to follow
   403|         0|            0|            0|  0.00%|        # the standard lookup behaviour for special methods.
   404|         0|            0|            0|  0.00%|        _cb_type = type(exit)
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|        try:
   407|         0|            0|            0|  0.00%|            exit_method = _cb_type.__exit__
   408|         0|            0|            0|  0.00%|        except AttributeError:
   409|         0|            0|            0|  0.00%|            # Not a context manager, so assume it's a callable.
   410|         0|            0|            0|  0.00%|            self._push_exit_callback(exit)
   411|         0|            0|            0|  0.00%|        else:
   412|         0|            0|            0|  0.00%|            self._push_cm_exit(exit, exit_method)
   413|         0|            0|            0|  0.00%|        return exit  # Allow use as a decorator.
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    def enter_context(self, cm):
   416|         0|            0|            0|  0.00%|        """Enters the supplied context manager.
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|        If successful, also pushes its __exit__ method as a callback and
   419|         0|            0|            0|  0.00%|        returns the result of the __enter__ method.
   420|         0|            0|            0|  0.00%|        """
   421|         0|            0|            0|  0.00%|        # We look up the special methods on the type to match the with
   422|         0|            0|            0|  0.00%|        # statement.
   423|         0|            0|            0|  0.00%|        _cm_type = type(cm)
   424|         0|            0|            0|  0.00%|        _exit = _cm_type.__exit__
   425|         0|            0|            0|  0.00%|        result = _cm_type.__enter__(cm)
   426|         0|            0|            0|  0.00%|        self._push_cm_exit(cm, _exit)
   427|         0|            0|            0|  0.00%|        return result
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    def callback(*args, **kwds):
   430|         0|            0|            0|  0.00%|        """Registers an arbitrary callback and arguments.
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|        Cannot suppress exceptions.
   433|         0|            0|            0|  0.00%|        """
   434|         0|            0|            0|  0.00%|        if len(args) >= 2:
   435|         0|            0|            0|  0.00%|            self, callback, *args = args
   436|         0|            0|            0|  0.00%|        elif not args:
   437|         0|            0|            0|  0.00%|            raise TypeError("descriptor 'callback' of '_BaseExitStack' object "
   438|         0|            0|            0|  0.00%|                            "needs an argument")
   439|         0|            0|            0|  0.00%|        elif 'callback' in kwds:
   440|         0|            0|            0|  0.00%|            callback = kwds.pop('callback')
   441|         0|            0|            0|  0.00%|            self, *args = args
   442|         0|            0|            0|  0.00%|            import warnings
   443|         0|            0|            0|  0.00%|            warnings.warn("Passing 'callback' as keyword argument is deprecated",
   444|         0|            0|            0|  0.00%|                          DeprecationWarning, stacklevel=2)
   445|         0|            0|            0|  0.00%|        else:
   446|         0|            0|            0|  0.00%|            raise TypeError('callback expected at least 1 positional argument, '
   447|         0|            0|            0|  0.00%|                            'got %d' % (len(args)-1))
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_cb_wrapper(callback, *args, **kwds)
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|        # We changed the signature, so using @wraps is not appropriate, but
   452|         0|            0|            0|  0.00%|        # setting __wrapped__ may still help with introspection.
   453|         0|            0|            0|  0.00%|        _exit_wrapper.__wrapped__ = callback
   454|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper)
   455|         0|            0|            0|  0.00%|        return callback  # Allow use as a decorator
   456|         0|            0|            0|  0.00%|    callback.__text_signature__ = '($self, callback, /, *args, **kwds)'
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|    def _push_cm_exit(self, cm, cm_exit):
   459|         0|            0|            0|  0.00%|        """Helper to correctly register callbacks to __exit__ methods."""
   460|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_exit_wrapper(cm, cm_exit)
   461|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper, True)
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    def _push_exit_callback(self, callback, is_sync=True):
   464|         0|            0|            0|  0.00%|        self._exit_callbacks.append((is_sync, callback))
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|# Inspired by discussions on http://bugs.python.org/issue13585
   468|         0|            0|            0|  0.00%|class ExitStack(_BaseExitStack, AbstractContextManager):
   469|         0|            0|            0|  0.00%|    """Context manager for dynamic management of a stack of exit callbacks.
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|    For example:
   472|         0|            0|            0|  0.00%|        with ExitStack() as stack:
   473|         0|            0|            0|  0.00%|            files = [stack.enter_context(open(fname)) for fname in filenames]
   474|         0|            0|            0|  0.00%|            # All opened files will automatically be closed at the end of
   475|         0|            0|            0|  0.00%|            # the with statement, even if attempts to open files later
   476|         0|            0|            0|  0.00%|            # in the list raise an exception.
   477|         0|            0|            0|  0.00%|    """
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|    def __enter__(self):
   480|         0|            0|            0|  0.00%|        return self
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    def __exit__(self, *exc_details):
   483|         0|            0|            0|  0.00%|        received_exc = exc_details[0] is not None
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|        # We manipulate the exception state so it behaves as though
   486|         0|            0|            0|  0.00%|        # we were actually nesting multiple with statements
   487|         0|            0|            0|  0.00%|        frame_exc = sys.exc_info()[1]
   488|         0|            0|            0|  0.00%|        def _fix_exception_context(new_exc, old_exc):
   489|         0|            0|            0|  0.00%|            # Context may not be correct, so find the end of the chain
   490|         0|            0|            0|  0.00%|            while 1:
   491|         0|            0|            0|  0.00%|                exc_context = new_exc.__context__
   492|         0|            0|            0|  0.00%|                if exc_context is old_exc:
   493|         0|            0|            0|  0.00%|                    # Context is already set correctly (see issue 20317)
   494|         0|            0|            0|  0.00%|                    return
   495|         0|            0|            0|  0.00%|                if exc_context is None or exc_context is frame_exc:
   496|         0|            0|            0|  0.00%|                    break
   497|         0|            0|            0|  0.00%|                new_exc = exc_context
   498|         0|            0|            0|  0.00%|            # Change the end of the chain to point to the exception
   499|         0|            0|            0|  0.00%|            # we expect it to reference
   500|         0|            0|            0|  0.00%|            new_exc.__context__ = old_exc
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|        # Callbacks are invoked in LIFO order to match the behaviour of
   503|         0|            0|            0|  0.00%|        # nested context managers
   504|         0|            0|            0|  0.00%|        suppressed_exc = False
   505|         0|            0|            0|  0.00%|        pending_raise = False
   506|         0|            0|            0|  0.00%|        while self._exit_callbacks:
   507|         0|            0|            0|  0.00%|            is_sync, cb = self._exit_callbacks.pop()
   508|         0|            0|            0|  0.00%|            assert is_sync
   509|         0|            0|            0|  0.00%|            try:
   510|         0|            0|            0|  0.00%|                if cb(*exc_details):
   511|         0|            0|            0|  0.00%|                    suppressed_exc = True
   512|         0|            0|            0|  0.00%|                    pending_raise = False
   513|         0|            0|            0|  0.00%|                    exc_details = (None, None, None)
   514|         0|            0|            0|  0.00%|            except:
   515|         0|            0|            0|  0.00%|                new_exc_details = sys.exc_info()
   516|         0|            0|            0|  0.00%|                # simulate the stack of exceptions by setting the context
   517|         0|            0|            0|  0.00%|                _fix_exception_context(new_exc_details[1], exc_details[1])
   518|         0|            0|            0|  0.00%|                pending_raise = True
   519|         0|            0|            0|  0.00%|                exc_details = new_exc_details
   520|         0|            0|            0|  0.00%|        if pending_raise:
   521|         0|            0|            0|  0.00%|            try:
   522|         0|            0|            0|  0.00%|                # bare "raise exc_details[1]" replaces our carefully
   523|         0|            0|            0|  0.00%|                # set-up context
   524|         0|            0|            0|  0.00%|                fixed_ctx = exc_details[1].__context__
   525|         0|            0|            0|  0.00%|                raise exc_details[1]
   526|         0|            0|            0|  0.00%|            except BaseException:
   527|         0|            0|            0|  0.00%|                exc_details[1].__context__ = fixed_ctx
   528|         0|            0|            0|  0.00%|                raise
   529|         0|            0|            0|  0.00%|        return received_exc and suppressed_exc
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    def close(self):
   532|         0|            0|            0|  0.00%|        """Immediately unwind the context stack."""
   533|         0|            0|            0|  0.00%|        self.__exit__(None, None, None)
   534|         0|            0|            0|  0.00%|
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|# Inspired by discussions on https://bugs.python.org/issue29302
   537|         0|            0|            0|  0.00%|class AsyncExitStack(_BaseExitStack, AbstractAsyncContextManager):
   538|         0|            0|            0|  0.00%|    """Async context manager for dynamic management of a stack of exit
   539|         0|            0|            0|  0.00%|    callbacks.
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|    For example:
   542|         0|            0|            0|  0.00%|        async with AsyncExitStack() as stack:
   543|         0|            0|            0|  0.00%|            connections = [await stack.enter_async_context(get_connection())
   544|         0|            0|            0|  0.00%|                for i in range(5)]
   545|         0|            0|            0|  0.00%|            # All opened connections will automatically be released at the
   546|         0|            0|            0|  0.00%|            # end of the async with statement, even if attempts to open a
   547|         0|            0|            0|  0.00%|            # connection later in the list raise an exception.
   548|         0|            0|            0|  0.00%|    """
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|    @staticmethod
   551|         0|            0|            0|  0.00%|    def _create_async_exit_wrapper(cm, cm_exit):
   552|         0|            0|            0|  0.00%|        return MethodType(cm_exit, cm)
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|    @staticmethod
   555|         0|            0|            0|  0.00%|    def _create_async_cb_wrapper(callback, /, *args, **kwds):
   556|         0|            0|            0|  0.00%|        async def _exit_wrapper(exc_type, exc, tb):
   557|         0|            0|            0|  0.00%|            await callback(*args, **kwds)
   558|         0|            0|            0|  0.00%|        return _exit_wrapper
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|    async def enter_async_context(self, cm):
   561|         0|            0|            0|  0.00%|        """Enters the supplied async context manager.
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|        If successful, also pushes its __aexit__ method as a callback and
   564|         0|            0|            0|  0.00%|        returns the result of the __aenter__ method.
   565|         0|            0|            0|  0.00%|        """
   566|         0|            0|            0|  0.00%|        _cm_type = type(cm)
   567|         0|            0|            0|  0.00%|        _exit = _cm_type.__aexit__
   568|         0|            0|            0|  0.00%|        result = await _cm_type.__aenter__(cm)
   569|         0|            0|            0|  0.00%|        self._push_async_cm_exit(cm, _exit)
   570|         0|            0|            0|  0.00%|        return result
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def push_async_exit(self, exit):
   573|         0|            0|            0|  0.00%|        """Registers a coroutine function with the standard __aexit__ method
   574|         0|            0|            0|  0.00%|        signature.
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|        Can suppress exceptions the same way __aexit__ method can.
   577|         0|            0|            0|  0.00%|        Also accepts any object with an __aexit__ method (registering a call
   578|         0|            0|            0|  0.00%|        to the method instead of the object itself).
   579|         0|            0|            0|  0.00%|        """
   580|         0|            0|            0|  0.00%|        _cb_type = type(exit)
   581|         0|            0|            0|  0.00%|        try:
   582|         0|            0|            0|  0.00%|            exit_method = _cb_type.__aexit__
   583|         0|            0|            0|  0.00%|        except AttributeError:
   584|         0|            0|            0|  0.00%|            # Not an async context manager, so assume it's a coroutine function
   585|         0|            0|            0|  0.00%|            self._push_exit_callback(exit, False)
   586|         0|            0|            0|  0.00%|        else:
   587|         0|            0|            0|  0.00%|            self._push_async_cm_exit(exit, exit_method)
   588|         0|            0|            0|  0.00%|        return exit  # Allow use as a decorator
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|    def push_async_callback(*args, **kwds):
   591|         0|            0|            0|  0.00%|        """Registers an arbitrary coroutine function and arguments.
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|        Cannot suppress exceptions.
   594|         0|            0|            0|  0.00%|        """
   595|         0|            0|            0|  0.00%|        if len(args) >= 2:
   596|         0|            0|            0|  0.00%|            self, callback, *args = args
   597|         0|            0|            0|  0.00%|        elif not args:
   598|         0|            0|            0|  0.00%|            raise TypeError("descriptor 'push_async_callback' of "
   599|         0|            0|            0|  0.00%|                            "'AsyncExitStack' object needs an argument")
   600|         0|            0|            0|  0.00%|        elif 'callback' in kwds:
   601|         0|            0|            0|  0.00%|            callback = kwds.pop('callback')
   602|         0|            0|            0|  0.00%|            self, *args = args
   603|         0|            0|            0|  0.00%|            import warnings
   604|         0|            0|            0|  0.00%|            warnings.warn("Passing 'callback' as keyword argument is deprecated",
   605|         0|            0|            0|  0.00%|                          DeprecationWarning, stacklevel=2)
   606|         0|            0|            0|  0.00%|        else:
   607|         0|            0|            0|  0.00%|            raise TypeError('push_async_callback expected at least 1 '
   608|         0|            0|            0|  0.00%|                            'positional argument, got %d' % (len(args)-1))
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_async_cb_wrapper(callback, *args, **kwds)
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|        # We changed the signature, so using @wraps is not appropriate, but
   613|         0|            0|            0|  0.00%|        # setting __wrapped__ may still help with introspection.
   614|         0|            0|            0|  0.00%|        _exit_wrapper.__wrapped__ = callback
   615|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper, False)
   616|         0|            0|            0|  0.00%|        return callback  # Allow use as a decorator
   617|         0|            0|            0|  0.00%|    push_async_callback.__text_signature__ = '($self, callback, /, *args, **kwds)'
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    async def aclose(self):
   620|         0|            0|            0|  0.00%|        """Immediately unwind the context stack."""
   621|         0|            0|            0|  0.00%|        await self.__aexit__(None, None, None)
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    def _push_async_cm_exit(self, cm, cm_exit):
   624|         0|            0|            0|  0.00%|        """Helper to correctly register coroutine function to __aexit__
   625|         0|            0|            0|  0.00%|        method."""
   626|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_async_exit_wrapper(cm, cm_exit)
   627|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper, False)
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|    async def __aenter__(self):
   630|         0|            0|            0|  0.00%|        return self
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|    async def __aexit__(self, *exc_details):
   633|         0|            0|            0|  0.00%|        received_exc = exc_details[0] is not None
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|        # We manipulate the exception state so it behaves as though
   636|         0|            0|            0|  0.00%|        # we were actually nesting multiple with statements
   637|         0|            0|            0|  0.00%|        frame_exc = sys.exc_info()[1]
   638|         0|            0|            0|  0.00%|        def _fix_exception_context(new_exc, old_exc):
   639|         0|            0|            0|  0.00%|            # Context may not be correct, so find the end of the chain
   640|         0|            0|            0|  0.00%|            while 1:
   641|         0|            0|            0|  0.00%|                exc_context = new_exc.__context__
   642|         0|            0|            0|  0.00%|                if exc_context is old_exc:
   643|         0|            0|            0|  0.00%|                    # Context is already set correctly (see issue 20317)
   644|         0|            0|            0|  0.00%|                    return
   645|         0|            0|            0|  0.00%|                if exc_context is None or exc_context is frame_exc:
   646|         0|            0|            0|  0.00%|                    break
   647|         0|            0|            0|  0.00%|                new_exc = exc_context
   648|         0|            0|            0|  0.00%|            # Change the end of the chain to point to the exception
   649|         0|            0|            0|  0.00%|            # we expect it to reference
   650|         0|            0|            0|  0.00%|            new_exc.__context__ = old_exc
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|        # Callbacks are invoked in LIFO order to match the behaviour of
   653|         0|            0|            0|  0.00%|        # nested context managers
   654|         0|            0|            0|  0.00%|        suppressed_exc = False
   655|         0|            0|            0|  0.00%|        pending_raise = False
   656|         0|            0|            0|  0.00%|        while self._exit_callbacks:
   657|         0|            0|            0|  0.00%|            is_sync, cb = self._exit_callbacks.pop()
   658|         0|            0|            0|  0.00%|            try:
   659|         0|            0|            0|  0.00%|                if is_sync:
   660|         0|            0|            0|  0.00%|                    cb_suppress = cb(*exc_details)
   661|         0|            0|            0|  0.00%|                else:
   662|         0|            0|            0|  0.00%|                    cb_suppress = await cb(*exc_details)
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|                if cb_suppress:
   665|         0|            0|            0|  0.00%|                    suppressed_exc = True
   666|         0|            0|            0|  0.00%|                    pending_raise = False
   667|         0|            0|            0|  0.00%|                    exc_details = (None, None, None)
   668|         0|            0|            0|  0.00%|            except:
   669|         0|            0|            0|  0.00%|                new_exc_details = sys.exc_info()
   670|         0|            0|            0|  0.00%|                # simulate the stack of exceptions by setting the context
   671|         0|            0|            0|  0.00%|                _fix_exception_context(new_exc_details[1], exc_details[1])
   672|         0|            0|            0|  0.00%|                pending_raise = True
   673|         0|            0|            0|  0.00%|                exc_details = new_exc_details
   674|         0|            0|            0|  0.00%|        if pending_raise:
   675|         0|            0|            0|  0.00%|            try:
   676|         0|            0|            0|  0.00%|                # bare "raise exc_details[1]" replaces our carefully
   677|         0|            0|            0|  0.00%|                # set-up context
   678|         0|            0|            0|  0.00%|                fixed_ctx = exc_details[1].__context__
   679|         0|            0|            0|  0.00%|                raise exc_details[1]
   680|         0|            0|            0|  0.00%|            except BaseException:
   681|         0|            0|            0|  0.00%|                exc_details[1].__context__ = fixed_ctx
   682|         0|            0|            0|  0.00%|                raise
   683|         0|            0|            0|  0.00%|        return received_exc and suppressed_exc
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|class nullcontext(AbstractContextManager):
   687|         0|            0|            0|  0.00%|    """Context manager that does no additional processing.
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    Used as a stand-in for a normal context manager, when a particular
   690|         0|            0|            0|  0.00%|    block of code is only sometimes used with a normal context manager:
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    cm = optional_cm if condition else nullcontext()
   693|         0|            0|            0|  0.00%|    with cm:
   694|         0|            0|            0|  0.00%|        # Perform operation, using optional_cm if condition is True
   695|         0|            0|            0|  0.00%|    """
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|    def __init__(self, enter_result=None):
   698|         0|            0|            0|  0.00%|        self.enter_result = enter_result
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    def __enter__(self):
   701|         0|            0|            0|  0.00%|        return self.enter_result
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    def __exit__(self, *excinfo):
   704|         0|            0|            0|  0.00%|        pass
File: /opt/conda/lib/python3.8/site-packages/torch/backends/__init__.py
File duration: 0.00011158s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from contextlib import contextmanager
     2|         0|            0|            0|  0.00%|import types
     3|         0|            0|            0|  0.00%|# The idea for this parameter is that we forbid bare assignment
     4|         0|            0|            0|  0.00%|# to torch.backends.<cudnn|mkldnn>.enabled and friends when running our
     5|         0|            0|            0|  0.00%|# test suite, where it's very easy to forget to undo the change
     6|         0|            0|            0|  0.00%|# later.
     7|         0|            0|            0|  0.00%|__allow_nonbracketed_mutation_flag = True
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|def disable_global_flags():
    10|         0|            0|            0|  0.00%|    global __allow_nonbracketed_mutation_flag
    11|         0|            0|            0|  0.00%|    __allow_nonbracketed_mutation_flag = False
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|def flags_frozen():
    14|         0|            0|            0|  0.00%|    return not __allow_nonbracketed_mutation_flag
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|@contextmanager
    17|         0|            0|            0|  0.00%|def __allow_nonbracketed_mutation():
    18|         0|            0|            0|  0.00%|    global __allow_nonbracketed_mutation_flag
    19|         0|            0|            0|  0.00%|    old = __allow_nonbracketed_mutation_flag
    20|         0|            0|            0|  0.00%|    __allow_nonbracketed_mutation_flag = True
    21|         0|            0|            0|  0.00%|    try:
    22|         0|            0|            0|  0.00%|        yield
    23|         0|            0|            0|  0.00%|    finally:
    24|         0|            0|            0|  0.00%|        __allow_nonbracketed_mutation_flag = old
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|class ContextProp(object):
    27|         0|            0|            0|  0.00%|    def __init__(self, getter, setter):
    28|         0|            0|            0|  0.00%|        self.getter = getter
    29|         0|            0|            0|  0.00%|        self.setter = setter
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|    def __get__(self, obj, objtype):
    32|         0|            0|            0|  0.00%|        return self.getter()
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|    def __set__(self, obj, val):
    35|         0|            0|            0|  0.00%|        if not flags_frozen():
    36|         0|            0|            0|  0.00%|            self.setter(val)
    37|         0|            0|            0|  0.00%|        else:
    38|         0|            0|            0|  0.00%|            raise RuntimeError("not allowed to set %s flags "
    39|         0|            0|            0|  0.00%|                               "after disable_global_flags; please use flags() context manager instead" % obj.__name__)
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|class PropModule(types.ModuleType):
    42|         0|            0|            0|  0.00%|    def __init__(self, m, name):
    43|         0|            0|            0|  0.00%|        super(PropModule, self).__init__(name)
    44|         0|            0|            0|  0.00%|        self.m = m
    45|         0|            0|            0|  0.00%|
    46|         8|  4.98295e-05|  6.22869e-06|  0.00%|    def __getattr__(self, attr):
    47|         8|  6.17504e-05|   7.7188e-06|  0.00%|        return self.m.__getattribute__(attr)
File: /opt/conda/lib/python3.8/site-packages/torch/backends/quantized/__init__.py
File duration: 6.05583e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import sys
     2|         0|            0|            0|  0.00%|import torch
     3|         0|            0|            0|  0.00%|import types
     4|         0|            0|            0|  0.00%|from typing import List
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|# This function should correspond to the enums present in c10/core/QEngine.h
     7|         0|            0|            0|  0.00%|def _get_qengine_id(qengine: str) -> int:
     8|         0|            0|            0|  0.00%|    if qengine == 'none' or qengine == '' or qengine is None:
     9|         0|            0|            0|  0.00%|        ret = 0
    10|         0|            0|            0|  0.00%|    elif qengine == 'fbgemm':
    11|         0|            0|            0|  0.00%|        ret = 1
    12|         0|            0|            0|  0.00%|    elif qengine == 'qnnpack':
    13|         0|            0|            0|  0.00%|        ret = 2
    14|         0|            0|            0|  0.00%|    else:
    15|         0|            0|            0|  0.00%|        ret = -1
    16|         0|            0|            0|  0.00%|        raise RuntimeError("{} is not a valid value for quantized engine".format(qengine))
    17|         0|            0|            0|  0.00%|    return ret
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|# This function should correspond to the enums present in c10/core/QEngine.h
    20|         0|            0|            0|  0.00%|def _get_qengine_str(qengine: int) -> str:
    21|         0|            0|            0|  0.00%|    all_engines = {0 : 'none', 1 : 'fbgemm', 2 : 'qnnpack'}
    22|         0|            0|            0|  0.00%|    return all_engines.get(qengine, '*undefined')
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|class _QEngineProp(object):
    25|         0|            0|            0|  0.00%|    def __get__(self, obj, objtype) -> str:
    26|         0|            0|            0|  0.00%|        return _get_qengine_str(torch._C._get_qengine())
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|    def __set__(self, obj, val: str) -> None:
    29|         0|            0|            0|  0.00%|        torch._C._set_qengine(_get_qengine_id(val))
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|class _SupportedQEnginesProp(object):
    32|         0|            0|            0|  0.00%|    def __get__(self, obj, objtype) -> List[str]:
    33|         0|            0|            0|  0.00%|        qengines = torch._C._supported_qengines()
    34|         0|            0|            0|  0.00%|        return [_get_qengine_str(qe) for qe in qengines]
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    def __set__(self, obj, val) -> None:
    37|         0|            0|            0|  0.00%|        raise RuntimeError("Assignment not supported")
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|class QuantizedEngine(types.ModuleType):
    40|         0|            0|            0|  0.00%|    def __init__(self, m, name):
    41|         0|            0|            0|  0.00%|        super(QuantizedEngine, self).__init__(name)
    42|         0|            0|            0|  0.00%|        self.m = m
    43|         0|            0|            0|  0.00%|
    44|         4|  2.98023e-05|  7.45058e-06|  0.00%|    def __getattr__(self, attr):
    45|         4|   3.0756e-05|    7.689e-06|  0.00%|        return self.m.__getattribute__(attr)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    engine = _QEngineProp()
    48|         0|            0|            0|  0.00%|    supported_engines = _SupportedQEnginesProp()
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|# This is the sys.modules replacement trick, see
    51|         0|            0|            0|  0.00%|# https://stackoverflow.com/questions/2447353/getattr-on-a-module/7668273#7668273
    52|         0|            0|            0|  0.00%|sys.modules[__name__] = QuantizedEngine(sys.modules[__name__], __name__)
    53|         0|            0|            0|  0.00%|engine: str
    54|         0|            0|            0|  0.00%|supported_engines: List[str]
File: /opt/conda/lib/python3.8/site-packages/torch/_VF.py
File duration: 6.03199e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|This makes the functions in torch._C._VariableFunctions available as
     3|         0|            0|            0|  0.00%|    torch._VF.<funcname>
     4|         0|            0|            0|  0.00%|without mypy being able to find them.
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|A subset of those functions are mapped to ATen functions in
     7|         0|            0|            0|  0.00%|torch/jit/_builtins.py
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|See https://github.com/pytorch/pytorch/issues/21478 for the reason for
    10|         0|            0|            0|  0.00%|introducing torch._VF
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|"""
    13|         0|            0|            0|  0.00%|import torch
    14|         0|            0|            0|  0.00%|import sys
    15|         0|            0|            0|  0.00%|import types
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|class VFModule(types.ModuleType):
    19|         0|            0|            0|  0.00%|    vf: types.ModuleType
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|    def __init__(self, name):
    22|         0|            0|            0|  0.00%|        super(VFModule, self).__init__(name)
    23|         0|            0|            0|  0.00%|        self.vf = torch._C._VariableFunctions
    24|         0|            0|            0|  0.00%|
    25|         1|  1.52588e-05|  1.52588e-05|  0.00%|    def __getattr__(self, attr):
    26|         1|  4.50611e-05|  4.50611e-05|  0.00%|        return getattr(self.vf, attr)
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|sys.modules[__name__] = VFModule(__name__)
File: /opt/conda/lib/python3.8/asyncio/coroutines.py
File duration: 5.76973e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|__all__ = 'coroutine', 'iscoroutinefunction', 'iscoroutine'
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import collections.abc
     4|         0|            0|            0|  0.00%|import functools
     5|         0|            0|            0|  0.00%|import inspect
     6|         0|            0|            0|  0.00%|import os
     7|         0|            0|            0|  0.00%|import sys
     8|         0|            0|            0|  0.00%|import traceback
     9|         0|            0|            0|  0.00%|import types
    10|         0|            0|            0|  0.00%|import warnings
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|from . import base_futures
    13|         0|            0|            0|  0.00%|from . import constants
    14|         0|            0|            0|  0.00%|from . import format_helpers
    15|         0|            0|            0|  0.00%|from .log import logger
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|def _is_debug_mode():
    19|         0|            0|            0|  0.00%|    # If you set _DEBUG to true, @coroutine will wrap the resulting
    20|         0|            0|            0|  0.00%|    # generator objects in a CoroWrapper instance (defined below).  That
    21|         0|            0|            0|  0.00%|    # instance will log a message when the generator is never iterated
    22|         0|            0|            0|  0.00%|    # over, which may happen when you forget to use "await" or "yield from"
    23|         0|            0|            0|  0.00%|    # with a coroutine call.
    24|         0|            0|            0|  0.00%|    # Note that the value of the _DEBUG flag is taken
    25|         0|            0|            0|  0.00%|    # when the decorator is used, so to be of any use it must be set
    26|         0|            0|            0|  0.00%|    # before you define your coroutines.  A downside of using this feature
    27|         0|            0|            0|  0.00%|    # is that tracebacks show entries for the CoroWrapper.__next__ method
    28|         0|            0|            0|  0.00%|    # when _DEBUG is true.
    29|         0|            0|            0|  0.00%|    return sys.flags.dev_mode or (not sys.flags.ignore_environment and
    30|         0|            0|            0|  0.00%|                                  bool(os.environ.get('PYTHONASYNCIODEBUG')))
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|_DEBUG = _is_debug_mode()
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|class CoroWrapper:
    37|         0|            0|            0|  0.00%|    # Wrapper for coroutine object in _DEBUG mode.
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    def __init__(self, gen, func=None):
    40|         0|            0|            0|  0.00%|        assert inspect.isgenerator(gen) or inspect.iscoroutine(gen), gen
    41|         0|            0|            0|  0.00%|        self.gen = gen
    42|         0|            0|            0|  0.00%|        self.func = func  # Used to unwrap @coroutine decorator
    43|         0|            0|            0|  0.00%|        self._source_traceback = format_helpers.extract_stack(sys._getframe(1))
    44|         0|            0|            0|  0.00%|        self.__name__ = getattr(gen, '__name__', None)
    45|         0|            0|            0|  0.00%|        self.__qualname__ = getattr(gen, '__qualname__', None)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    def __repr__(self):
    48|         0|            0|            0|  0.00%|        coro_repr = _format_coroutine(self)
    49|         0|            0|            0|  0.00%|        if self._source_traceback:
    50|         0|            0|            0|  0.00%|            frame = self._source_traceback[-1]
    51|         0|            0|            0|  0.00%|            coro_repr += f', created at {frame[0]}:{frame[1]}'
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|        return f'<{self.__class__.__name__} {coro_repr}>'
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|    def __iter__(self):
    56|         0|            0|            0|  0.00%|        return self
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|    def __next__(self):
    59|         0|            0|            0|  0.00%|        return self.gen.send(None)
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|    def send(self, value):
    62|         0|            0|            0|  0.00%|        return self.gen.send(value)
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    def throw(self, type, value=None, traceback=None):
    65|         0|            0|            0|  0.00%|        return self.gen.throw(type, value, traceback)
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|    def close(self):
    68|         0|            0|            0|  0.00%|        return self.gen.close()
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|    @property
    71|         0|            0|            0|  0.00%|    def gi_frame(self):
    72|         0|            0|            0|  0.00%|        return self.gen.gi_frame
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    @property
    75|         0|            0|            0|  0.00%|    def gi_running(self):
    76|         0|            0|            0|  0.00%|        return self.gen.gi_running
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|    @property
    79|         0|            0|            0|  0.00%|    def gi_code(self):
    80|         0|            0|            0|  0.00%|        return self.gen.gi_code
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    def __await__(self):
    83|         0|            0|            0|  0.00%|        return self
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|    @property
    86|         0|            0|            0|  0.00%|    def gi_yieldfrom(self):
    87|         0|            0|            0|  0.00%|        return self.gen.gi_yieldfrom
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    def __del__(self):
    90|         0|            0|            0|  0.00%|        # Be careful accessing self.gen.frame -- self.gen might not exist.
    91|         0|            0|            0|  0.00%|        gen = getattr(self, 'gen', None)
    92|         0|            0|            0|  0.00%|        frame = getattr(gen, 'gi_frame', None)
    93|         0|            0|            0|  0.00%|        if frame is not None and frame.f_lasti == -1:
    94|         0|            0|            0|  0.00%|            msg = f'{self!r} was never yielded from'
    95|         0|            0|            0|  0.00%|            tb = getattr(self, '_source_traceback', ())
    96|         0|            0|            0|  0.00%|            if tb:
    97|         0|            0|            0|  0.00%|                tb = ''.join(traceback.format_list(tb))
    98|         0|            0|            0|  0.00%|                msg += (f'\nCoroutine object created at '
    99|         0|            0|            0|  0.00%|                        f'(most recent call last, truncated to '
   100|         0|            0|            0|  0.00%|                        f'{constants.DEBUG_STACK_DEPTH} last lines):\n')
   101|         0|            0|            0|  0.00%|                msg += tb.rstrip()
   102|         0|            0|            0|  0.00%|            logger.error(msg)
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|def coroutine(func):
   106|         0|            0|            0|  0.00%|    """Decorator to mark coroutines.
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    If the coroutine is not yielded from before it is destroyed,
   109|         0|            0|            0|  0.00%|    an error message is logged.
   110|         0|            0|            0|  0.00%|    """
   111|         0|            0|            0|  0.00%|    warnings.warn('"@coroutine" decorator is deprecated since Python 3.8, use "async def" instead',
   112|         0|            0|            0|  0.00%|                  DeprecationWarning,
   113|         0|            0|            0|  0.00%|                  stacklevel=2)
   114|         0|            0|            0|  0.00%|    if inspect.iscoroutinefunction(func):
   115|         0|            0|            0|  0.00%|        # In Python 3.5 that's all we need to do for coroutines
   116|         0|            0|            0|  0.00%|        # defined with "async def".
   117|         0|            0|            0|  0.00%|        return func
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|    if inspect.isgeneratorfunction(func):
   120|         0|            0|            0|  0.00%|        coro = func
   121|         0|            0|            0|  0.00%|    else:
   122|         0|            0|            0|  0.00%|        @functools.wraps(func)
   123|         0|            0|            0|  0.00%|        def coro(*args, **kw):
   124|         0|            0|            0|  0.00%|            res = func(*args, **kw)
   125|         0|            0|            0|  0.00%|            if (base_futures.isfuture(res) or inspect.isgenerator(res) or
   126|         0|            0|            0|  0.00%|                    isinstance(res, CoroWrapper)):
   127|         0|            0|            0|  0.00%|                res = yield from res
   128|         0|            0|            0|  0.00%|            else:
   129|         0|            0|            0|  0.00%|                # If 'res' is an awaitable, run it.
   130|         0|            0|            0|  0.00%|                try:
   131|         0|            0|            0|  0.00%|                    await_meth = res.__await__
   132|         0|            0|            0|  0.00%|                except AttributeError:
   133|         0|            0|            0|  0.00%|                    pass
   134|         0|            0|            0|  0.00%|                else:
   135|         0|            0|            0|  0.00%|                    if isinstance(res, collections.abc.Awaitable):
   136|         0|            0|            0|  0.00%|                        res = yield from await_meth()
   137|         0|            0|            0|  0.00%|            return res
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    coro = types.coroutine(coro)
   140|         0|            0|            0|  0.00%|    if not _DEBUG:
   141|         0|            0|            0|  0.00%|        wrapper = coro
   142|         0|            0|            0|  0.00%|    else:
   143|         0|            0|            0|  0.00%|        @functools.wraps(func)
   144|         0|            0|            0|  0.00%|        def wrapper(*args, **kwds):
   145|         0|            0|            0|  0.00%|            w = CoroWrapper(coro(*args, **kwds), func=func)
   146|         0|            0|            0|  0.00%|            if w._source_traceback:
   147|         0|            0|            0|  0.00%|                del w._source_traceback[-1]
   148|         0|            0|            0|  0.00%|            # Python < 3.5 does not implement __qualname__
   149|         0|            0|            0|  0.00%|            # on generator objects, so we set it manually.
   150|         0|            0|            0|  0.00%|            # We use getattr as some callables (such as
   151|         0|            0|            0|  0.00%|            # functools.partial may lack __qualname__).
   152|         0|            0|            0|  0.00%|            w.__name__ = getattr(func, '__name__', None)
   153|         0|            0|            0|  0.00%|            w.__qualname__ = getattr(func, '__qualname__', None)
   154|         0|            0|            0|  0.00%|            return w
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    wrapper._is_coroutine = _is_coroutine  # For iscoroutinefunction().
   157|         0|            0|            0|  0.00%|    return wrapper
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|# A marker for iscoroutinefunction.
   161|         0|            0|            0|  0.00%|_is_coroutine = object()
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         1|  1.19209e-05|  1.19209e-05|  0.00%|def iscoroutinefunction(func):
   165|         0|            0|            0|  0.00%|    """Return True if func is a decorated coroutine function."""
   166|         2|  3.12328e-05|  1.56164e-05|  0.00%|    return (inspect.iscoroutinefunction(func) or
(call)|         1|  0.000158787|  0.000158787|  0.00%|# /opt/conda/lib/python3.8/inspect.py:189 iscoroutinefunction
   167|         1|  1.45435e-05|  1.45435e-05|  0.00%|            getattr(func, '_is_coroutine', None) is _is_coroutine)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|# Prioritize native coroutine check to speed-up
   171|         0|            0|            0|  0.00%|# asyncio.iscoroutine.
   172|         0|            0|            0|  0.00%|_COROUTINE_TYPES = (types.CoroutineType, types.GeneratorType,
   173|         0|            0|            0|  0.00%|                    collections.abc.Coroutine, CoroWrapper)
   174|         0|            0|            0|  0.00%|_iscoroutine_typecache = set()
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|def iscoroutine(obj):
   178|         0|            0|            0|  0.00%|    """Return True if obj is a coroutine object."""
   179|         0|            0|            0|  0.00%|    if type(obj) in _iscoroutine_typecache:
   180|         0|            0|            0|  0.00%|        return True
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    if isinstance(obj, _COROUTINE_TYPES):
   183|         0|            0|            0|  0.00%|        # Just in case we don't want to cache more than 100
   184|         0|            0|            0|  0.00%|        # positive types.  That shouldn't ever happen, unless
   185|         0|            0|            0|  0.00%|        # someone stressing the system on purpose.
   186|         0|            0|            0|  0.00%|        if len(_iscoroutine_typecache) < 100:
   187|         0|            0|            0|  0.00%|            _iscoroutine_typecache.add(type(obj))
   188|         0|            0|            0|  0.00%|        return True
   189|         0|            0|            0|  0.00%|    else:
   190|         0|            0|            0|  0.00%|        return False
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|def _format_coroutine(coro):
   194|         0|            0|            0|  0.00%|    assert iscoroutine(coro)
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    is_corowrapper = isinstance(coro, CoroWrapper)
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    def get_name(coro):
   199|         0|            0|            0|  0.00%|        # Coroutines compiled with Cython sometimes don't have
   200|         0|            0|            0|  0.00%|        # proper __qualname__ or __name__.  While that is a bug
   201|         0|            0|            0|  0.00%|        # in Cython, asyncio shouldn't crash with an AttributeError
   202|         0|            0|            0|  0.00%|        # in its __repr__ functions.
   203|         0|            0|            0|  0.00%|        if is_corowrapper:
   204|         0|            0|            0|  0.00%|            return format_helpers._format_callback(coro.func, (), {})
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|        if hasattr(coro, '__qualname__') and coro.__qualname__:
   207|         0|            0|            0|  0.00%|            coro_name = coro.__qualname__
   208|         0|            0|            0|  0.00%|        elif hasattr(coro, '__name__') and coro.__name__:
   209|         0|            0|            0|  0.00%|            coro_name = coro.__name__
   210|         0|            0|            0|  0.00%|        else:
   211|         0|            0|            0|  0.00%|            # Stop masking Cython bugs, expose them in a friendly way.
   212|         0|            0|            0|  0.00%|            coro_name = f'<{type(coro).__name__} without __name__>'
   213|         0|            0|            0|  0.00%|        return f'{coro_name}()'
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    def is_running(coro):
   216|         0|            0|            0|  0.00%|        try:
   217|         0|            0|            0|  0.00%|            return coro.cr_running
   218|         0|            0|            0|  0.00%|        except AttributeError:
   219|         0|            0|            0|  0.00%|            try:
   220|         0|            0|            0|  0.00%|                return coro.gi_running
   221|         0|            0|            0|  0.00%|            except AttributeError:
   222|         0|            0|            0|  0.00%|                return False
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    coro_code = None
   225|         0|            0|            0|  0.00%|    if hasattr(coro, 'cr_code') and coro.cr_code:
   226|         0|            0|            0|  0.00%|        coro_code = coro.cr_code
   227|         0|            0|            0|  0.00%|    elif hasattr(coro, 'gi_code') and coro.gi_code:
   228|         0|            0|            0|  0.00%|        coro_code = coro.gi_code
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    coro_name = get_name(coro)
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    if not coro_code:
   233|         0|            0|            0|  0.00%|        # Built-in types might not have __qualname__ or __name__.
   234|         0|            0|            0|  0.00%|        if is_running(coro):
   235|         0|            0|            0|  0.00%|            return f'{coro_name} running'
   236|         0|            0|            0|  0.00%|        else:
   237|         0|            0|            0|  0.00%|            return coro_name
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    coro_frame = None
   240|         0|            0|            0|  0.00%|    if hasattr(coro, 'gi_frame') and coro.gi_frame:
   241|         0|            0|            0|  0.00%|        coro_frame = coro.gi_frame
   242|         0|            0|            0|  0.00%|    elif hasattr(coro, 'cr_frame') and coro.cr_frame:
   243|         0|            0|            0|  0.00%|        coro_frame = coro.cr_frame
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|    # If Cython's coroutine has a fake code object without proper
   246|         0|            0|            0|  0.00%|    # co_filename -- expose that.
   247|         0|            0|            0|  0.00%|    filename = coro_code.co_filename or '<empty co_filename>'
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|    lineno = 0
   250|         0|            0|            0|  0.00%|    if (is_corowrapper and
   251|         0|            0|            0|  0.00%|            coro.func is not None and
   252|         0|            0|            0|  0.00%|            not inspect.isgeneratorfunction(coro.func)):
   253|         0|            0|            0|  0.00%|        source = format_helpers._get_function_source(coro.func)
   254|         0|            0|            0|  0.00%|        if source is not None:
   255|         0|            0|            0|  0.00%|            filename, lineno = source
   256|         0|            0|            0|  0.00%|        if coro_frame is None:
   257|         0|            0|            0|  0.00%|            coro_repr = f'{coro_name} done, defined at {filename}:{lineno}'
   258|         0|            0|            0|  0.00%|        else:
   259|         0|            0|            0|  0.00%|            coro_repr = f'{coro_name} running, defined at {filename}:{lineno}'
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    elif coro_frame is not None:
   262|         0|            0|            0|  0.00%|        lineno = coro_frame.f_lineno
   263|         0|            0|            0|  0.00%|        coro_repr = f'{coro_name} running at {filename}:{lineno}'
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|    else:
   266|         0|            0|            0|  0.00%|        lineno = coro_code.co_firstlineno
   267|         0|            0|            0|  0.00%|        coro_repr = f'{coro_name} done, defined at {filename}:{lineno}'
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|    return coro_repr
File: /opt/conda/lib/python3.8/functools.py
File duration: 3.38554e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""functools.py - Tools for working with functions and callable objects
     2|         0|            0|            0|  0.00%|"""
     3|         0|            0|            0|  0.00%|# Python module wrapper for _functools C module
     4|         0|            0|            0|  0.00%|# to allow utilities written in Python to be added
     5|         0|            0|            0|  0.00%|# to the functools module.
     6|         0|            0|            0|  0.00%|# Written by Nick Coghlan <ncoghlan at gmail.com>,
     7|         0|            0|            0|  0.00%|# Raymond Hettinger <python at rcn.com>,
     8|         0|            0|            0|  0.00%|# and ukasz Langa <lukasz at langa.pl>.
     9|         0|            0|            0|  0.00%|#   Copyright (C) 2006-2013 Python Software Foundation.
    10|         0|            0|            0|  0.00%|# See C source code for _functools credits/copyright
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|__all__ = ['update_wrapper', 'wraps', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES',
    13|         0|            0|            0|  0.00%|           'total_ordering', 'cmp_to_key', 'lru_cache', 'reduce', 'partial',
    14|         0|            0|            0|  0.00%|           'partialmethod', 'singledispatch', 'singledispatchmethod',
    15|         0|            0|            0|  0.00%|           "cached_property"]
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|from abc import get_cache_token
    18|         0|            0|            0|  0.00%|from collections import namedtuple
    19|         0|            0|            0|  0.00%|# import types, weakref  # Deferred to single_dispatch()
    20|         0|            0|            0|  0.00%|from reprlib import recursive_repr
    21|         0|            0|            0|  0.00%|from _thread import RLock
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|################################################################################
    25|         0|            0|            0|  0.00%|### update_wrapper() and wraps() decorator
    26|         0|            0|            0|  0.00%|################################################################################
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|# update_wrapper() and wraps() are tools to help write
    29|         0|            0|            0|  0.00%|# wrapper functions that can handle naive introspection
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',
    32|         0|            0|            0|  0.00%|                       '__annotations__')
    33|         0|            0|            0|  0.00%|WRAPPER_UPDATES = ('__dict__',)
    34|         0|            0|            0|  0.00%|def update_wrapper(wrapper,
    35|         0|            0|            0|  0.00%|                   wrapped,
    36|         0|            0|            0|  0.00%|                   assigned = WRAPPER_ASSIGNMENTS,
    37|         0|            0|            0|  0.00%|                   updated = WRAPPER_UPDATES):
    38|         0|            0|            0|  0.00%|    """Update a wrapper function to look like the wrapped function
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|       wrapper is the function to be updated
    41|         0|            0|            0|  0.00%|       wrapped is the original function
    42|         0|            0|            0|  0.00%|       assigned is a tuple naming the attributes assigned directly
    43|         0|            0|            0|  0.00%|       from the wrapped function to the wrapper function (defaults to
    44|         0|            0|            0|  0.00%|       functools.WRAPPER_ASSIGNMENTS)
    45|         0|            0|            0|  0.00%|       updated is a tuple naming the attributes of the wrapper that
    46|         0|            0|            0|  0.00%|       are updated with the corresponding attribute from the wrapped
    47|         0|            0|            0|  0.00%|       function (defaults to functools.WRAPPER_UPDATES)
    48|         0|            0|            0|  0.00%|    """
    49|         0|            0|            0|  0.00%|    for attr in assigned:
    50|         0|            0|            0|  0.00%|        try:
    51|         0|            0|            0|  0.00%|            value = getattr(wrapped, attr)
    52|         0|            0|            0|  0.00%|        except AttributeError:
    53|         0|            0|            0|  0.00%|            pass
    54|         0|            0|            0|  0.00%|        else:
    55|         0|            0|            0|  0.00%|            setattr(wrapper, attr, value)
    56|         0|            0|            0|  0.00%|    for attr in updated:
    57|         0|            0|            0|  0.00%|        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
    58|         0|            0|            0|  0.00%|    # Issue #17482: set __wrapped__ last so we don't inadvertently copy it
    59|         0|            0|            0|  0.00%|    # from the wrapped function when updating __dict__
    60|         0|            0|            0|  0.00%|    wrapper.__wrapped__ = wrapped
    61|         0|            0|            0|  0.00%|    # Return the wrapper so this can be used as a decorator via partial()
    62|         0|            0|            0|  0.00%|    return wrapper
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|def wraps(wrapped,
    65|         0|            0|            0|  0.00%|          assigned = WRAPPER_ASSIGNMENTS,
    66|         0|            0|            0|  0.00%|          updated = WRAPPER_UPDATES):
    67|         0|            0|            0|  0.00%|    """Decorator factory to apply update_wrapper() to a wrapper function
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|       Returns a decorator that invokes update_wrapper() with the decorated
    70|         0|            0|            0|  0.00%|       function as the wrapper argument and the arguments to wraps() as the
    71|         0|            0|            0|  0.00%|       remaining arguments. Default arguments are as for update_wrapper().
    72|         0|            0|            0|  0.00%|       This is a convenience function to simplify applying partial() to
    73|         0|            0|            0|  0.00%|       update_wrapper().
    74|         0|            0|            0|  0.00%|    """
    75|         0|            0|            0|  0.00%|    return partial(update_wrapper, wrapped=wrapped,
    76|         0|            0|            0|  0.00%|                   assigned=assigned, updated=updated)
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|################################################################################
    80|         0|            0|            0|  0.00%|### total_ordering class decorator
    81|         0|            0|            0|  0.00%|################################################################################
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|# The total ordering functions all invoke the root magic method directly
    84|         0|            0|            0|  0.00%|# rather than using the corresponding operator.  This avoids possible
    85|         0|            0|            0|  0.00%|# infinite recursion that could occur when the operator dispatch logic
    86|         0|            0|            0|  0.00%|# detects a NotImplemented result and then calls a reflected method.
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|def _gt_from_lt(self, other, NotImplemented=NotImplemented):
    89|         0|            0|            0|  0.00%|    'Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).'
    90|         0|            0|            0|  0.00%|    op_result = self.__lt__(other)
    91|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
    92|         0|            0|            0|  0.00%|        return op_result
    93|         0|            0|            0|  0.00%|    return not op_result and self != other
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|def _le_from_lt(self, other, NotImplemented=NotImplemented):
    96|         0|            0|            0|  0.00%|    'Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).'
    97|         0|            0|            0|  0.00%|    op_result = self.__lt__(other)
    98|         0|            0|            0|  0.00%|    return op_result or self == other
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|def _ge_from_lt(self, other, NotImplemented=NotImplemented):
   101|         0|            0|            0|  0.00%|    'Return a >= b.  Computed by @total_ordering from (not a < b).'
   102|         0|            0|            0|  0.00%|    op_result = self.__lt__(other)
   103|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   104|         0|            0|            0|  0.00%|        return op_result
   105|         0|            0|            0|  0.00%|    return not op_result
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|def _ge_from_le(self, other, NotImplemented=NotImplemented):
   108|         0|            0|            0|  0.00%|    'Return a >= b.  Computed by @total_ordering from (not a <= b) or (a == b).'
   109|         0|            0|            0|  0.00%|    op_result = self.__le__(other)
   110|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   111|         0|            0|            0|  0.00%|        return op_result
   112|         0|            0|            0|  0.00%|    return not op_result or self == other
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|def _lt_from_le(self, other, NotImplemented=NotImplemented):
   115|         0|            0|            0|  0.00%|    'Return a < b.  Computed by @total_ordering from (a <= b) and (a != b).'
   116|         0|            0|            0|  0.00%|    op_result = self.__le__(other)
   117|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   118|         0|            0|            0|  0.00%|        return op_result
   119|         0|            0|            0|  0.00%|    return op_result and self != other
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|def _gt_from_le(self, other, NotImplemented=NotImplemented):
   122|         0|            0|            0|  0.00%|    'Return a > b.  Computed by @total_ordering from (not a <= b).'
   123|         0|            0|            0|  0.00%|    op_result = self.__le__(other)
   124|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   125|         0|            0|            0|  0.00%|        return op_result
   126|         0|            0|            0|  0.00%|    return not op_result
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|def _lt_from_gt(self, other, NotImplemented=NotImplemented):
   129|         0|            0|            0|  0.00%|    'Return a < b.  Computed by @total_ordering from (not a > b) and (a != b).'
   130|         0|            0|            0|  0.00%|    op_result = self.__gt__(other)
   131|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   132|         0|            0|            0|  0.00%|        return op_result
   133|         0|            0|            0|  0.00%|    return not op_result and self != other
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|def _ge_from_gt(self, other, NotImplemented=NotImplemented):
   136|         0|            0|            0|  0.00%|    'Return a >= b.  Computed by @total_ordering from (a > b) or (a == b).'
   137|         0|            0|            0|  0.00%|    op_result = self.__gt__(other)
   138|         0|            0|            0|  0.00%|    return op_result or self == other
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|def _le_from_gt(self, other, NotImplemented=NotImplemented):
   141|         0|            0|            0|  0.00%|    'Return a <= b.  Computed by @total_ordering from (not a > b).'
   142|         0|            0|            0|  0.00%|    op_result = self.__gt__(other)
   143|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   144|         0|            0|            0|  0.00%|        return op_result
   145|         0|            0|            0|  0.00%|    return not op_result
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|def _le_from_ge(self, other, NotImplemented=NotImplemented):
   148|         0|            0|            0|  0.00%|    'Return a <= b.  Computed by @total_ordering from (not a >= b) or (a == b).'
   149|         0|            0|            0|  0.00%|    op_result = self.__ge__(other)
   150|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   151|         0|            0|            0|  0.00%|        return op_result
   152|         0|            0|            0|  0.00%|    return not op_result or self == other
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|def _gt_from_ge(self, other, NotImplemented=NotImplemented):
   155|         0|            0|            0|  0.00%|    'Return a > b.  Computed by @total_ordering from (a >= b) and (a != b).'
   156|         0|            0|            0|  0.00%|    op_result = self.__ge__(other)
   157|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   158|         0|            0|            0|  0.00%|        return op_result
   159|         0|            0|            0|  0.00%|    return op_result and self != other
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|def _lt_from_ge(self, other, NotImplemented=NotImplemented):
   162|         0|            0|            0|  0.00%|    'Return a < b.  Computed by @total_ordering from (not a >= b).'
   163|         0|            0|            0|  0.00%|    op_result = self.__ge__(other)
   164|         0|            0|            0|  0.00%|    if op_result is NotImplemented:
   165|         0|            0|            0|  0.00%|        return op_result
   166|         0|            0|            0|  0.00%|    return not op_result
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|_convert = {
   169|         0|            0|            0|  0.00%|    '__lt__': [('__gt__', _gt_from_lt),
   170|         0|            0|            0|  0.00%|               ('__le__', _le_from_lt),
   171|         0|            0|            0|  0.00%|               ('__ge__', _ge_from_lt)],
   172|         0|            0|            0|  0.00%|    '__le__': [('__ge__', _ge_from_le),
   173|         0|            0|            0|  0.00%|               ('__lt__', _lt_from_le),
   174|         0|            0|            0|  0.00%|               ('__gt__', _gt_from_le)],
   175|         0|            0|            0|  0.00%|    '__gt__': [('__lt__', _lt_from_gt),
   176|         0|            0|            0|  0.00%|               ('__ge__', _ge_from_gt),
   177|         0|            0|            0|  0.00%|               ('__le__', _le_from_gt)],
   178|         0|            0|            0|  0.00%|    '__ge__': [('__le__', _le_from_ge),
   179|         0|            0|            0|  0.00%|               ('__gt__', _gt_from_ge),
   180|         0|            0|            0|  0.00%|               ('__lt__', _lt_from_ge)]
   181|         0|            0|            0|  0.00%|}
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|def total_ordering(cls):
   184|         0|            0|            0|  0.00%|    """Class decorator that fills in missing ordering methods"""
   185|         0|            0|            0|  0.00%|    # Find user-defined comparisons (not those inherited from object).
   186|         0|            0|            0|  0.00%|    roots = {op for op in _convert if getattr(cls, op, None) is not getattr(object, op, None)}
   187|         0|            0|            0|  0.00%|    if not roots:
   188|         0|            0|            0|  0.00%|        raise ValueError('must define at least one ordering operation: < > <= >=')
   189|         0|            0|            0|  0.00%|    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__
   190|         0|            0|            0|  0.00%|    for opname, opfunc in _convert[root]:
   191|         0|            0|            0|  0.00%|        if opname not in roots:
   192|         0|            0|            0|  0.00%|            opfunc.__name__ = opname
   193|         0|            0|            0|  0.00%|            setattr(cls, opname, opfunc)
   194|         0|            0|            0|  0.00%|    return cls
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|################################################################################
   198|         0|            0|            0|  0.00%|### cmp_to_key() function converter
   199|         0|            0|            0|  0.00%|################################################################################
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|def cmp_to_key(mycmp):
   202|         0|            0|            0|  0.00%|    """Convert a cmp= function into a key= function"""
   203|         0|            0|            0|  0.00%|    class K(object):
   204|         0|            0|            0|  0.00%|        __slots__ = ['obj']
   205|         0|            0|            0|  0.00%|        def __init__(self, obj):
   206|         0|            0|            0|  0.00%|            self.obj = obj
   207|         0|            0|            0|  0.00%|        def __lt__(self, other):
   208|         0|            0|            0|  0.00%|            return mycmp(self.obj, other.obj) < 0
   209|         0|            0|            0|  0.00%|        def __gt__(self, other):
   210|         0|            0|            0|  0.00%|            return mycmp(self.obj, other.obj) > 0
   211|         0|            0|            0|  0.00%|        def __eq__(self, other):
   212|         0|            0|            0|  0.00%|            return mycmp(self.obj, other.obj) == 0
   213|         0|            0|            0|  0.00%|        def __le__(self, other):
   214|         0|            0|            0|  0.00%|            return mycmp(self.obj, other.obj) <= 0
   215|         0|            0|            0|  0.00%|        def __ge__(self, other):
   216|         0|            0|            0|  0.00%|            return mycmp(self.obj, other.obj) >= 0
   217|         0|            0|            0|  0.00%|        __hash__ = None
   218|         0|            0|            0|  0.00%|    return K
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|try:
   221|         0|            0|            0|  0.00%|    from _functools import cmp_to_key
   222|         0|            0|            0|  0.00%|except ImportError:
   223|         0|            0|            0|  0.00%|    pass
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|################################################################################
   227|         0|            0|            0|  0.00%|### reduce() sequence to a single item
   228|         0|            0|            0|  0.00%|################################################################################
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|_initial_missing = object()
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|def reduce(function, sequence, initial=_initial_missing):
   233|         0|            0|            0|  0.00%|    """
   234|         0|            0|            0|  0.00%|    reduce(function, sequence[, initial]) -> value
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    Apply a function of two arguments cumulatively to the items of a sequence,
   237|         0|            0|            0|  0.00%|    from left to right, so as to reduce the sequence to a single value.
   238|         0|            0|            0|  0.00%|    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
   239|         0|            0|            0|  0.00%|    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
   240|         0|            0|            0|  0.00%|    of the sequence in the calculation, and serves as a default when the
   241|         0|            0|            0|  0.00%|    sequence is empty.
   242|         0|            0|            0|  0.00%|    """
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    it = iter(sequence)
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|    if initial is _initial_missing:
   247|         0|            0|            0|  0.00%|        try:
   248|         0|            0|            0|  0.00%|            value = next(it)
   249|         0|            0|            0|  0.00%|        except StopIteration:
   250|         0|            0|            0|  0.00%|            raise TypeError("reduce() of empty sequence with no initial value") from None
   251|         0|            0|            0|  0.00%|    else:
   252|         0|            0|            0|  0.00%|        value = initial
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    for element in it:
   255|         0|            0|            0|  0.00%|        value = function(value, element)
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    return value
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|try:
   260|         0|            0|            0|  0.00%|    from _functools import reduce
   261|         0|            0|            0|  0.00%|except ImportError:
   262|         0|            0|            0|  0.00%|    pass
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|################################################################################
   266|         0|            0|            0|  0.00%|### partial() argument application
   267|         0|            0|            0|  0.00%|################################################################################
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|# Purely functional, no descriptor behaviour
   270|         0|            0|            0|  0.00%|class partial:
   271|         0|            0|            0|  0.00%|    """New function with partial application of the given arguments
   272|         0|            0|            0|  0.00%|    and keywords.
   273|         0|            0|            0|  0.00%|    """
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    __slots__ = "func", "args", "keywords", "__dict__", "__weakref__"
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|    def __new__(cls, func, /, *args, **keywords):
   278|         0|            0|            0|  0.00%|        if not callable(func):
   279|         0|            0|            0|  0.00%|            raise TypeError("the first argument must be callable")
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|        if hasattr(func, "func"):
   282|         0|            0|            0|  0.00%|            args = func.args + args
   283|         0|            0|            0|  0.00%|            keywords = {**func.keywords, **keywords}
   284|         0|            0|            0|  0.00%|            func = func.func
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|        self = super(partial, cls).__new__(cls)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|        self.func = func
   289|         0|            0|            0|  0.00%|        self.args = args
   290|         0|            0|            0|  0.00%|        self.keywords = keywords
   291|         0|            0|            0|  0.00%|        return self
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    def __call__(self, /, *args, **keywords):
   294|         0|            0|            0|  0.00%|        keywords = {**self.keywords, **keywords}
   295|         0|            0|            0|  0.00%|        return self.func(*self.args, *args, **keywords)
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    @recursive_repr()
   298|         0|            0|            0|  0.00%|    def __repr__(self):
   299|         0|            0|            0|  0.00%|        qualname = type(self).__qualname__
   300|         0|            0|            0|  0.00%|        args = [repr(self.func)]
   301|         0|            0|            0|  0.00%|        args.extend(repr(x) for x in self.args)
   302|         0|            0|            0|  0.00%|        args.extend(f"{k}={v!r}" for (k, v) in self.keywords.items())
   303|         0|            0|            0|  0.00%|        if type(self).__module__ == "functools":
   304|         0|            0|            0|  0.00%|            return f"functools.{qualname}({', '.join(args)})"
   305|         0|            0|            0|  0.00%|        return f"{qualname}({', '.join(args)})"
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    def __reduce__(self):
   308|         0|            0|            0|  0.00%|        return type(self), (self.func,), (self.func, self.args,
   309|         0|            0|            0|  0.00%|               self.keywords or None, self.__dict__ or None)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    def __setstate__(self, state):
   312|         0|            0|            0|  0.00%|        if not isinstance(state, tuple):
   313|         0|            0|            0|  0.00%|            raise TypeError("argument to __setstate__ must be a tuple")
   314|         0|            0|            0|  0.00%|        if len(state) != 4:
   315|         0|            0|            0|  0.00%|            raise TypeError(f"expected 4 items in state, got {len(state)}")
   316|         0|            0|            0|  0.00%|        func, args, kwds, namespace = state
   317|         0|            0|            0|  0.00%|        if (not callable(func) or not isinstance(args, tuple) or
   318|         0|            0|            0|  0.00%|           (kwds is not None and not isinstance(kwds, dict)) or
   319|         0|            0|            0|  0.00%|           (namespace is not None and not isinstance(namespace, dict))):
   320|         0|            0|            0|  0.00%|            raise TypeError("invalid partial state")
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|        args = tuple(args) # just in case it's a subclass
   323|         0|            0|            0|  0.00%|        if kwds is None:
   324|         0|            0|            0|  0.00%|            kwds = {}
   325|         0|            0|            0|  0.00%|        elif type(kwds) is not dict: # XXX does it need to be *exactly* dict?
   326|         0|            0|            0|  0.00%|            kwds = dict(kwds)
   327|         0|            0|            0|  0.00%|        if namespace is None:
   328|         0|            0|            0|  0.00%|            namespace = {}
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|        self.__dict__ = namespace
   331|         0|            0|            0|  0.00%|        self.func = func
   332|         0|            0|            0|  0.00%|        self.args = args
   333|         0|            0|            0|  0.00%|        self.keywords = kwds
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|try:
   336|         0|            0|            0|  0.00%|    from _functools import partial
   337|         0|            0|            0|  0.00%|except ImportError:
   338|         0|            0|            0|  0.00%|    pass
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|# Descriptor version
   341|         0|            0|            0|  0.00%|class partialmethod(object):
   342|         0|            0|            0|  0.00%|    """Method descriptor with partial application of the given arguments
   343|         0|            0|            0|  0.00%|    and keywords.
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    Supports wrapping existing descriptors and handles non-descriptor
   346|         0|            0|            0|  0.00%|    callables as instance methods.
   347|         0|            0|            0|  0.00%|    """
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|    def __init__(*args, **keywords):
   350|         0|            0|            0|  0.00%|        if len(args) >= 2:
   351|         0|            0|            0|  0.00%|            self, func, *args = args
   352|         0|            0|            0|  0.00%|        elif not args:
   353|         0|            0|            0|  0.00%|            raise TypeError("descriptor '__init__' of partialmethod "
   354|         0|            0|            0|  0.00%|                            "needs an argument")
   355|         0|            0|            0|  0.00%|        elif 'func' in keywords:
   356|         0|            0|            0|  0.00%|            func = keywords.pop('func')
   357|         0|            0|            0|  0.00%|            self, *args = args
   358|         0|            0|            0|  0.00%|            import warnings
   359|         0|            0|            0|  0.00%|            warnings.warn("Passing 'func' as keyword argument is deprecated",
   360|         0|            0|            0|  0.00%|                          DeprecationWarning, stacklevel=2)
   361|         0|            0|            0|  0.00%|        else:
   362|         0|            0|            0|  0.00%|            raise TypeError("type 'partialmethod' takes at least one argument, "
   363|         0|            0|            0|  0.00%|                            "got %d" % (len(args)-1))
   364|         0|            0|            0|  0.00%|        args = tuple(args)
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|        if not callable(func) and not hasattr(func, "__get__"):
   367|         0|            0|            0|  0.00%|            raise TypeError("{!r} is not callable or a descriptor"
   368|         0|            0|            0|  0.00%|                                 .format(func))
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|        # func could be a descriptor like classmethod which isn't callable,
   371|         0|            0|            0|  0.00%|        # so we can't inherit from partial (it verifies func is callable)
   372|         0|            0|            0|  0.00%|        if isinstance(func, partialmethod):
   373|         0|            0|            0|  0.00%|            # flattening is mandatory in order to place cls/self before all
   374|         0|            0|            0|  0.00%|            # other arguments
   375|         0|            0|            0|  0.00%|            # it's also more efficient since only one function will be called
   376|         0|            0|            0|  0.00%|            self.func = func.func
   377|         0|            0|            0|  0.00%|            self.args = func.args + args
   378|         0|            0|            0|  0.00%|            self.keywords = {**func.keywords, **keywords}
   379|         0|            0|            0|  0.00%|        else:
   380|         0|            0|            0|  0.00%|            self.func = func
   381|         0|            0|            0|  0.00%|            self.args = args
   382|         0|            0|            0|  0.00%|            self.keywords = keywords
   383|         0|            0|            0|  0.00%|    __init__.__text_signature__ = '($self, func, /, *args, **keywords)'
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    def __repr__(self):
   386|         0|            0|            0|  0.00%|        args = ", ".join(map(repr, self.args))
   387|         0|            0|            0|  0.00%|        keywords = ", ".join("{}={!r}".format(k, v)
   388|         0|            0|            0|  0.00%|                                 for k, v in self.keywords.items())
   389|         0|            0|            0|  0.00%|        format_string = "{module}.{cls}({func}, {args}, {keywords})"
   390|         0|            0|            0|  0.00%|        return format_string.format(module=self.__class__.__module__,
   391|         0|            0|            0|  0.00%|                                    cls=self.__class__.__qualname__,
   392|         0|            0|            0|  0.00%|                                    func=self.func,
   393|         0|            0|            0|  0.00%|                                    args=args,
   394|         0|            0|            0|  0.00%|                                    keywords=keywords)
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|    def _make_unbound_method(self):
   397|         0|            0|            0|  0.00%|        def _method(cls_or_self, /, *args, **keywords):
   398|         0|            0|            0|  0.00%|            keywords = {**self.keywords, **keywords}
   399|         0|            0|            0|  0.00%|            return self.func(cls_or_self, *self.args, *args, **keywords)
   400|         0|            0|            0|  0.00%|        _method.__isabstractmethod__ = self.__isabstractmethod__
   401|         0|            0|            0|  0.00%|        _method._partialmethod = self
   402|         0|            0|            0|  0.00%|        return _method
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    def __get__(self, obj, cls=None):
   405|         0|            0|            0|  0.00%|        get = getattr(self.func, "__get__", None)
   406|         0|            0|            0|  0.00%|        result = None
   407|         0|            0|            0|  0.00%|        if get is not None:
   408|         0|            0|            0|  0.00%|            new_func = get(obj, cls)
   409|         0|            0|            0|  0.00%|            if new_func is not self.func:
   410|         0|            0|            0|  0.00%|                # Assume __get__ returning something new indicates the
   411|         0|            0|            0|  0.00%|                # creation of an appropriate callable
   412|         0|            0|            0|  0.00%|                result = partial(new_func, *self.args, **self.keywords)
   413|         0|            0|            0|  0.00%|                try:
   414|         0|            0|            0|  0.00%|                    result.__self__ = new_func.__self__
   415|         0|            0|            0|  0.00%|                except AttributeError:
   416|         0|            0|            0|  0.00%|                    pass
   417|         0|            0|            0|  0.00%|        if result is None:
   418|         0|            0|            0|  0.00%|            # If the underlying descriptor didn't do anything, treat this
   419|         0|            0|            0|  0.00%|            # like an instance method
   420|         0|            0|            0|  0.00%|            result = self._make_unbound_method().__get__(obj, cls)
   421|         0|            0|            0|  0.00%|        return result
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    @property
   424|         0|            0|            0|  0.00%|    def __isabstractmethod__(self):
   425|         0|            0|            0|  0.00%|        return getattr(self.func, "__isabstractmethod__", False)
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|# Helper functions
   428|         0|            0|            0|  0.00%|
   429|         1|  6.67572e-06|  6.67572e-06|  0.00%|def _unwrap_partial(func):
   430|         1|  2.12193e-05|  2.12193e-05|  0.00%|    while isinstance(func, partial):
   431|         0|            0|            0|  0.00%|        func = func.func
   432|         1|  5.96046e-06|  5.96046e-06|  0.00%|    return func
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|################################################################################
   435|         0|            0|            0|  0.00%|### LRU Cache function decorator
   436|         0|            0|            0|  0.00%|################################################################################
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|_CacheInfo = namedtuple("CacheInfo", ["hits", "misses", "maxsize", "currsize"])
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|class _HashedSeq(list):
   441|         0|            0|            0|  0.00%|    """ This class guarantees that hash() will be called no more than once
   442|         0|            0|            0|  0.00%|        per element.  This is important because the lru_cache() will hash
   443|         0|            0|            0|  0.00%|        the key multiple times on a cache miss.
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    """
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    __slots__ = 'hashvalue'
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    def __init__(self, tup, hash=hash):
   450|         0|            0|            0|  0.00%|        self[:] = tup
   451|         0|            0|            0|  0.00%|        self.hashvalue = hash(tup)
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    def __hash__(self):
   454|         0|            0|            0|  0.00%|        return self.hashvalue
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|def _make_key(args, kwds, typed,
   457|         0|            0|            0|  0.00%|             kwd_mark = (object(),),
   458|         0|            0|            0|  0.00%|             fasttypes = {int, str},
   459|         0|            0|            0|  0.00%|             tuple=tuple, type=type, len=len):
   460|         0|            0|            0|  0.00%|    """Make a cache key from optionally typed positional and keyword arguments
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|    The key is constructed in a way that is flat as possible rather than
   463|         0|            0|            0|  0.00%|    as a nested structure that would take more memory.
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    If there is only a single argument and its data type is known to cache
   466|         0|            0|            0|  0.00%|    its hash value, then that argument is returned without a wrapper.  This
   467|         0|            0|            0|  0.00%|    saves space and improves lookup speed.
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|    """
   470|         0|            0|            0|  0.00%|    # All of code below relies on kwds preserving the order input by the user.
   471|         0|            0|            0|  0.00%|    # Formerly, we sorted() the kwds before looping.  The new way is *much*
   472|         0|            0|            0|  0.00%|    # faster; however, it means that f(x=1, y=2) will now be treated as a
   473|         0|            0|            0|  0.00%|    # distinct call from f(y=2, x=1) which will be cached separately.
   474|         0|            0|            0|  0.00%|    key = args
   475|         0|            0|            0|  0.00%|    if kwds:
   476|         0|            0|            0|  0.00%|        key += kwd_mark
   477|         0|            0|            0|  0.00%|        for item in kwds.items():
   478|         0|            0|            0|  0.00%|            key += item
   479|         0|            0|            0|  0.00%|    if typed:
   480|         0|            0|            0|  0.00%|        key += tuple(type(v) for v in args)
   481|         0|            0|            0|  0.00%|        if kwds:
   482|         0|            0|            0|  0.00%|            key += tuple(type(v) for v in kwds.values())
   483|         0|            0|            0|  0.00%|    elif len(key) == 1 and type(key[0]) in fasttypes:
   484|         0|            0|            0|  0.00%|        return key[0]
   485|         0|            0|            0|  0.00%|    return _HashedSeq(key)
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|def lru_cache(maxsize=128, typed=False):
   488|         0|            0|            0|  0.00%|    """Least-recently-used cache decorator.
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    If *maxsize* is set to None, the LRU features are disabled and the cache
   491|         0|            0|            0|  0.00%|    can grow without bound.
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    If *typed* is True, arguments of different types will be cached separately.
   494|         0|            0|            0|  0.00%|    For example, f(3.0) and f(3) will be treated as distinct calls with
   495|         0|            0|            0|  0.00%|    distinct results.
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    Arguments to the cached function must be hashable.
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    View the cache statistics named tuple (hits, misses, maxsize, currsize)
   500|         0|            0|            0|  0.00%|    with f.cache_info().  Clear the cache and statistics with f.cache_clear().
   501|         0|            0|            0|  0.00%|    Access the underlying function with f.__wrapped__.
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|    See:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|    """
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|    # Users should only access the lru_cache through its public API:
   508|         0|            0|            0|  0.00%|    #       cache_info, cache_clear, and f.__wrapped__
   509|         0|            0|            0|  0.00%|    # The internals of the lru_cache are encapsulated for thread safety and
   510|         0|            0|            0|  0.00%|    # to allow the implementation to change (including a possible C version).
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    if isinstance(maxsize, int):
   513|         0|            0|            0|  0.00%|        # Negative maxsize is treated as 0
   514|         0|            0|            0|  0.00%|        if maxsize < 0:
   515|         0|            0|            0|  0.00%|            maxsize = 0
   516|         0|            0|            0|  0.00%|    elif callable(maxsize) and isinstance(typed, bool):
   517|         0|            0|            0|  0.00%|        # The user_function was passed in directly via the maxsize argument
   518|         0|            0|            0|  0.00%|        user_function, maxsize = maxsize, 128
   519|         0|            0|            0|  0.00%|        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
   520|         0|            0|            0|  0.00%|        return update_wrapper(wrapper, user_function)
   521|         0|            0|            0|  0.00%|    elif maxsize is not None:
   522|         0|            0|            0|  0.00%|        raise TypeError(
   523|         0|            0|            0|  0.00%|            'Expected first argument to be an integer, a callable, or None')
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|    def decorating_function(user_function):
   526|         0|            0|            0|  0.00%|        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)
   527|         0|            0|            0|  0.00%|        return update_wrapper(wrapper, user_function)
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    return decorating_function
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):
   532|         0|            0|            0|  0.00%|    # Constants shared by all lru cache instances:
   533|         0|            0|            0|  0.00%|    sentinel = object()          # unique object used to signal cache misses
   534|         0|            0|            0|  0.00%|    make_key = _make_key         # build a key from the function arguments
   535|         0|            0|            0|  0.00%|    PREV, NEXT, KEY, RESULT = 0, 1, 2, 3   # names for the link fields
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|    cache = {}
   538|         0|            0|            0|  0.00%|    hits = misses = 0
   539|         0|            0|            0|  0.00%|    full = False
   540|         0|            0|            0|  0.00%|    cache_get = cache.get    # bound method to lookup a key or return None
   541|         0|            0|            0|  0.00%|    cache_len = cache.__len__  # get cache size without calling len()
   542|         0|            0|            0|  0.00%|    lock = RLock()           # because linkedlist updates aren't threadsafe
   543|         0|            0|            0|  0.00%|    root = []                # root of the circular doubly linked list
   544|         0|            0|            0|  0.00%|    root[:] = [root, root, None, None]     # initialize by pointing to self
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|    if maxsize == 0:
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|        def wrapper(*args, **kwds):
   549|         0|            0|            0|  0.00%|            # No caching -- just a statistics update
   550|         0|            0|            0|  0.00%|            nonlocal misses
   551|         0|            0|            0|  0.00%|            misses += 1
   552|         0|            0|            0|  0.00%|            result = user_function(*args, **kwds)
   553|         0|            0|            0|  0.00%|            return result
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|    elif maxsize is None:
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|        def wrapper(*args, **kwds):
   558|         0|            0|            0|  0.00%|            # Simple caching without ordering or size limit
   559|         0|            0|            0|  0.00%|            nonlocal hits, misses
   560|         0|            0|            0|  0.00%|            key = make_key(args, kwds, typed)
   561|         0|            0|            0|  0.00%|            result = cache_get(key, sentinel)
   562|         0|            0|            0|  0.00%|            if result is not sentinel:
   563|         0|            0|            0|  0.00%|                hits += 1
   564|         0|            0|            0|  0.00%|                return result
   565|         0|            0|            0|  0.00%|            misses += 1
   566|         0|            0|            0|  0.00%|            result = user_function(*args, **kwds)
   567|         0|            0|            0|  0.00%|            cache[key] = result
   568|         0|            0|            0|  0.00%|            return result
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|    else:
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|        def wrapper(*args, **kwds):
   573|         0|            0|            0|  0.00%|            # Size limited caching that tracks accesses by recency
   574|         0|            0|            0|  0.00%|            nonlocal root, hits, misses, full
   575|         0|            0|            0|  0.00%|            key = make_key(args, kwds, typed)
   576|         0|            0|            0|  0.00%|            with lock:
   577|         0|            0|            0|  0.00%|                link = cache_get(key)
   578|         0|            0|            0|  0.00%|                if link is not None:
   579|         0|            0|            0|  0.00%|                    # Move the link to the front of the circular queue
   580|         0|            0|            0|  0.00%|                    link_prev, link_next, _key, result = link
   581|         0|            0|            0|  0.00%|                    link_prev[NEXT] = link_next
   582|         0|            0|            0|  0.00%|                    link_next[PREV] = link_prev
   583|         0|            0|            0|  0.00%|                    last = root[PREV]
   584|         0|            0|            0|  0.00%|                    last[NEXT] = root[PREV] = link
   585|         0|            0|            0|  0.00%|                    link[PREV] = last
   586|         0|            0|            0|  0.00%|                    link[NEXT] = root
   587|         0|            0|            0|  0.00%|                    hits += 1
   588|         0|            0|            0|  0.00%|                    return result
   589|         0|            0|            0|  0.00%|                misses += 1
   590|         0|            0|            0|  0.00%|            result = user_function(*args, **kwds)
   591|         0|            0|            0|  0.00%|            with lock:
   592|         0|            0|            0|  0.00%|                if key in cache:
   593|         0|            0|            0|  0.00%|                    # Getting here means that this same key was added to the
   594|         0|            0|            0|  0.00%|                    # cache while the lock was released.  Since the link
   595|         0|            0|            0|  0.00%|                    # update is already done, we need only return the
   596|         0|            0|            0|  0.00%|                    # computed result and update the count of misses.
   597|         0|            0|            0|  0.00%|                    pass
   598|         0|            0|            0|  0.00%|                elif full:
   599|         0|            0|            0|  0.00%|                    # Use the old root to store the new key and result.
   600|         0|            0|            0|  0.00%|                    oldroot = root
   601|         0|            0|            0|  0.00%|                    oldroot[KEY] = key
   602|         0|            0|            0|  0.00%|                    oldroot[RESULT] = result
   603|         0|            0|            0|  0.00%|                    # Empty the oldest link and make it the new root.
   604|         0|            0|            0|  0.00%|                    # Keep a reference to the old key and old result to
   605|         0|            0|            0|  0.00%|                    # prevent their ref counts from going to zero during the
   606|         0|            0|            0|  0.00%|                    # update. That will prevent potentially arbitrary object
   607|         0|            0|            0|  0.00%|                    # clean-up code (i.e. __del__) from running while we're
   608|         0|            0|            0|  0.00%|                    # still adjusting the links.
   609|         0|            0|            0|  0.00%|                    root = oldroot[NEXT]
   610|         0|            0|            0|  0.00%|                    oldkey = root[KEY]
   611|         0|            0|            0|  0.00%|                    oldresult = root[RESULT]
   612|         0|            0|            0|  0.00%|                    root[KEY] = root[RESULT] = None
   613|         0|            0|            0|  0.00%|                    # Now update the cache dictionary.
   614|         0|            0|            0|  0.00%|                    del cache[oldkey]
   615|         0|            0|            0|  0.00%|                    # Save the potentially reentrant cache[key] assignment
   616|         0|            0|            0|  0.00%|                    # for last, after the root and links have been put in
   617|         0|            0|            0|  0.00%|                    # a consistent state.
   618|         0|            0|            0|  0.00%|                    cache[key] = oldroot
   619|         0|            0|            0|  0.00%|                else:
   620|         0|            0|            0|  0.00%|                    # Put result in a new link at the front of the queue.
   621|         0|            0|            0|  0.00%|                    last = root[PREV]
   622|         0|            0|            0|  0.00%|                    link = [last, root, key, result]
   623|         0|            0|            0|  0.00%|                    last[NEXT] = root[PREV] = cache[key] = link
   624|         0|            0|            0|  0.00%|                    # Use the cache_len bound method instead of the len() function
   625|         0|            0|            0|  0.00%|                    # which could potentially be wrapped in an lru_cache itself.
   626|         0|            0|            0|  0.00%|                    full = (cache_len() >= maxsize)
   627|         0|            0|            0|  0.00%|            return result
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|    def cache_info():
   630|         0|            0|            0|  0.00%|        """Report cache statistics"""
   631|         0|            0|            0|  0.00%|        with lock:
   632|         0|            0|            0|  0.00%|            return _CacheInfo(hits, misses, maxsize, cache_len())
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|    def cache_clear():
   635|         0|            0|            0|  0.00%|        """Clear the cache and cache statistics"""
   636|         0|            0|            0|  0.00%|        nonlocal hits, misses, full
   637|         0|            0|            0|  0.00%|        with lock:
   638|         0|            0|            0|  0.00%|            cache.clear()
   639|         0|            0|            0|  0.00%|            root[:] = [root, root, None, None]
   640|         0|            0|            0|  0.00%|            hits = misses = 0
   641|         0|            0|            0|  0.00%|            full = False
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    wrapper.cache_info = cache_info
   644|         0|            0|            0|  0.00%|    wrapper.cache_clear = cache_clear
   645|         0|            0|            0|  0.00%|    return wrapper
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|try:
   648|         0|            0|            0|  0.00%|    from _functools import _lru_cache_wrapper
   649|         0|            0|            0|  0.00%|except ImportError:
   650|         0|            0|            0|  0.00%|    pass
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|################################################################################
   654|         0|            0|            0|  0.00%|### singledispatch() - single-dispatch generic function decorator
   655|         0|            0|            0|  0.00%|################################################################################
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|def _c3_merge(sequences):
   658|         0|            0|            0|  0.00%|    """Merges MROs in *sequences* to a single MRO using the C3 algorithm.
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    Adapted from http://www.python.org/download/releases/2.3/mro/.
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|    """
   663|         0|            0|            0|  0.00%|    result = []
   664|         0|            0|            0|  0.00%|    while True:
   665|         0|            0|            0|  0.00%|        sequences = [s for s in sequences if s]   # purge empty sequences
   666|         0|            0|            0|  0.00%|        if not sequences:
   667|         0|            0|            0|  0.00%|            return result
   668|         0|            0|            0|  0.00%|        for s1 in sequences:   # find merge candidates among seq heads
   669|         0|            0|            0|  0.00%|            candidate = s1[0]
   670|         0|            0|            0|  0.00%|            for s2 in sequences:
   671|         0|            0|            0|  0.00%|                if candidate in s2[1:]:
   672|         0|            0|            0|  0.00%|                    candidate = None
   673|         0|            0|            0|  0.00%|                    break      # reject the current head, it appears later
   674|         0|            0|            0|  0.00%|            else:
   675|         0|            0|            0|  0.00%|                break
   676|         0|            0|            0|  0.00%|        if candidate is None:
   677|         0|            0|            0|  0.00%|            raise RuntimeError("Inconsistent hierarchy")
   678|         0|            0|            0|  0.00%|        result.append(candidate)
   679|         0|            0|            0|  0.00%|        # remove the chosen candidate
   680|         0|            0|            0|  0.00%|        for seq in sequences:
   681|         0|            0|            0|  0.00%|            if seq[0] == candidate:
   682|         0|            0|            0|  0.00%|                del seq[0]
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|def _c3_mro(cls, abcs=None):
   685|         0|            0|            0|  0.00%|    """Computes the method resolution order using extended C3 linearization.
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|    If no *abcs* are given, the algorithm works exactly like the built-in C3
   688|         0|            0|            0|  0.00%|    linearization used for method resolution.
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|    If given, *abcs* is a list of abstract base classes that should be inserted
   691|         0|            0|            0|  0.00%|    into the resulting MRO. Unrelated ABCs are ignored and don't end up in the
   692|         0|            0|            0|  0.00%|    result. The algorithm inserts ABCs where their functionality is introduced,
   693|         0|            0|            0|  0.00%|    i.e. issubclass(cls, abc) returns True for the class itself but returns
   694|         0|            0|            0|  0.00%|    False for all its direct base classes. Implicit ABCs for a given class
   695|         0|            0|            0|  0.00%|    (either registered or inferred from the presence of a special method like
   696|         0|            0|            0|  0.00%|    __len__) are inserted directly after the last ABC explicitly listed in the
   697|         0|            0|            0|  0.00%|    MRO of said class. If two implicit ABCs end up next to each other in the
   698|         0|            0|            0|  0.00%|    resulting MRO, their ordering depends on the order of types in *abcs*.
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    """
   701|         0|            0|            0|  0.00%|    for i, base in enumerate(reversed(cls.__bases__)):
   702|         0|            0|            0|  0.00%|        if hasattr(base, '__abstractmethods__'):
   703|         0|            0|            0|  0.00%|            boundary = len(cls.__bases__) - i
   704|         0|            0|            0|  0.00%|            break   # Bases up to the last explicit ABC are considered first.
   705|         0|            0|            0|  0.00%|    else:
   706|         0|            0|            0|  0.00%|        boundary = 0
   707|         0|            0|            0|  0.00%|    abcs = list(abcs) if abcs else []
   708|         0|            0|            0|  0.00%|    explicit_bases = list(cls.__bases__[:boundary])
   709|         0|            0|            0|  0.00%|    abstract_bases = []
   710|         0|            0|            0|  0.00%|    other_bases = list(cls.__bases__[boundary:])
   711|         0|            0|            0|  0.00%|    for base in abcs:
   712|         0|            0|            0|  0.00%|        if issubclass(cls, base) and not any(
   713|         0|            0|            0|  0.00%|                issubclass(b, base) for b in cls.__bases__
   714|         0|            0|            0|  0.00%|            ):
   715|         0|            0|            0|  0.00%|            # If *cls* is the class that introduces behaviour described by
   716|         0|            0|            0|  0.00%|            # an ABC *base*, insert said ABC to its MRO.
   717|         0|            0|            0|  0.00%|            abstract_bases.append(base)
   718|         0|            0|            0|  0.00%|    for base in abstract_bases:
   719|         0|            0|            0|  0.00%|        abcs.remove(base)
   720|         0|            0|            0|  0.00%|    explicit_c3_mros = [_c3_mro(base, abcs=abcs) for base in explicit_bases]
   721|         0|            0|            0|  0.00%|    abstract_c3_mros = [_c3_mro(base, abcs=abcs) for base in abstract_bases]
   722|         0|            0|            0|  0.00%|    other_c3_mros = [_c3_mro(base, abcs=abcs) for base in other_bases]
   723|         0|            0|            0|  0.00%|    return _c3_merge(
   724|         0|            0|            0|  0.00%|        [[cls]] +
   725|         0|            0|            0|  0.00%|        explicit_c3_mros + abstract_c3_mros + other_c3_mros +
   726|         0|            0|            0|  0.00%|        [explicit_bases] + [abstract_bases] + [other_bases]
   727|         0|            0|            0|  0.00%|    )
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|def _compose_mro(cls, types):
   730|         0|            0|            0|  0.00%|    """Calculates the method resolution order for a given class *cls*.
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|    Includes relevant abstract base classes (with their respective bases) from
   733|         0|            0|            0|  0.00%|    the *types* iterable. Uses a modified C3 linearization algorithm.
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|    """
   736|         0|            0|            0|  0.00%|    bases = set(cls.__mro__)
   737|         0|            0|            0|  0.00%|    # Remove entries which are already present in the __mro__ or unrelated.
   738|         0|            0|            0|  0.00%|    def is_related(typ):
   739|         0|            0|            0|  0.00%|        return (typ not in bases and hasattr(typ, '__mro__')
   740|         0|            0|            0|  0.00%|                                 and issubclass(cls, typ))
   741|         0|            0|            0|  0.00%|    types = [n for n in types if is_related(n)]
   742|         0|            0|            0|  0.00%|    # Remove entries which are strict bases of other entries (they will end up
   743|         0|            0|            0|  0.00%|    # in the MRO anyway.
   744|         0|            0|            0|  0.00%|    def is_strict_base(typ):
   745|         0|            0|            0|  0.00%|        for other in types:
   746|         0|            0|            0|  0.00%|            if typ != other and typ in other.__mro__:
   747|         0|            0|            0|  0.00%|                return True
   748|         0|            0|            0|  0.00%|        return False
   749|         0|            0|            0|  0.00%|    types = [n for n in types if not is_strict_base(n)]
   750|         0|            0|            0|  0.00%|    # Subclasses of the ABCs in *types* which are also implemented by
   751|         0|            0|            0|  0.00%|    # *cls* can be used to stabilize ABC ordering.
   752|         0|            0|            0|  0.00%|    type_set = set(types)
   753|         0|            0|            0|  0.00%|    mro = []
   754|         0|            0|            0|  0.00%|    for typ in types:
   755|         0|            0|            0|  0.00%|        found = []
   756|         0|            0|            0|  0.00%|        for sub in typ.__subclasses__():
   757|         0|            0|            0|  0.00%|            if sub not in bases and issubclass(cls, sub):
   758|         0|            0|            0|  0.00%|                found.append([s for s in sub.__mro__ if s in type_set])
   759|         0|            0|            0|  0.00%|        if not found:
   760|         0|            0|            0|  0.00%|            mro.append(typ)
   761|         0|            0|            0|  0.00%|            continue
   762|         0|            0|            0|  0.00%|        # Favor subclasses with the biggest number of useful bases
   763|         0|            0|            0|  0.00%|        found.sort(key=len, reverse=True)
   764|         0|            0|            0|  0.00%|        for sub in found:
   765|         0|            0|            0|  0.00%|            for subcls in sub:
   766|         0|            0|            0|  0.00%|                if subcls not in mro:
   767|         0|            0|            0|  0.00%|                    mro.append(subcls)
   768|         0|            0|            0|  0.00%|    return _c3_mro(cls, abcs=mro)
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|def _find_impl(cls, registry):
   771|         0|            0|            0|  0.00%|    """Returns the best matching implementation from *registry* for type *cls*.
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|    Where there is no registered implementation for a specific type, its method
   774|         0|            0|            0|  0.00%|    resolution order is used to find a more generic implementation.
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|    Note: if *registry* does not contain an implementation for the base
   777|         0|            0|            0|  0.00%|    *object* type, this function may return None.
   778|         0|            0|            0|  0.00%|
   779|         0|            0|            0|  0.00%|    """
   780|         0|            0|            0|  0.00%|    mro = _compose_mro(cls, registry.keys())
   781|         0|            0|            0|  0.00%|    match = None
   782|         0|            0|            0|  0.00%|    for t in mro:
   783|         0|            0|            0|  0.00%|        if match is not None:
   784|         0|            0|            0|  0.00%|            # If *match* is an implicit ABC but there is another unrelated,
   785|         0|            0|            0|  0.00%|            # equally matching implicit ABC, refuse the temptation to guess.
   786|         0|            0|            0|  0.00%|            if (t in registry and t not in cls.__mro__
   787|         0|            0|            0|  0.00%|                              and match not in cls.__mro__
   788|         0|            0|            0|  0.00%|                              and not issubclass(match, t)):
   789|         0|            0|            0|  0.00%|                raise RuntimeError("Ambiguous dispatch: {} or {}".format(
   790|         0|            0|            0|  0.00%|                    match, t))
   791|         0|            0|            0|  0.00%|            break
   792|         0|            0|            0|  0.00%|        if t in registry:
   793|         0|            0|            0|  0.00%|            match = t
   794|         0|            0|            0|  0.00%|    return registry.get(match)
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|def singledispatch(func):
   797|         0|            0|            0|  0.00%|    """Single-dispatch generic function decorator.
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|    Transforms a function into a generic function, which can have different
   800|         0|            0|            0|  0.00%|    behaviours depending upon the type of its first argument. The decorated
   801|         0|            0|            0|  0.00%|    function acts as the default implementation, and additional
   802|         0|            0|            0|  0.00%|    implementations can be registered using the register() attribute of the
   803|         0|            0|            0|  0.00%|    generic function.
   804|         0|            0|            0|  0.00%|    """
   805|         0|            0|            0|  0.00%|    # There are many programs that use functools without singledispatch, so we
   806|         0|            0|            0|  0.00%|    # trade-off making singledispatch marginally slower for the benefit of
   807|         0|            0|            0|  0.00%|    # making start-up of such applications slightly faster.
   808|         0|            0|            0|  0.00%|    import types, weakref
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    registry = {}
   811|         0|            0|            0|  0.00%|    dispatch_cache = weakref.WeakKeyDictionary()
   812|         0|            0|            0|  0.00%|    cache_token = None
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    def dispatch(cls):
   815|         0|            0|            0|  0.00%|        """generic_func.dispatch(cls) -> <function implementation>
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|        Runs the dispatch algorithm to return the best available implementation
   818|         0|            0|            0|  0.00%|        for the given *cls* registered on *generic_func*.
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|        """
   821|         0|            0|            0|  0.00%|        nonlocal cache_token
   822|         0|            0|            0|  0.00%|        if cache_token is not None:
   823|         0|            0|            0|  0.00%|            current_token = get_cache_token()
   824|         0|            0|            0|  0.00%|            if cache_token != current_token:
   825|         0|            0|            0|  0.00%|                dispatch_cache.clear()
   826|         0|            0|            0|  0.00%|                cache_token = current_token
   827|         0|            0|            0|  0.00%|        try:
   828|         0|            0|            0|  0.00%|            impl = dispatch_cache[cls]
   829|         0|            0|            0|  0.00%|        except KeyError:
   830|         0|            0|            0|  0.00%|            try:
   831|         0|            0|            0|  0.00%|                impl = registry[cls]
   832|         0|            0|            0|  0.00%|            except KeyError:
   833|         0|            0|            0|  0.00%|                impl = _find_impl(cls, registry)
   834|         0|            0|            0|  0.00%|            dispatch_cache[cls] = impl
   835|         0|            0|            0|  0.00%|        return impl
   836|         0|            0|            0|  0.00%|
   837|         0|            0|            0|  0.00%|    def register(cls, func=None):
   838|         0|            0|            0|  0.00%|        """generic_func.register(cls, func) -> func
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|        Registers a new implementation for the given *cls* on a *generic_func*.
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|        """
   843|         0|            0|            0|  0.00%|        nonlocal cache_token
   844|         0|            0|            0|  0.00%|        if func is None:
   845|         0|            0|            0|  0.00%|            if isinstance(cls, type):
   846|         0|            0|            0|  0.00%|                return lambda f: register(cls, f)
   847|         0|            0|            0|  0.00%|            ann = getattr(cls, '__annotations__', {})
   848|         0|            0|            0|  0.00%|            if not ann:
   849|         0|            0|            0|  0.00%|                raise TypeError(
   850|         0|            0|            0|  0.00%|                    f"Invalid first argument to `register()`: {cls!r}. "
   851|         0|            0|            0|  0.00%|                    f"Use either `@register(some_class)` or plain `@register` "
   852|         0|            0|            0|  0.00%|                    f"on an annotated function."
   853|         0|            0|            0|  0.00%|                )
   854|         0|            0|            0|  0.00%|            func = cls
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|            # only import typing if annotation parsing is necessary
   857|         0|            0|            0|  0.00%|            from typing import get_type_hints
   858|         0|            0|            0|  0.00%|            argname, cls = next(iter(get_type_hints(func).items()))
   859|         0|            0|            0|  0.00%|            if not isinstance(cls, type):
   860|         0|            0|            0|  0.00%|                raise TypeError(
   861|         0|            0|            0|  0.00%|                    f"Invalid annotation for {argname!r}. "
   862|         0|            0|            0|  0.00%|                    f"{cls!r} is not a class."
   863|         0|            0|            0|  0.00%|                )
   864|         0|            0|            0|  0.00%|        registry[cls] = func
   865|         0|            0|            0|  0.00%|        if cache_token is None and hasattr(cls, '__abstractmethods__'):
   866|         0|            0|            0|  0.00%|            cache_token = get_cache_token()
   867|         0|            0|            0|  0.00%|        dispatch_cache.clear()
   868|         0|            0|            0|  0.00%|        return func
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    def wrapper(*args, **kw):
   871|         0|            0|            0|  0.00%|        if not args:
   872|         0|            0|            0|  0.00%|            raise TypeError(f'{funcname} requires at least '
   873|         0|            0|            0|  0.00%|                            '1 positional argument')
   874|         0|            0|            0|  0.00%|
   875|         0|            0|            0|  0.00%|        return dispatch(args[0].__class__)(*args, **kw)
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|    funcname = getattr(func, '__name__', 'singledispatch function')
   878|         0|            0|            0|  0.00%|    registry[object] = func
   879|         0|            0|            0|  0.00%|    wrapper.register = register
   880|         0|            0|            0|  0.00%|    wrapper.dispatch = dispatch
   881|         0|            0|            0|  0.00%|    wrapper.registry = types.MappingProxyType(registry)
   882|         0|            0|            0|  0.00%|    wrapper._clear_cache = dispatch_cache.clear
   883|         0|            0|            0|  0.00%|    update_wrapper(wrapper, func)
   884|         0|            0|            0|  0.00%|    return wrapper
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|# Descriptor version
   888|         0|            0|            0|  0.00%|class singledispatchmethod:
   889|         0|            0|            0|  0.00%|    """Single-dispatch generic method descriptor.
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|    Supports wrapping existing descriptors and handles non-descriptor
   892|         0|            0|            0|  0.00%|    callables as instance methods.
   893|         0|            0|            0|  0.00%|    """
   894|         0|            0|            0|  0.00%|
   895|         0|            0|            0|  0.00%|    def __init__(self, func):
   896|         0|            0|            0|  0.00%|        if not callable(func) and not hasattr(func, "__get__"):
   897|         0|            0|            0|  0.00%|            raise TypeError(f"{func!r} is not callable or a descriptor")
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|        self.dispatcher = singledispatch(func)
   900|         0|            0|            0|  0.00%|        self.func = func
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|    def register(self, cls, method=None):
   903|         0|            0|            0|  0.00%|        """generic_method.register(cls, func) -> func
   904|         0|            0|            0|  0.00%|
   905|         0|            0|            0|  0.00%|        Registers a new implementation for the given *cls* on a *generic_method*.
   906|         0|            0|            0|  0.00%|        """
   907|         0|            0|            0|  0.00%|        return self.dispatcher.register(cls, func=method)
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    def __get__(self, obj, cls=None):
   910|         0|            0|            0|  0.00%|        def _method(*args, **kwargs):
   911|         0|            0|            0|  0.00%|            method = self.dispatcher.dispatch(args[0].__class__)
   912|         0|            0|            0|  0.00%|            return method.__get__(obj, cls)(*args, **kwargs)
   913|         0|            0|            0|  0.00%|
   914|         0|            0|            0|  0.00%|        _method.__isabstractmethod__ = self.__isabstractmethod__
   915|         0|            0|            0|  0.00%|        _method.register = self.register
   916|         0|            0|            0|  0.00%|        update_wrapper(_method, self.func)
   917|         0|            0|            0|  0.00%|        return _method
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|    @property
   920|         0|            0|            0|  0.00%|    def __isabstractmethod__(self):
   921|         0|            0|            0|  0.00%|        return getattr(self.func, '__isabstractmethod__', False)
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|################################################################################
   925|         0|            0|            0|  0.00%|### cached_property() - computed once per instance, cached as attribute
   926|         0|            0|            0|  0.00%|################################################################################
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|_NOT_FOUND = object()
   929|         0|            0|            0|  0.00%|
   930|         0|            0|            0|  0.00%|
   931|         0|            0|            0|  0.00%|class cached_property:
   932|         0|            0|            0|  0.00%|    def __init__(self, func):
   933|         0|            0|            0|  0.00%|        self.func = func
   934|         0|            0|            0|  0.00%|        self.attrname = None
   935|         0|            0|            0|  0.00%|        self.__doc__ = func.__doc__
   936|         0|            0|            0|  0.00%|        self.lock = RLock()
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|    def __set_name__(self, owner, name):
   939|         0|            0|            0|  0.00%|        if self.attrname is None:
   940|         0|            0|            0|  0.00%|            self.attrname = name
   941|         0|            0|            0|  0.00%|        elif name != self.attrname:
   942|         0|            0|            0|  0.00%|            raise TypeError(
   943|         0|            0|            0|  0.00%|                "Cannot assign the same cached_property to two different names "
   944|         0|            0|            0|  0.00%|                f"({self.attrname!r} and {name!r})."
   945|         0|            0|            0|  0.00%|            )
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|    def __get__(self, instance, owner=None):
   948|         0|            0|            0|  0.00%|        if instance is None:
   949|         0|            0|            0|  0.00%|            return self
   950|         0|            0|            0|  0.00%|        if self.attrname is None:
   951|         0|            0|            0|  0.00%|            raise TypeError(
   952|         0|            0|            0|  0.00%|                "Cannot use cached_property instance without calling __set_name__ on it.")
   953|         0|            0|            0|  0.00%|        try:
   954|         0|            0|            0|  0.00%|            cache = instance.__dict__
   955|         0|            0|            0|  0.00%|        except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
   956|         0|            0|            0|  0.00%|            msg = (
   957|         0|            0|            0|  0.00%|                f"No '__dict__' attribute on {type(instance).__name__!r} "
   958|         0|            0|            0|  0.00%|                f"instance to cache {self.attrname!r} property."
   959|         0|            0|            0|  0.00%|            )
   960|         0|            0|            0|  0.00%|            raise TypeError(msg) from None
   961|         0|            0|            0|  0.00%|        val = cache.get(self.attrname, _NOT_FOUND)
   962|         0|            0|            0|  0.00%|        if val is _NOT_FOUND:
   963|         0|            0|            0|  0.00%|            with self.lock:
   964|         0|            0|            0|  0.00%|                # check if another thread filled cache while we awaited lock
   965|         0|            0|            0|  0.00%|                val = cache.get(self.attrname, _NOT_FOUND)
   966|         0|            0|            0|  0.00%|                if val is _NOT_FOUND:
   967|         0|            0|            0|  0.00%|                    val = self.func(instance)
   968|         0|            0|            0|  0.00%|                    try:
   969|         0|            0|            0|  0.00%|                        cache[self.attrname] = val
   970|         0|            0|            0|  0.00%|                    except TypeError:
   971|         0|            0|            0|  0.00%|                        msg = (
   972|         0|            0|            0|  0.00%|                            f"The '__dict__' attribute on {type(instance).__name__!r} instance "
   973|         0|            0|            0|  0.00%|                            f"does not support item assignment for caching {self.attrname!r} property."
   974|         0|            0|            0|  0.00%|                        )
   975|         0|            0|            0|  0.00%|                        raise TypeError(msg) from None
   976|         0|            0|            0|  0.00%|        return val
File: main.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# Source: https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html
     2|         0|            0|            0|  0.00%|# --WITH CHANGES
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|# License: BSD
     5|         0|            0|            0|  0.00%|# Author: Sasank Chilamkurthy
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|from __future__ import print_function, division
     8|         0|            0|            0|  0.00%|import realtime_monitoring
     9|         0|            0|            0|  0.00%|import torch
    10|         0|            0|            0|  0.00%|from memory_profiler import profile
    11|         0|            0|            0|  0.00%|import io
    12|         0|            0|            0|  0.00%|import pprofile
    13|         0|            0|            0|  0.00%|import cProfile, pstats, sys
    14|         0|            0|            0|  0.00%|import pyRAPL
    15|         0|            0|            0|  0.00%|import psutil
    16|         0|            0|            0|  0.00%|import pandas as pd
    17|         0|            0|            0|  0.00%|import zipfile
    18|         0|            0|            0|  0.00%|import torch.nn as nn
    19|         0|            0|            0|  0.00%|import torch.optim as optim
    20|         0|            0|            0|  0.00%|from torch.optim import lr_scheduler
    21|         0|            0|            0|  0.00%|import numpy as np
    22|         0|            0|            0|  0.00%|import torchvision
    23|         0|            0|            0|  0.00%|from torchvision import datasets, models, transforms
    24|         0|            0|            0|  0.00%|import matplotlib.pyplot as plt
    25|         0|            0|            0|  0.00%|import time
    26|         0|            0|            0|  0.00%|import os
    27|         0|            0|            0|  0.00%|import copy
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|# def imshow(inp, title=None):
    30|         0|            0|            0|  0.00%|#     """Imshow for Tensor."""
    31|         0|            0|            0|  0.00%|#     inp = inp.numpy().transpose((1, 2, 0))
    32|         0|            0|            0|  0.00%|#     mean = np.array([0.485, 0.456, 0.406])
    33|         0|            0|            0|  0.00%|#     std = np.array([0.229, 0.224, 0.225])
    34|         0|            0|            0|  0.00%|#     inp = std * inp + mean
    35|         0|            0|            0|  0.00%|#     inp = np.clip(inp, 0, 1)
    36|         0|            0|            0|  0.00%|#     plt.imshow(inp)
    37|         0|            0|            0|  0.00%|#     if title is not None:
    38|         0|            0|            0|  0.00%|#         plt.title(title)
    39|         0|            0|            0|  0.00%|#     plt.pause(0.001)  # pause a bit so that plots are updated
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|# pyRAPL.setup()
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|# csv_output = pyRAPL.outputs.CSVOutput('energy_pyRAPL.csv')
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|# @pyRAPL.measure(output=csv_output)
    46|         0|            0|            0|  0.00%|@profile(precision=3)
    47|         0|            0|            0|  0.00%|def train_model(model, criterion, optimizer, scheduler, num_epochs=1):
    48|         0|            0|            0|  0.00%|    since = time.time()
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    best_model_wts = copy.deepcopy(model.state_dict())
    51|         0|            0|            0|  0.00%|    best_acc = 0.0
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|    for epoch in range(num_epochs):
    54|         0|            0|            0|  0.00%|        # s = realtime_monitoring.intermediate()
    55|         0|            0|            0|  0.00%|        print('Epoch {}/{}'.format(epoch, num_epochs - 1))
    56|         0|            0|            0|  0.00%|        print('-' * 10)
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|        # Each epoch has a training and validation phase
    59|         0|            0|            0|  0.00%|        for phase in ['train', 'val']:
    60|         0|            0|            0|  0.00%|            if phase == 'train':
    61|         0|            0|            0|  0.00%|                model.train()  # Set model to training mode
    62|         0|            0|            0|  0.00%|            else:
    63|         0|            0|            0|  0.00%|                model.eval()   # Set model to evaluate mode
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|            running_loss = 0.0
    66|         0|            0|            0|  0.00%|            running_corrects = 0
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|            # Iterate over data.
    69|         0|            0|            0|  0.00%|            for inputs, labels in dataloaders[phase]:
    70|         0|            0|            0|  0.00%|                inputs = inputs.to(device)
    71|         0|            0|            0|  0.00%|                labels = labels.to(device)
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|                # zero the parameter gradients
    74|         0|            0|            0|  0.00%|                optimizer.zero_grad()
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|                # forward
    77|         0|            0|            0|  0.00%|                # track history if only in train
    78|         0|            0|            0|  0.00%|                with torch.set_grad_enabled(phase == 'train'):
    79|         0|            0|            0|  0.00%|                    outputs = model(inputs)
    80|         0|            0|            0|  0.00%|                    _, preds = torch.max(outputs, 1)
    81|         0|            0|            0|  0.00%|                    loss = criterion(outputs, labels)
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|                    # backward + optimize only if in training phase
    84|         0|            0|            0|  0.00%|                    if phase == 'train':
    85|         0|            0|            0|  0.00%|                        loss.backward()
    86|         0|            0|            0|  0.00%|                        optimizer.step()
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|                # statistics
    89|         0|            0|            0|  0.00%|                running_loss += loss.item() * inputs.size(0)
    90|         0|            0|            0|  0.00%|                running_corrects += torch.sum(preds == labels.data)
    91|         0|            0|            0|  0.00%|            if phase == 'train':
    92|         0|            0|            0|  0.00%|                scheduler.step()
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|            epoch_loss = running_loss / dataset_sizes[phase]
    95|         0|            0|            0|  0.00%|            epoch_acc = running_corrects.double() / dataset_sizes[phase]
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|            print('{} Loss: {:.4f} Acc: {:.4f}'.format(
    98|         0|            0|            0|  0.00%|                phase, epoch_loss, epoch_acc))
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|            # deep copy the model
   101|         0|            0|            0|  0.00%|            if phase == 'val' and epoch_acc > best_acc:
   102|         0|            0|            0|  0.00%|                best_acc = epoch_acc
   103|         0|            0|            0|  0.00%|                best_model_wts = copy.deepcopy(model.state_dict())
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|        print()
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    time_elapsed = time.time() - since
   108|         0|            0|            0|  0.00%|    print('Training complete in {:.0f}m {:.0f}s'.format(
   109|         0|            0|            0|  0.00%|        time_elapsed // 60, time_elapsed % 60))
   110|         0|            0|            0|  0.00%|    print('Best val Acc: {:4f}'.format(best_acc))
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|    # load best model weights
   113|         0|            0|            0|  0.00%|    model.load_state_dict(best_model_wts)
   114|         0|            0|            0|  0.00%|    return model
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|# def visualize_model(model, num_images=6):
   117|         0|            0|            0|  0.00%|#     was_training = model.training
   118|         0|            0|            0|  0.00%|#     model.eval()
   119|         0|            0|            0|  0.00%|#     images_so_far = 0
   120|         0|            0|            0|  0.00%|#     fig = plt.figure()
   121|         0|            0|            0|  0.00%|#
   122|         0|            0|            0|  0.00%|#     with torch.no_grad():
   123|         0|            0|            0|  0.00%|#         for i, (inputs, labels) in enumerate(dataloaders['val']):
   124|         0|            0|            0|  0.00%|#             inputs = inputs.to(device)
   125|         0|            0|            0|  0.00%|#             labels = labels.to(device)
   126|         0|            0|            0|  0.00%|#
   127|         0|            0|            0|  0.00%|#             outputs = model(inputs)
   128|         0|            0|            0|  0.00%|#             _, preds = torch.max(outputs, 1)
   129|         0|            0|            0|  0.00%|#
   130|         0|            0|            0|  0.00%|#             for j in range(inputs.size()[0]):
   131|         0|            0|            0|  0.00%|#                 images_so_far += 1
   132|         0|            0|            0|  0.00%|#                 ax = plt.subplot(num_images//2, 2, images_so_far)
   133|         0|            0|            0|  0.00%|#                 ax.axis('off')
   134|         0|            0|            0|  0.00%|#                 ax.set_title('predicted: {}'.format(class_names[preds[j]]))
   135|         0|            0|            0|  0.00%|#                 # imshow(inputs.cpu().data[j])
   136|         0|            0|            0|  0.00%|#
   137|         0|            0|            0|  0.00%|#                 if images_so_far == num_images:
   138|         0|            0|            0|  0.00%|#                     model.train(mode=was_training)
   139|         0|            0|            0|  0.00%|#                     return
   140|         0|            0|            0|  0.00%|#         model.train(mode=was_training)
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|if __name__ == '__main__':
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    plt.ion()   # interactive mode
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    zip = zipfile.ZipFile('hymenoptera_data.zip')
   147|         0|            0|            0|  0.00%|    zip.extractall()
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    # Data augmentation and normalization for training
   150|         0|            0|            0|  0.00%|    # Just normalization for validation
   151|         0|            0|            0|  0.00%|    data_transforms = {
   152|         0|            0|            0|  0.00%|        'train': transforms.Compose([
   153|         0|            0|            0|  0.00%|            transforms.RandomResizedCrop(224),
   154|         0|            0|            0|  0.00%|            transforms.RandomHorizontalFlip(),
   155|         0|            0|            0|  0.00%|            transforms.ToTensor(),
   156|         0|            0|            0|  0.00%|            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
   157|         0|            0|            0|  0.00%|        ]),
   158|         0|            0|            0|  0.00%|        'val': transforms.Compose([
   159|         0|            0|            0|  0.00%|            transforms.Resize(256),
   160|         0|            0|            0|  0.00%|            transforms.CenterCrop(224),
   161|         0|            0|            0|  0.00%|            transforms.ToTensor(),
   162|         0|            0|            0|  0.00%|            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
   163|         0|            0|            0|  0.00%|        ]),
   164|         0|            0|            0|  0.00%|    }
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    data_dir = 'hymenoptera_data'
   167|         0|            0|            0|  0.00%|    image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),
   168|         0|            0|            0|  0.00%|                                              data_transforms[x])
   169|         0|            0|            0|  0.00%|                      for x in ['train', 'val']}
   170|         0|            0|            0|  0.00%|    dataloaders = {x: torch.utils.data.DataLoader(image_datasets[x], batch_size=4,
   171|         0|            0|            0|  0.00%|                                                 shuffle=True, num_workers=4)
   172|         0|            0|            0|  0.00%|                  for x in ['train', 'val']}
   173|         0|            0|            0|  0.00%|    dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'val']}
   174|         0|            0|            0|  0.00%|    class_names = image_datasets['train'].classes
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    # Get a batch of training data
   180|         0|            0|            0|  0.00%|    inputs, classes = next(iter(dataloaders['train']))
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    # Make a grid from batch
   183|         0|            0|            0|  0.00%|    out = torchvision.utils.make_grid(inputs)
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    # imshow(out, title=[class_names[x] for x in classes])
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|    # model_ft = models.resnet18(pretrained=True)
   190|         0|            0|            0|  0.00%|    # torch.save(model_ft, "resnet18.pt")
   191|         0|            0|            0|  0.00%|    model_ft = torch.load("resnet18.pt")
   192|         0|            0|            0|  0.00%|    num_ftrs = model_ft.fc.in_features
   193|         0|            0|            0|  0.00%|    # Here the size of each output sample is set to 2.
   194|         0|            0|            0|  0.00%|    # Alternatively, it can be generalized to nn.Linear(num_ftrs, len(class_names)).
   195|         0|            0|            0|  0.00%|    model_ft.fc = nn.Linear(num_ftrs, 2)
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    model_ft = model_ft.to(device)
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    criterion = nn.CrossEntropyLoss()
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    # Observe that all parameters are being optimized
   202|         0|            0|            0|  0.00%|    optimizer_ft = optim.SGD(model_ft.parameters(), lr=0.001, momentum=0.9)
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    # Decay LR by a factor of 0.1 every 7 epochs
   205|         0|            0|            0|  0.00%|    exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=7, gamma=0.1)
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    # gives a single float value
   209|         0|            0|            0|  0.00%|    cpu_per_b = psutil.cpu_percent()
   210|         0|            0|            0|  0.00%|    # gives an object with many fields
   211|         0|            0|            0|  0.00%|    # vir_mem_b = psutil.virtual_memory()
   212|         0|            0|            0|  0.00%|    # you can convert that object to a dictionary
   213|         0|            0|            0|  0.00%|    vir_mem_b = dict(psutil.virtual_memory()._asdict())
   214|         0|            0|            0|  0.00%|    # you can have the percentage of used RAM
   215|         0|            0|            0|  0.00%|    vir_mem_per_b = psutil.virtual_memory().percent
   216|         0|            0|            0|  0.00%|    # you can calculate percentage of available memory
   217|         0|            0|            0|  0.00%|    mem_av_per_b = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    profiler = pprofile.Profile()
   221|         0|            0|            0|  0.00%|    pr = cProfile.Profile()
   222|         0|            0|            0|  0.00%|    pr.enable()
   223|         0|            0|            0|  0.00%|    start_train = time.time()
   224|         0|            0|            0|  0.00%|    with profiler:
   225|         0|            0|            0|  0.00%|        model_ft = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,
(call)|         1|   0.00673103|   0.00673103|  0.00%|# /opt/conda/lib/python3.8/site-packages/memory_profiler.py:1140 wrapper
   226|         0|            0|            0|  0.00%|                           num_epochs=1)
   227|         0|            0|            0|  0.00%|        # csv_output.save()
   228|         0|            0|            0|  0.00%|    end_train = time.time()
   229|         0|            0|            0|  0.00%|    pr.disable()
   230|         0|            0|            0|  0.00%|    elapsed_time = end_train-start_train
   231|         0|            0|            0|  0.00%|    with open('Elapsed_time.txt', 'w') as f1:
   232|         0|            0|            0|  0.00%|        f1.write("Training Time(Elapsed):")
   233|         0|            0|            0|  0.00%|        f1.write(str(elapsed_time))
   234|         0|            0|            0|  0.00%|    f1.close()
   235|         0|            0|            0|  0.00%|    # gives a single float value
   236|         0|            0|            0|  0.00%|    # profiler.print_stats()
   237|         0|            0|            0|  0.00%|    # Or to a file:
   238|         0|            0|            0|  0.00%|    profiler.dump_stats("exec_time.txt")
   239|         0|            0|            0|  0.00%|    cpu_per_a = psutil.cpu_percent()
   240|         0|            0|            0|  0.00%|    # gives an object with many fields
   241|         0|            0|            0|  0.00%|    # vir_mem_a = psutil.virtual_memory()
   242|         0|            0|            0|  0.00%|    # you can convert that object to a dictionary
   243|         0|            0|            0|  0.00%|    vir_mem_a = dict(psutil.virtual_memory()._asdict())
   244|         0|            0|            0|  0.00%|    # you can have the percentage of used RAM
   245|         0|            0|            0|  0.00%|    vir_mem_per_a = psutil.virtual_memory().percent
   246|         0|            0|            0|  0.00%|    # you can calculate percentage of available memory
   247|         0|            0|            0|  0.00%|    mem_av_per_a = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|    # ps.print_stats()
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    # CPU_table = [["CPU Usage Percent", cpu_per_b, cpu_per_a], ["Memory Used", vir_mem_b, vir_mem_a],
   252|         0|            0|            0|  0.00%|    #          ["Memory Used(%)", vir_mem_per_b, vir_mem_per_a], ["Memory Available(%)", mem_av_per_b, mem_av_per_a]]
   253|         0|            0|            0|  0.00%|    # print(tabulate(CPU_table, headers=["Metric", "Before Training", "After Training"], tablefmt="pretty"))
   254|         0|            0|            0|  0.00%|    with open('CPU_table.txt', 'w') as f:
   255|         0|            0|            0|  0.00%|        # f.write(tabulate(CPU_table, headers=["Metric", "Before Training", "After Training"], tablefmt="pretty"))
   256|         0|            0|            0|  0.00%|        f.write("BEFORE TRAINING:--------\n")
   257|         0|            0|            0|  0.00%|        f.write("CPU USAGE(%):")
   258|         0|            0|            0|  0.00%|        f.write(str(cpu_per_b))
   259|         0|            0|            0|  0.00%|        f.write("\n")
   260|         0|            0|            0|  0.00%|        f.write("MEMORY USE:")
   261|         0|            0|            0|  0.00%|        f.write(str(vir_mem_b))
   262|         0|            0|            0|  0.00%|        f.write("\n")
   263|         0|            0|            0|  0.00%|        f.write("MEMORY USE(%):")
   264|         0|            0|            0|  0.00%|        f.write(str(vir_mem_per_b))
   265|         0|            0|            0|  0.00%|        f.write("\n")
   266|         0|            0|            0|  0.00%|        f.write("MEMORY AVAIL(%):")
   267|         0|            0|            0|  0.00%|        f.write(str(mem_av_per_b))
   268|         0|            0|            0|  0.00%|        f.write("\n")
   269|         0|            0|            0|  0.00%|        f.write("\n\n\n\n")
   270|         0|            0|            0|  0.00%|        f.write("AFTER TRAINING:---------\n")
   271|         0|            0|            0|  0.00%|        f.write("CPU USAGE(%):")
   272|         0|            0|            0|  0.00%|        f.write(str(cpu_per_a))
   273|         0|            0|            0|  0.00%|        f.write("\n")
   274|         0|            0|            0|  0.00%|        f.write("MEMORY USE:")
   275|         0|            0|            0|  0.00%|        f.write(str(vir_mem_a))
   276|         0|            0|            0|  0.00%|        f.write("\n")
   277|         0|            0|            0|  0.00%|        f.write("MEMORY USE(%):")
   278|         0|            0|            0|  0.00%|        f.write(str(vir_mem_per_a))
   279|         0|            0|            0|  0.00%|        f.write("\n")
   280|         0|            0|            0|  0.00%|        f.write("MEMORY AVAIL(%):")
   281|         0|            0|            0|  0.00%|        f.write(str(mem_av_per_a))
   282|         0|            0|            0|  0.00%|        f.write("\n")
   283|         0|            0|            0|  0.00%|    f.close()
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    result = io.StringIO()
   286|         0|            0|            0|  0.00%|    pstats.Stats(pr, stream=result).print_stats()
   287|         0|            0|            0|  0.00%|    result = result.getvalue()
   288|         0|            0|            0|  0.00%|    # chop the string into a csv-like buffer
   289|         0|            0|            0|  0.00%|    result = 'ncalls' + result.split('ncalls')[-1]
   290|         0|            0|            0|  0.00%|    result = '\n'.join([','.join(line.rstrip().split(None, 5)) for line in result.split('\n')])
   291|         0|            0|            0|  0.00%|    # save it to disk
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    with open('memory_logs.csv', 'w+') as f:
   294|         0|            0|            0|  0.00%|        # f=open(result.rsplit('.')[0]+'.csv','w')
   295|         0|            0|            0|  0.00%|        f.write(result)
   296|         0|            0|            0|  0.00%|        f.close()
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    # # ps = pstats.Stats(pr, stream=sys.stdout)
   299|         0|            0|            0|  0.00%|    # s = io.StringIO()
   300|         0|            0|            0|  0.00%|    # ps = pstats.Stats(pr, stream=s).sort_stats('tottime')
   301|         0|            0|            0|  0.00%|    # # ps.print_stats()
   302|         0|            0|            0|  0.00%|    #
   303|         0|            0|            0|  0.00%|    # with open('memory_logs.txt', 'w+') as f:
   304|         0|            0|            0|  0.00%|    #     f.write(s.getvalue())
   305|         0|            0|            0|  0.00%|    # f.close()
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    # data_cpu = pd.read_csv("energy_pyRAPL.csv")
   308|         0|            0|            0|  0.00%|    # Preview the first 5 lines of the loaded data
   309|         0|            0|            0|  0.00%|    # data_cpu.head()
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    # visualize_model(model_ft)
